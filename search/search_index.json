{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"iCal-library Fast, yet simple, iCalendar reader with excellent recurrence support. RFC 5545 compliant. Documentation : https://jorricks.github.io/iCal-library/ Source Code : https://github.com/Jorricks/iCal-library iCal-library is a Python library for anyone who wishes to read any iCalendar file. It is one of the fastest iCalender python library out there and has excellent support for recurring events. Now there is truly no reason to miss an event, ever. This project is under active development. You may encounter items on which we can improve, please file an issue if you encounter any issue or create a feature request for any missing feature. Features \ud83d\ude80 Easy python interface. It's as simple as ' client.load_ics_file(\"<my_file>\").timeline ' to show all your events of that week. \ud83d\udcc8 Timeline support. Show exactly what is planned for a specific week. \u2728 Fully functional support for recurring iCal components. E.g. Any recurring event will show up as intended within the timeline interface. This includes: Recurring components/events based on RRule. Recurring components/events based on RDate. Excluding components/events based on EXDate. Any combination of the above three. Redefined/changed components/events correctly show the latest version. \u23e9 Very fast parsing due to lazy evaluation of iCal properties. \u2049\ufe0f Debugger supported. Any issues? Open up a debugger and inspect all values. \ud83d\udd05 Minimal dependencies. Only python-dateutil and pendulum . \ud83c\udd8e Fully typed code base. Installation To use iCal-library, first install it using pip: pip install iCal-library Installed Requirements Python 3.8+ iCal-library uses two major libraries for their date and time utilities: - Pendulum for its extensions on datetime objects and parsing of durations. - Python-Dateutil for its RRule support. Example A simple example. Please look in the docs for more examples. from ical_library import client calendar = client . parse_icalendar_file ( \"/home/user/my_icalendar.ics\" ) print ( calendar . events ) print ( calendar . todos ) print ( calendar . journals ) print ( calendar . free_busy_list ) print ( calendar . time_zones ) During experimentation, it is recommended to use a Python Debugger. iCal-library is fully Debugger compliant, meaning it is very easy to use a debugger with this project. It will be much faster to see all the different attributes and functions from inside a Python debugger. If you are unsure whether your IDE supports it, take a look here under the sections 'IDEs with Debug Capabilities'. Limitations Currently, it is not supported to write ICS files. If this is a deal-breaker for you, it should be relatively straight forward to add it, so please consider submitting a PR for this :).","title":"Home"},{"location":"#ical-library","text":"Fast, yet simple, iCalendar reader with excellent recurrence support. RFC 5545 compliant. Documentation : https://jorricks.github.io/iCal-library/ Source Code : https://github.com/Jorricks/iCal-library iCal-library is a Python library for anyone who wishes to read any iCalendar file. It is one of the fastest iCalender python library out there and has excellent support for recurring events. Now there is truly no reason to miss an event, ever. This project is under active development. You may encounter items on which we can improve, please file an issue if you encounter any issue or create a feature request for any missing feature.","title":"iCal-library"},{"location":"#features","text":"\ud83d\ude80 Easy python interface. It's as simple as ' client.load_ics_file(\"<my_file>\").timeline ' to show all your events of that week. \ud83d\udcc8 Timeline support. Show exactly what is planned for a specific week. \u2728 Fully functional support for recurring iCal components. E.g. Any recurring event will show up as intended within the timeline interface. This includes: Recurring components/events based on RRule. Recurring components/events based on RDate. Excluding components/events based on EXDate. Any combination of the above three. Redefined/changed components/events correctly show the latest version. \u23e9 Very fast parsing due to lazy evaluation of iCal properties. \u2049\ufe0f Debugger supported. Any issues? Open up a debugger and inspect all values. \ud83d\udd05 Minimal dependencies. Only python-dateutil and pendulum . \ud83c\udd8e Fully typed code base.","title":"Features"},{"location":"#installation","text":"To use iCal-library, first install it using pip: pip install iCal-library Installed","title":"Installation"},{"location":"#requirements","text":"Python 3.8+ iCal-library uses two major libraries for their date and time utilities: - Pendulum for its extensions on datetime objects and parsing of durations. - Python-Dateutil for its RRule support.","title":"Requirements"},{"location":"#example","text":"A simple example. Please look in the docs for more examples. from ical_library import client calendar = client . parse_icalendar_file ( \"/home/user/my_icalendar.ics\" ) print ( calendar . events ) print ( calendar . todos ) print ( calendar . journals ) print ( calendar . free_busy_list ) print ( calendar . time_zones ) During experimentation, it is recommended to use a Python Debugger. iCal-library is fully Debugger compliant, meaning it is very easy to use a debugger with this project. It will be much faster to see all the different attributes and functions from inside a Python debugger. If you are unsure whether your IDE supports it, take a look here under the sections 'IDEs with Debug Capabilities'.","title":"Example"},{"location":"#limitations","text":"Currently, it is not supported to write ICS files. If this is a deal-breaker for you, it should be relatively straight forward to add it, so please consider submitting a PR for this :).","title":"Limitations"},{"location":"faq/","text":"FAQ Why did you create this library and not use one of the existing libraries? I first tried several libraries for iCalendar events. However, none of them supported recurring events as well as they should be. For some libraries my calendar loaded but then didn't show my recurring events, while others simply threw stacktraces trying to load it. Furthermore, I noticed that my calendar (with over 2000 events) took ages to load. After traversing the code of the other libraries I decided I wanted to build my own. With some key principles that were lacking in most of the libraries: Recurring components should work, always, FOREVER. No strict evaluation that could lead to errors while parsing the file. Lazy evaluation for iCalendar properties to speed up the process. Perfect typing information. Striving for no open issues & especially no open pull requests that are waiting for feedback!","title":"Frequently asked questions"},{"location":"faq/#faq","text":"Why did you create this library and not use one of the existing libraries? I first tried several libraries for iCalendar events. However, none of them supported recurring events as well as they should be. For some libraries my calendar loaded but then didn't show my recurring events, while others simply threw stacktraces trying to load it. Furthermore, I noticed that my calendar (with over 2000 events) took ages to load. After traversing the code of the other libraries I decided I wanted to build my own. With some key principles that were lacking in most of the libraries: Recurring components should work, always, FOREVER. No strict evaluation that could lead to errors while parsing the file. Lazy evaluation for iCalendar properties to speed up the process. Perfect typing information. Striving for no open issues & especially no open pull requests that are waiting for feedback!","title":"FAQ"},{"location":"release-notes/","text":"Release Notes 0.2.3 Pendulum pinning This version is there to pin the pendulum version. Two changes: - \ud83d\udccc Pin pendulum to <3.0.0 - \u2705 Update tests for compatibility with different timezones 0.2.2 BugFix release This is a minor release to solve a critical bug. It occurred when it is expanding a recurring event with a start date in dates for a range defined by dates. - \ud83d\udc1b RRule expansion failing where event.start_date==return_range.start. 0.2.1 Documentation update A minor update to improve documentation: - \ud83d\udcdd Remove workflow badge - \u2b06\ufe0f Add Python 3.11 & 3.12 support 0.2.0 Release to improve timezone offset changes support This release contains some bugfixes and a major improvement to also support timezone offset changes over time. Thereby, recurring events for timezones that have Daylight saving time now correctly change according to the VTIMEZONE definition. Furthermore, EXDATE (so excluding a single occurrence from a recurring event) now correctly handles timezones. Previously it did not exclude EXDATE's with a Timezone correctly. This release fixes that. \u2728 Support offset changes in a sequence of recurring events. \ud83d\udc1b Return only recurring items in Timespan range. \ud83d\udc1b EXDate now takes TZID into account. \ud83d\udcdd Make pipeline name more generic. 0.1.0 Code structure release This release mostly contains general improvements to the code base with some minor bugfixes. \ud83d\udcdd Add emoji to features docs. \u2705 Add tests for CalAddress. \ud83d\udc1b Defaultlist gave None when using .get . \ud83d\udc1b Function arg date type should match other arg. \ud83d\udc1b Remove unwanted commented code. \ud83d\udc1b Remove unwanted print. \ud83c\udfa8 Update name of package on Pypi. \ud83d\udcdd Update buttons. 0.0.1a1 BugFix release This release contains some updates to the release process. \ud83d\udcdd Update PyPi package description. \ud83d\udd27 Remove auto tagging pipeline. \ud83d\ude80 0.0.1a0 Initial release The initial release of the package. Some turbulence expected. \u2705 Easy python interface. It's as simple as ' client.load_ics_file(\"<my_file>\").timeline ' to show all your events of that week. \ud83d\udcc8 Timeline support. Show exactly what is planned for a specific week. \ud83d\udc4c Fully functional support for recurring iCal components. E.g. Any recurring event will show up as intended within the timeline interface. This includes: Recurring components/events based on RRule. Recurring components/events based on RDate. Excluding components/events based on EXDate. Any combination of the above three. Redefined/changed components/events correctly show the latest version. \u26a1\ufe0f Very fast parsing due to lazy evaluation of iCal properties. \u2728 Debugger supported. Any issues? Open up a debugger and inspect all values. \ud83d\udd25 Minimal dependencies. Only python-dateutil and pendulum . \ud83d\udcdd Fully documented code base. \ud83c\udff7\ufe0f Fully typed code base.","title":"Release notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#023-pendulum-pinning","text":"This version is there to pin the pendulum version. Two changes: - \ud83d\udccc Pin pendulum to <3.0.0 - \u2705 Update tests for compatibility with different timezones","title":"0.2.3 Pendulum pinning"},{"location":"release-notes/#022-bugfix-release","text":"This is a minor release to solve a critical bug. It occurred when it is expanding a recurring event with a start date in dates for a range defined by dates. - \ud83d\udc1b RRule expansion failing where event.start_date==return_range.start.","title":"0.2.2 BugFix release"},{"location":"release-notes/#021-documentation-update","text":"A minor update to improve documentation: - \ud83d\udcdd Remove workflow badge - \u2b06\ufe0f Add Python 3.11 & 3.12 support","title":"0.2.1 Documentation update"},{"location":"release-notes/#020-release-to-improve-timezone-offset-changes-support","text":"This release contains some bugfixes and a major improvement to also support timezone offset changes over time. Thereby, recurring events for timezones that have Daylight saving time now correctly change according to the VTIMEZONE definition. Furthermore, EXDATE (so excluding a single occurrence from a recurring event) now correctly handles timezones. Previously it did not exclude EXDATE's with a Timezone correctly. This release fixes that. \u2728 Support offset changes in a sequence of recurring events. \ud83d\udc1b Return only recurring items in Timespan range. \ud83d\udc1b EXDate now takes TZID into account. \ud83d\udcdd Make pipeline name more generic.","title":"0.2.0 Release to improve timezone offset changes support"},{"location":"release-notes/#010-code-structure-release","text":"This release mostly contains general improvements to the code base with some minor bugfixes. \ud83d\udcdd Add emoji to features docs. \u2705 Add tests for CalAddress. \ud83d\udc1b Defaultlist gave None when using .get . \ud83d\udc1b Function arg date type should match other arg. \ud83d\udc1b Remove unwanted commented code. \ud83d\udc1b Remove unwanted print. \ud83c\udfa8 Update name of package on Pypi. \ud83d\udcdd Update buttons.","title":"0.1.0 Code structure release"},{"location":"release-notes/#001a1-bugfix-release","text":"This release contains some updates to the release process. \ud83d\udcdd Update PyPi package description. \ud83d\udd27 Remove auto tagging pipeline.","title":"0.0.1a1 BugFix release"},{"location":"release-notes/#001a0-initial-release","text":"The initial release of the package. Some turbulence expected. \u2705 Easy python interface. It's as simple as ' client.load_ics_file(\"<my_file>\").timeline ' to show all your events of that week. \ud83d\udcc8 Timeline support. Show exactly what is planned for a specific week. \ud83d\udc4c Fully functional support for recurring iCal components. E.g. Any recurring event will show up as intended within the timeline interface. This includes: Recurring components/events based on RRule. Recurring components/events based on RDate. Excluding components/events based on EXDate. Any combination of the above three. Redefined/changed components/events correctly show the latest version. \u26a1\ufe0f Very fast parsing due to lazy evaluation of iCal properties. \u2728 Debugger supported. Any issues? Open up a debugger and inspect all values. \ud83d\udd25 Minimal dependencies. Only python-dateutil and pendulum . \ud83d\udcdd Fully documented code base. \ud83c\udff7\ufe0f Fully typed code base.","title":"\ud83d\ude80 0.0.1a0 Initial release"},{"location":"remote-icalendars/","text":"Remote iCalendars Here are some more in-depth use-cases Integration status. Google Calendar: . Works with private and public calendars. Also works when you are part of an organisation that does not allow plugins. Microsoft Outlook: . Requires you to make your calendar public. Apple Calendar: . Unable to find any info on how to make calendars public. Getting the iCalendar URL for remote calendars. Before we can actually load in the data of your calendar, we need to get the iCalendar URL. The steps are different per host, some of them are listed here: Google Calendar: \"Getting your secret address in iCal format\" Microsoft Outlook: \"Publish your Calendar\" Info This package is actively tested with Google iCalendars. If you have any other calendars and encounter odd behaviour, please file a Github feature request or a Github Issue. Reading your iCalendar from a remote place Follow one of the above-mentioned tutorial to get the iCalendar URL. Verify that when you open the URL in your browser, it shows a page or downloads a file that begins with BEGIN:VCALENDAR . Use the client.parse_icalendar_url() to get it directly. from ical_library import client calendar = client . parse_icalendar_url ( \"https://calendar.google.com/calendar/ical/xxxxxx/private-xxxxxx/basic.ics\" ) print ( calendar . events ) Reading your iCalendar from a remote place with rate limiting To help you avoid doing unnecessary requests to your iCalendar provider, there is a CacheClient . This helps you cache the result on a location on your Hard Drive to avoid the need to fetch it every time you restart your application. from pathlib import Path from pendulum import Duration from ical_library.cache_client import CacheClient cache_client = CacheClient ( url = \"https://calendar.google.com/calendar/ical/xxxxxx/private-xxxxxx/basic.ics\" , cache_location = Path . home () / \"ical-library-cache\" , cache_ttl = Duration ( hours = 1 ), verbose = True , ) calendar = cache_client . get_icalendar () print ( calendar . events ) Info If you have a production use-case for a 24/7 running service, you might be better of doing the caching/rate-limiting in your service.","title":"Remote iCalendar"},{"location":"remote-icalendars/#remote-icalendars","text":"Here are some more in-depth use-cases","title":"Remote iCalendars"},{"location":"remote-icalendars/#integration-status","text":"Google Calendar: . Works with private and public calendars. Also works when you are part of an organisation that does not allow plugins. Microsoft Outlook: . Requires you to make your calendar public. Apple Calendar: . Unable to find any info on how to make calendars public.","title":"Integration status."},{"location":"remote-icalendars/#getting-the-icalendar-url-for-remote-calendars","text":"Before we can actually load in the data of your calendar, we need to get the iCalendar URL. The steps are different per host, some of them are listed here: Google Calendar: \"Getting your secret address in iCal format\" Microsoft Outlook: \"Publish your Calendar\" Info This package is actively tested with Google iCalendars. If you have any other calendars and encounter odd behaviour, please file a Github feature request or a Github Issue.","title":"Getting the iCalendar URL for remote calendars."},{"location":"remote-icalendars/#reading-your-icalendar-from-a-remote-place","text":"Follow one of the above-mentioned tutorial to get the iCalendar URL. Verify that when you open the URL in your browser, it shows a page or downloads a file that begins with BEGIN:VCALENDAR . Use the client.parse_icalendar_url() to get it directly. from ical_library import client calendar = client . parse_icalendar_url ( \"https://calendar.google.com/calendar/ical/xxxxxx/private-xxxxxx/basic.ics\" ) print ( calendar . events )","title":"Reading your iCalendar from a remote place"},{"location":"remote-icalendars/#reading-your-icalendar-from-a-remote-place-with-rate-limiting","text":"To help you avoid doing unnecessary requests to your iCalendar provider, there is a CacheClient . This helps you cache the result on a location on your Hard Drive to avoid the need to fetch it every time you restart your application. from pathlib import Path from pendulum import Duration from ical_library.cache_client import CacheClient cache_client = CacheClient ( url = \"https://calendar.google.com/calendar/ical/xxxxxx/private-xxxxxx/basic.ics\" , cache_location = Path . home () / \"ical-library-cache\" , cache_ttl = Duration ( hours = 1 ), verbose = True , ) calendar = cache_client . get_icalendar () print ( calendar . events ) Info If you have a production use-case for a 24/7 running service, you might be better of doing the caching/rate-limiting in your service.","title":"Reading your iCalendar from a remote place with rate limiting"},{"location":"timeline/","text":"TimeLine","title":"Timeline"},{"location":"timeline/#timeline","text":"","title":"TimeLine"},{"location":"code/cache_client/","text":"The client for remote calendars with builtin cache support When you have a service that periodically runs, and you don't want to fetch a new version of your calendar each time, this is the go-to place. CacheClient A iCalendar client which takes care of caching the result for you. This avoids you needing to handle the caching. Parameters: Name Type Description Default cache_location Union [ Path , str ] A path to the cache. Can be relative or absolute references. When you pass in a value with a file extension, it is considered to be a directory, otherwise it's considered as a file reference. required cache_ttl Union [ Duration ] The time-to-live for the cache. The cache will be deleted/refreshed once it is older than the TTL. Duration (hours=1) verbose bool Print verbose messages regarding cache usage. True url str The URL to the iCalendar file. required Source code in ical_library/cache_client.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class CacheClient : \"\"\" A iCalendar client which takes care of caching the result for you. This avoids you needing to handle the caching. :param cache_location: A path to the cache. Can be relative or absolute references. When you pass in a value with a file extension, it is considered to be a directory, otherwise it's considered as a file reference. :param cache_ttl: The time-to-live for the cache. The cache will be deleted/refreshed once it is older than the TTL. :param verbose: Print verbose messages regarding cache usage. :param url: The URL to the iCalendar file. \"\"\" def __init__ ( self , url : str , cache_location : Union [ Path , str ], cache_ttl : Union [ Duration ] = Duration ( hours = 1 ), verbose : bool = True , ): self . url : str = url self . cache_location : Path = Path ( cache_location ) self . cache_ttl : Duration = cache_ttl self . verbose = verbose @property def cache_file_path ( self ) -> Path : \"\"\"Return the filepath to the cache for the given URL.\"\"\" if self . cache_location . suffix == \"\" : return self . cache_location / hashlib . md5 ( self . url . encode ()) . hexdigest () return self . cache_location def get_icalendar ( self , ** kwargs : Any ) -> VCalendar : \"\"\" Get a parsed VCalendar instance. If there is an active cache, return that, otherwise fetch and cache the result. :param kwargs: Any keyword arguments to pass onto the `urllib.request.urlopen` call. :return: a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. \"\"\" if not self . _is_cache_expired (): if self . verbose : print ( \"Using cache to remove this folder.\" ) return client . parse_icalendar_file ( self . cache_file_path ) self . _purge_icalendar_cache () response = request . urlopen ( self . url , ** kwargs ) if not ( 200 <= response . getcode () < 400 ): raise ValueError ( f \"Unable to execute request at { self . url =} . Response code was: { response . getcode () } .\" ) text = response . read () . decode ( \"utf-8\" ) self . _write_response_to_cache ( text ) lines = text . split ( \" \\n \" ) return client . parse_lines_into_calendar ( lines ) def _write_response_to_cache ( self , text : str ) -> None : \"\"\" Write the response of the fetched URL to cache. :param text: The fetched result. \"\"\" if self . verbose : print ( f \"Successfully loaded new iCalendar data and stored it at { self . cache_file_path } .\" ) self . cache_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( self . cache_file_path , \"w\" ) as file : file . write ( text ) def _purge_icalendar_cache ( self ) -> None : \"\"\"Purge the cache we have for this Calendar.\"\"\" if self . verbose : print ( f \"Cache was expired. Removed { self . cache_file_path } .\" ) return self . cache_file_path . unlink () def _is_cache_expired ( self ) -> bool : \"\"\"Return whether the cache is passed its expiration date.\"\"\" cutoff = DateTime . utcnow () - self . cache_ttl mtime = DateTime . utcfromtimestamp ( os . path . getmtime ( self . cache_file_path )) return mtime < cutoff cache_file_path : Path property Return the filepath to the cache for the given URL. _is_cache_expired () Return whether the cache is passed its expiration date. Source code in ical_library/cache_client.py 82 83 84 85 86 def _is_cache_expired ( self ) -> bool : \"\"\"Return whether the cache is passed its expiration date.\"\"\" cutoff = DateTime . utcnow () - self . cache_ttl mtime = DateTime . utcfromtimestamp ( os . path . getmtime ( self . cache_file_path )) return mtime < cutoff _purge_icalendar_cache () Purge the cache we have for this Calendar. Source code in ical_library/cache_client.py 76 77 78 79 80 def _purge_icalendar_cache ( self ) -> None : \"\"\"Purge the cache we have for this Calendar.\"\"\" if self . verbose : print ( f \"Cache was expired. Removed { self . cache_file_path } .\" ) return self . cache_file_path . unlink () _write_response_to_cache ( text ) Write the response of the fetched URL to cache. Parameters: Name Type Description Default text str The fetched result. required Source code in ical_library/cache_client.py 65 66 67 68 69 70 71 72 73 74 def _write_response_to_cache ( self , text : str ) -> None : \"\"\" Write the response of the fetched URL to cache. :param text: The fetched result. \"\"\" if self . verbose : print ( f \"Successfully loaded new iCalendar data and stored it at { self . cache_file_path } .\" ) self . cache_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( self . cache_file_path , \"w\" ) as file : file . write ( text ) get_icalendar ( ** kwargs ) Get a parsed VCalendar instance. If there is an active cache, return that, otherwise fetch and cache the result. Parameters: Name Type Description Default kwargs Any Any keyword arguments to pass onto the urllib.request.urlopen call. {} Returns: Type Description VCalendar a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. Source code in ical_library/cache_client.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_icalendar ( self , ** kwargs : Any ) -> VCalendar : \"\"\" Get a parsed VCalendar instance. If there is an active cache, return that, otherwise fetch and cache the result. :param kwargs: Any keyword arguments to pass onto the `urllib.request.urlopen` call. :return: a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. \"\"\" if not self . _is_cache_expired (): if self . verbose : print ( \"Using cache to remove this folder.\" ) return client . parse_icalendar_file ( self . cache_file_path ) self . _purge_icalendar_cache () response = request . urlopen ( self . url , ** kwargs ) if not ( 200 <= response . getcode () < 400 ): raise ValueError ( f \"Unable to execute request at { self . url =} . Response code was: { response . getcode () } .\" ) text = response . read () . decode ( \"utf-8\" ) self . _write_response_to_cache ( text ) lines = text . split ( \" \\n \" ) return client . parse_lines_into_calendar ( lines )","title":"Cached Client"},{"location":"code/cache_client/#the-client-for-remote-calendars-with-builtin-cache-support","text":"When you have a service that periodically runs, and you don't want to fetch a new version of your calendar each time, this is the go-to place.","title":"The client for remote calendars with builtin cache support"},{"location":"code/cache_client/#ical_library.CacheClient","text":"A iCalendar client which takes care of caching the result for you. This avoids you needing to handle the caching. Parameters: Name Type Description Default cache_location Union [ Path , str ] A path to the cache. Can be relative or absolute references. When you pass in a value with a file extension, it is considered to be a directory, otherwise it's considered as a file reference. required cache_ttl Union [ Duration ] The time-to-live for the cache. The cache will be deleted/refreshed once it is older than the TTL. Duration (hours=1) verbose bool Print verbose messages regarding cache usage. True url str The URL to the iCalendar file. required Source code in ical_library/cache_client.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class CacheClient : \"\"\" A iCalendar client which takes care of caching the result for you. This avoids you needing to handle the caching. :param cache_location: A path to the cache. Can be relative or absolute references. When you pass in a value with a file extension, it is considered to be a directory, otherwise it's considered as a file reference. :param cache_ttl: The time-to-live for the cache. The cache will be deleted/refreshed once it is older than the TTL. :param verbose: Print verbose messages regarding cache usage. :param url: The URL to the iCalendar file. \"\"\" def __init__ ( self , url : str , cache_location : Union [ Path , str ], cache_ttl : Union [ Duration ] = Duration ( hours = 1 ), verbose : bool = True , ): self . url : str = url self . cache_location : Path = Path ( cache_location ) self . cache_ttl : Duration = cache_ttl self . verbose = verbose @property def cache_file_path ( self ) -> Path : \"\"\"Return the filepath to the cache for the given URL.\"\"\" if self . cache_location . suffix == \"\" : return self . cache_location / hashlib . md5 ( self . url . encode ()) . hexdigest () return self . cache_location def get_icalendar ( self , ** kwargs : Any ) -> VCalendar : \"\"\" Get a parsed VCalendar instance. If there is an active cache, return that, otherwise fetch and cache the result. :param kwargs: Any keyword arguments to pass onto the `urllib.request.urlopen` call. :return: a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. \"\"\" if not self . _is_cache_expired (): if self . verbose : print ( \"Using cache to remove this folder.\" ) return client . parse_icalendar_file ( self . cache_file_path ) self . _purge_icalendar_cache () response = request . urlopen ( self . url , ** kwargs ) if not ( 200 <= response . getcode () < 400 ): raise ValueError ( f \"Unable to execute request at { self . url =} . Response code was: { response . getcode () } .\" ) text = response . read () . decode ( \"utf-8\" ) self . _write_response_to_cache ( text ) lines = text . split ( \" \\n \" ) return client . parse_lines_into_calendar ( lines ) def _write_response_to_cache ( self , text : str ) -> None : \"\"\" Write the response of the fetched URL to cache. :param text: The fetched result. \"\"\" if self . verbose : print ( f \"Successfully loaded new iCalendar data and stored it at { self . cache_file_path } .\" ) self . cache_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( self . cache_file_path , \"w\" ) as file : file . write ( text ) def _purge_icalendar_cache ( self ) -> None : \"\"\"Purge the cache we have for this Calendar.\"\"\" if self . verbose : print ( f \"Cache was expired. Removed { self . cache_file_path } .\" ) return self . cache_file_path . unlink () def _is_cache_expired ( self ) -> bool : \"\"\"Return whether the cache is passed its expiration date.\"\"\" cutoff = DateTime . utcnow () - self . cache_ttl mtime = DateTime . utcfromtimestamp ( os . path . getmtime ( self . cache_file_path )) return mtime < cutoff","title":"CacheClient"},{"location":"code/cache_client/#ical_library.CacheClient.cache_file_path","text":"Return the filepath to the cache for the given URL.","title":"cache_file_path"},{"location":"code/cache_client/#ical_library.CacheClient._is_cache_expired","text":"Return whether the cache is passed its expiration date. Source code in ical_library/cache_client.py 82 83 84 85 86 def _is_cache_expired ( self ) -> bool : \"\"\"Return whether the cache is passed its expiration date.\"\"\" cutoff = DateTime . utcnow () - self . cache_ttl mtime = DateTime . utcfromtimestamp ( os . path . getmtime ( self . cache_file_path )) return mtime < cutoff","title":"_is_cache_expired"},{"location":"code/cache_client/#ical_library.CacheClient._purge_icalendar_cache","text":"Purge the cache we have for this Calendar. Source code in ical_library/cache_client.py 76 77 78 79 80 def _purge_icalendar_cache ( self ) -> None : \"\"\"Purge the cache we have for this Calendar.\"\"\" if self . verbose : print ( f \"Cache was expired. Removed { self . cache_file_path } .\" ) return self . cache_file_path . unlink ()","title":"_purge_icalendar_cache"},{"location":"code/cache_client/#ical_library.CacheClient._write_response_to_cache","text":"Write the response of the fetched URL to cache. Parameters: Name Type Description Default text str The fetched result. required Source code in ical_library/cache_client.py 65 66 67 68 69 70 71 72 73 74 def _write_response_to_cache ( self , text : str ) -> None : \"\"\" Write the response of the fetched URL to cache. :param text: The fetched result. \"\"\" if self . verbose : print ( f \"Successfully loaded new iCalendar data and stored it at { self . cache_file_path } .\" ) self . cache_file_path . parent . mkdir ( parents = True , exist_ok = True ) with open ( self . cache_file_path , \"w\" ) as file : file . write ( text )","title":"_write_response_to_cache"},{"location":"code/cache_client/#ical_library.CacheClient.get_icalendar","text":"Get a parsed VCalendar instance. If there is an active cache, return that, otherwise fetch and cache the result. Parameters: Name Type Description Default kwargs Any Any keyword arguments to pass onto the urllib.request.urlopen call. {} Returns: Type Description VCalendar a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. Source code in ical_library/cache_client.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def get_icalendar ( self , ** kwargs : Any ) -> VCalendar : \"\"\" Get a parsed VCalendar instance. If there is an active cache, return that, otherwise fetch and cache the result. :param kwargs: Any keyword arguments to pass onto the `urllib.request.urlopen` call. :return: a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. \"\"\" if not self . _is_cache_expired (): if self . verbose : print ( \"Using cache to remove this folder.\" ) return client . parse_icalendar_file ( self . cache_file_path ) self . _purge_icalendar_cache () response = request . urlopen ( self . url , ** kwargs ) if not ( 200 <= response . getcode () < 400 ): raise ValueError ( f \"Unable to execute request at { self . url =} . Response code was: { response . getcode () } .\" ) text = response . read () . decode ( \"utf-8\" ) self . _write_response_to_cache ( text ) lines = text . split ( \" \\n \" ) return client . parse_lines_into_calendar ( lines )","title":"get_icalendar"},{"location":"code/calendar/","text":"Documentation for your first returned item: VCalendar Once you imported the iCal-library library, you can use either the client or CacheCLient to get a VCalendar object. This page explains all the functions and attributes of the VCalendar object. VCalendar Bases: Component This class represents the VCALENDAR component specified in RFC 5545 in '3.6. Calendar Components'. The \"VCALENDAR\" component consists of a sequence of calendar properties and one or more calendar components. The calendar properties are attributes that apply to the calendar object as a whole. The calendar components are collections of properties that express a particular calendar semantic. For example, the calendar component can specify an event, a to-do, a journal entry, time zone information, free/busy time information, or an alarm. Parameters: Name Type Description Default prodid Optional [ ProdID ] The ProdID property. Required and must occur exactly once. None version Optional [ Version ] The Version property. Required and must occur exactly once. None calscale Optional [ CalScale ] The CalScale property. Optional, but may occur at most once. None method Optional [ Method ] The Method property. Optional, but may occur at most once. None events Optional [ List [ VEvent ]] Optional list of VEvent components. Each component may occur multiple times. None todos Optional [ List [ VToDo ]] Optional list of VToDo components. Each component may occur multiple times. None journals Optional [ List [ VJournal ]] Optional list of VJournal components. Each component may occur multiple times. None free_busy_list Optional [ List [ VFreeBusy ]] Optional list of VFreeBusy components. Each component may occur multiple times. None time_zones Optional [ List [ VTimeZone ]] Optional list of VTimeZone components. Each component may occur multiple times. None Source code in ical_library/ical_components/v_calendar.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class VCalendar ( Component ): \"\"\" This class represents the VCALENDAR component specified in RFC 5545 in '3.6. Calendar Components'. The \"VCALENDAR\" component consists of a sequence of calendar properties and one or more calendar components. The calendar properties are attributes that apply to the calendar object as a whole. The calendar components are collections of properties that express a particular calendar semantic. For example, the calendar component can specify an event, a to-do, a journal entry, time zone information, free/busy time information, or an alarm. :param prodid: The ProdID property. Required and must occur exactly once. :param version: The Version property. Required and must occur exactly once. :param calscale: The CalScale property. Optional, but may occur at most once. :param method: The Method property. Optional, but may occur at most once. :param events: Optional list of VEvent components. Each component may occur multiple times. :param todos: Optional list of VToDo components. Each component may occur multiple times. :param journals: Optional list of VJournal components. Each component may occur multiple times. :param free_busy_list: Optional list of VFreeBusy components. Each component may occur multiple times. :param time_zones: Optional list of VTimeZone components. Each component may occur multiple times. \"\"\" def __init__ ( self , prodid : Optional [ ProdID ] = None , version : Optional [ Version ] = None , calscale : Optional [ CalScale ] = None , method : Optional [ Method ] = None , events : Optional [ List [ VEvent ]] = None , todos : Optional [ List [ VToDo ]] = None , journals : Optional [ List [ VJournal ]] = None , free_busy_list : Optional [ List [ VFreeBusy ]] = None , time_zones : Optional [ List [ VTimeZone ]] = None , ): super () . __init__ ( \"VCALENDAR\" ) # Required properties, only one occurrence allowed. self . _prodid : Optional [ ProdID ] = self . as_parent ( prodid ) self . _version : Optional [ Version ] = self . as_parent ( version ) # Optional properties, must not occur more than once. self . calscale : Optional [ CalScale ] = self . as_parent ( calscale ) self . method : Optional [ Method ] = self . as_parent ( method ) # These are children Components self . events : List [ VEvent ] = events or [] self . todos : List [ VToDo ] = todos or [] self . journals : List [ VJournal ] = journals or [] self . free_busy_list : List [ VFreeBusy ] = free_busy_list or [] self . time_zones : List [ VTimeZone ] = time_zones or [] # Only the VCalender stores the entire list. self . _lines : Optional [ List [ str ]] = None def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VCalendar( { self . prodid . value } , { self . version . value } )\" @property def prodid ( self ) -> ProdID : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _prodid is None : raise MissingRequiredProperty ( self , \"prodid\" ) return self . _prodid @prodid . setter def prodid ( self , value : ProdID ): \"\"\"A setter to set the required property.\"\"\" self . _prodid = value @property def version ( self ) -> Version : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _version is None : raise MissingRequiredProperty ( self , \"version\" ) return self . _version @version . setter def version ( self , value : Version ): \"\"\"A setter to set the required property.\"\"\" self . _version = value @property def calendar_scale ( self ) -> str : \"\"\"Return the calendar scale according to RFC 5545.\"\"\" return self . calscale . value if self . calscale else \"GREGORIAN\" def get_timezone ( self , tzid : str ) -> VTimeZone : \"\"\"Get the corresponding VTimeZone object based on the given timezone identifier.\"\"\" for timezone in self . time_zones : if timezone . tzid . value == tzid : return timezone raise ValueError ( f \"Could not find Timezone with { tzid =} .\" ) def get_aware_dt_for_timezone ( self , dt : DateTime , tzid : str ) -> DateTime : \"\"\"Return the timezone aware DateTime object for a given TimeZone identifier.\"\"\" return self . get_timezone ( tzid ) . convert_naive_datetime_to_aware ( dt ) @property def timeline ( self ) -> \"Timeline\" : \"\"\"Return a timeline of VEvents from 1970-00-00T00:00:00 to 2100-00-00T00:00:00.\"\"\" from ical_library.timeline import Timeline return Timeline ( self ) def get_limited_timeline ( self , start : Optional [ DateTime ], end : Optional [ DateTime ]) -> \"Timeline\" : \"\"\" Return a timeline of VEvents limited by *start* and *end* :param start: Only include events in the timeline with a starting date later than this value. :param end: Only include events in the timeline with a starting date earlier than this value. \"\"\" from ical_library.timeline import Timeline return Timeline ( self , start , end ) def parse_component ( self , lines : List [ str ], line_number : int ) -> int : \"\"\" Parse a new component in the RAW string list. :param lines: A list of all the lines in the iCalendar file. :param line_number: The line number at which this component starts. :return: The line number at which this component ends. \"\"\" self . _lines = lines return super () . parse_component ( lines = lines , line_number = line_number ) def get_original_ical_text ( self , start_line : int , end_line : int ) -> str : \"\"\" Get the original iCAL text for your property from the RAW string list. :param start_line: The starting line index for the component you wish to show. :param end_line: The ending line index for the component you wish to show. :return: The complete string, as it was in the RAW string list, for the component you wish to show. \"\"\" lines = self . _lines if lines is None : raise TypeError ( \"We should first parse the component section before calling this function.\" ) return \" \\n \" . join ( line for line in self . tree_root . _lines [ max ( 0 , start_line ) : min ( len ( lines ), end_line )]) calendar_scale : str property Return the calendar scale according to RFC 5545. prodid : ProdID property writable A getter to ensure the required property is set. timeline : Timeline property Return a timeline of VEvents from 1970-00-00T00:00:00 to 2100-00-00T00:00:00. version : Version property writable A getter to ensure the required property is set. get_aware_dt_for_timezone ( dt , tzid ) Return the timezone aware DateTime object for a given TimeZone identifier. Source code in ical_library/ical_components/v_calendar.py 110 111 112 def get_aware_dt_for_timezone ( self , dt : DateTime , tzid : str ) -> DateTime : \"\"\"Return the timezone aware DateTime object for a given TimeZone identifier.\"\"\" return self . get_timezone ( tzid ) . convert_naive_datetime_to_aware ( dt ) get_limited_timeline ( start , end ) Return a timeline of VEvents limited by start and end Parameters: Name Type Description Default start Optional [ DateTime ] Only include events in the timeline with a starting date later than this value. required end Optional [ DateTime ] Only include events in the timeline with a starting date earlier than this value. required Source code in ical_library/ical_components/v_calendar.py 121 122 123 124 125 126 127 128 129 130 def get_limited_timeline ( self , start : Optional [ DateTime ], end : Optional [ DateTime ]) -> \"Timeline\" : \"\"\" Return a timeline of VEvents limited by *start* and *end* :param start: Only include events in the timeline with a starting date later than this value. :param end: Only include events in the timeline with a starting date earlier than this value. \"\"\" from ical_library.timeline import Timeline return Timeline ( self , start , end ) get_original_ical_text ( start_line , end_line ) Get the original iCAL text for your property from the RAW string list. Parameters: Name Type Description Default start_line int The starting line index for the component you wish to show. required end_line int The ending line index for the component you wish to show. required Returns: Type Description str The complete string, as it was in the RAW string list, for the component you wish to show. Source code in ical_library/ical_components/v_calendar.py 142 143 144 145 146 147 148 149 150 151 152 def get_original_ical_text ( self , start_line : int , end_line : int ) -> str : \"\"\" Get the original iCAL text for your property from the RAW string list. :param start_line: The starting line index for the component you wish to show. :param end_line: The ending line index for the component you wish to show. :return: The complete string, as it was in the RAW string list, for the component you wish to show. \"\"\" lines = self . _lines if lines is None : raise TypeError ( \"We should first parse the component section before calling this function.\" ) return \" \\n \" . join ( line for line in self . tree_root . _lines [ max ( 0 , start_line ) : min ( len ( lines ), end_line )]) get_timezone ( tzid ) Get the corresponding VTimeZone object based on the given timezone identifier. Source code in ical_library/ical_components/v_calendar.py 103 104 105 106 107 108 def get_timezone ( self , tzid : str ) -> VTimeZone : \"\"\"Get the corresponding VTimeZone object based on the given timezone identifier.\"\"\" for timezone in self . time_zones : if timezone . tzid . value == tzid : return timezone raise ValueError ( f \"Could not find Timezone with { tzid =} .\" ) parse_component ( lines , line_number ) Parse a new component in the RAW string list. Parameters: Name Type Description Default lines List [ str ] A list of all the lines in the iCalendar file. required line_number int The line number at which this component starts. required Returns: Type Description int The line number at which this component ends. Source code in ical_library/ical_components/v_calendar.py 132 133 134 135 136 137 138 139 140 def parse_component ( self , lines : List [ str ], line_number : int ) -> int : \"\"\" Parse a new component in the RAW string list. :param lines: A list of all the lines in the iCalendar file. :param line_number: The line number at which this component starts. :return: The line number at which this component ends. \"\"\" self . _lines = lines return super () . parse_component ( lines = lines , line_number = line_number )","title":"Calendar"},{"location":"code/calendar/#documentation-for-your-first-returned-item-vcalendar","text":"Once you imported the iCal-library library, you can use either the client or CacheCLient to get a VCalendar object. This page explains all the functions and attributes of the VCalendar object.","title":"Documentation for your first returned item: VCalendar"},{"location":"code/calendar/#ical_library.ical_components.VCalendar","text":"Bases: Component This class represents the VCALENDAR component specified in RFC 5545 in '3.6. Calendar Components'. The \"VCALENDAR\" component consists of a sequence of calendar properties and one or more calendar components. The calendar properties are attributes that apply to the calendar object as a whole. The calendar components are collections of properties that express a particular calendar semantic. For example, the calendar component can specify an event, a to-do, a journal entry, time zone information, free/busy time information, or an alarm. Parameters: Name Type Description Default prodid Optional [ ProdID ] The ProdID property. Required and must occur exactly once. None version Optional [ Version ] The Version property. Required and must occur exactly once. None calscale Optional [ CalScale ] The CalScale property. Optional, but may occur at most once. None method Optional [ Method ] The Method property. Optional, but may occur at most once. None events Optional [ List [ VEvent ]] Optional list of VEvent components. Each component may occur multiple times. None todos Optional [ List [ VToDo ]] Optional list of VToDo components. Each component may occur multiple times. None journals Optional [ List [ VJournal ]] Optional list of VJournal components. Each component may occur multiple times. None free_busy_list Optional [ List [ VFreeBusy ]] Optional list of VFreeBusy components. Each component may occur multiple times. None time_zones Optional [ List [ VTimeZone ]] Optional list of VTimeZone components. Each component may occur multiple times. None Source code in ical_library/ical_components/v_calendar.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class VCalendar ( Component ): \"\"\" This class represents the VCALENDAR component specified in RFC 5545 in '3.6. Calendar Components'. The \"VCALENDAR\" component consists of a sequence of calendar properties and one or more calendar components. The calendar properties are attributes that apply to the calendar object as a whole. The calendar components are collections of properties that express a particular calendar semantic. For example, the calendar component can specify an event, a to-do, a journal entry, time zone information, free/busy time information, or an alarm. :param prodid: The ProdID property. Required and must occur exactly once. :param version: The Version property. Required and must occur exactly once. :param calscale: The CalScale property. Optional, but may occur at most once. :param method: The Method property. Optional, but may occur at most once. :param events: Optional list of VEvent components. Each component may occur multiple times. :param todos: Optional list of VToDo components. Each component may occur multiple times. :param journals: Optional list of VJournal components. Each component may occur multiple times. :param free_busy_list: Optional list of VFreeBusy components. Each component may occur multiple times. :param time_zones: Optional list of VTimeZone components. Each component may occur multiple times. \"\"\" def __init__ ( self , prodid : Optional [ ProdID ] = None , version : Optional [ Version ] = None , calscale : Optional [ CalScale ] = None , method : Optional [ Method ] = None , events : Optional [ List [ VEvent ]] = None , todos : Optional [ List [ VToDo ]] = None , journals : Optional [ List [ VJournal ]] = None , free_busy_list : Optional [ List [ VFreeBusy ]] = None , time_zones : Optional [ List [ VTimeZone ]] = None , ): super () . __init__ ( \"VCALENDAR\" ) # Required properties, only one occurrence allowed. self . _prodid : Optional [ ProdID ] = self . as_parent ( prodid ) self . _version : Optional [ Version ] = self . as_parent ( version ) # Optional properties, must not occur more than once. self . calscale : Optional [ CalScale ] = self . as_parent ( calscale ) self . method : Optional [ Method ] = self . as_parent ( method ) # These are children Components self . events : List [ VEvent ] = events or [] self . todos : List [ VToDo ] = todos or [] self . journals : List [ VJournal ] = journals or [] self . free_busy_list : List [ VFreeBusy ] = free_busy_list or [] self . time_zones : List [ VTimeZone ] = time_zones or [] # Only the VCalender stores the entire list. self . _lines : Optional [ List [ str ]] = None def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VCalendar( { self . prodid . value } , { self . version . value } )\" @property def prodid ( self ) -> ProdID : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _prodid is None : raise MissingRequiredProperty ( self , \"prodid\" ) return self . _prodid @prodid . setter def prodid ( self , value : ProdID ): \"\"\"A setter to set the required property.\"\"\" self . _prodid = value @property def version ( self ) -> Version : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _version is None : raise MissingRequiredProperty ( self , \"version\" ) return self . _version @version . setter def version ( self , value : Version ): \"\"\"A setter to set the required property.\"\"\" self . _version = value @property def calendar_scale ( self ) -> str : \"\"\"Return the calendar scale according to RFC 5545.\"\"\" return self . calscale . value if self . calscale else \"GREGORIAN\" def get_timezone ( self , tzid : str ) -> VTimeZone : \"\"\"Get the corresponding VTimeZone object based on the given timezone identifier.\"\"\" for timezone in self . time_zones : if timezone . tzid . value == tzid : return timezone raise ValueError ( f \"Could not find Timezone with { tzid =} .\" ) def get_aware_dt_for_timezone ( self , dt : DateTime , tzid : str ) -> DateTime : \"\"\"Return the timezone aware DateTime object for a given TimeZone identifier.\"\"\" return self . get_timezone ( tzid ) . convert_naive_datetime_to_aware ( dt ) @property def timeline ( self ) -> \"Timeline\" : \"\"\"Return a timeline of VEvents from 1970-00-00T00:00:00 to 2100-00-00T00:00:00.\"\"\" from ical_library.timeline import Timeline return Timeline ( self ) def get_limited_timeline ( self , start : Optional [ DateTime ], end : Optional [ DateTime ]) -> \"Timeline\" : \"\"\" Return a timeline of VEvents limited by *start* and *end* :param start: Only include events in the timeline with a starting date later than this value. :param end: Only include events in the timeline with a starting date earlier than this value. \"\"\" from ical_library.timeline import Timeline return Timeline ( self , start , end ) def parse_component ( self , lines : List [ str ], line_number : int ) -> int : \"\"\" Parse a new component in the RAW string list. :param lines: A list of all the lines in the iCalendar file. :param line_number: The line number at which this component starts. :return: The line number at which this component ends. \"\"\" self . _lines = lines return super () . parse_component ( lines = lines , line_number = line_number ) def get_original_ical_text ( self , start_line : int , end_line : int ) -> str : \"\"\" Get the original iCAL text for your property from the RAW string list. :param start_line: The starting line index for the component you wish to show. :param end_line: The ending line index for the component you wish to show. :return: The complete string, as it was in the RAW string list, for the component you wish to show. \"\"\" lines = self . _lines if lines is None : raise TypeError ( \"We should first parse the component section before calling this function.\" ) return \" \\n \" . join ( line for line in self . tree_root . _lines [ max ( 0 , start_line ) : min ( len ( lines ), end_line )])","title":"VCalendar"},{"location":"code/calendar/#ical_library.ical_components.VCalendar.calendar_scale","text":"Return the calendar scale according to RFC 5545.","title":"calendar_scale"},{"location":"code/calendar/#ical_library.ical_components.VCalendar.prodid","text":"A getter to ensure the required property is set.","title":"prodid"},{"location":"code/calendar/#ical_library.ical_components.VCalendar.timeline","text":"Return a timeline of VEvents from 1970-00-00T00:00:00 to 2100-00-00T00:00:00.","title":"timeline"},{"location":"code/calendar/#ical_library.ical_components.VCalendar.version","text":"A getter to ensure the required property is set.","title":"version"},{"location":"code/calendar/#ical_library.ical_components.VCalendar.get_aware_dt_for_timezone","text":"Return the timezone aware DateTime object for a given TimeZone identifier. Source code in ical_library/ical_components/v_calendar.py 110 111 112 def get_aware_dt_for_timezone ( self , dt : DateTime , tzid : str ) -> DateTime : \"\"\"Return the timezone aware DateTime object for a given TimeZone identifier.\"\"\" return self . get_timezone ( tzid ) . convert_naive_datetime_to_aware ( dt )","title":"get_aware_dt_for_timezone"},{"location":"code/calendar/#ical_library.ical_components.VCalendar.get_limited_timeline","text":"Return a timeline of VEvents limited by start and end Parameters: Name Type Description Default start Optional [ DateTime ] Only include events in the timeline with a starting date later than this value. required end Optional [ DateTime ] Only include events in the timeline with a starting date earlier than this value. required Source code in ical_library/ical_components/v_calendar.py 121 122 123 124 125 126 127 128 129 130 def get_limited_timeline ( self , start : Optional [ DateTime ], end : Optional [ DateTime ]) -> \"Timeline\" : \"\"\" Return a timeline of VEvents limited by *start* and *end* :param start: Only include events in the timeline with a starting date later than this value. :param end: Only include events in the timeline with a starting date earlier than this value. \"\"\" from ical_library.timeline import Timeline return Timeline ( self , start , end )","title":"get_limited_timeline"},{"location":"code/calendar/#ical_library.ical_components.VCalendar.get_original_ical_text","text":"Get the original iCAL text for your property from the RAW string list. Parameters: Name Type Description Default start_line int The starting line index for the component you wish to show. required end_line int The ending line index for the component you wish to show. required Returns: Type Description str The complete string, as it was in the RAW string list, for the component you wish to show. Source code in ical_library/ical_components/v_calendar.py 142 143 144 145 146 147 148 149 150 151 152 def get_original_ical_text ( self , start_line : int , end_line : int ) -> str : \"\"\" Get the original iCAL text for your property from the RAW string list. :param start_line: The starting line index for the component you wish to show. :param end_line: The ending line index for the component you wish to show. :return: The complete string, as it was in the RAW string list, for the component you wish to show. \"\"\" lines = self . _lines if lines is None : raise TypeError ( \"We should first parse the component section before calling this function.\" ) return \" \\n \" . join ( line for line in self . tree_root . _lines [ max ( 0 , start_line ) : min ( len ( lines ), end_line )])","title":"get_original_ical_text"},{"location":"code/calendar/#ical_library.ical_components.VCalendar.get_timezone","text":"Get the corresponding VTimeZone object based on the given timezone identifier. Source code in ical_library/ical_components/v_calendar.py 103 104 105 106 107 108 def get_timezone ( self , tzid : str ) -> VTimeZone : \"\"\"Get the corresponding VTimeZone object based on the given timezone identifier.\"\"\" for timezone in self . time_zones : if timezone . tzid . value == tzid : return timezone raise ValueError ( f \"Could not find Timezone with { tzid =} .\" )","title":"get_timezone"},{"location":"code/calendar/#ical_library.ical_components.VCalendar.parse_component","text":"Parse a new component in the RAW string list. Parameters: Name Type Description Default lines List [ str ] A list of all the lines in the iCalendar file. required line_number int The line number at which this component starts. required Returns: Type Description int The line number at which this component ends. Source code in ical_library/ical_components/v_calendar.py 132 133 134 135 136 137 138 139 140 def parse_component ( self , lines : List [ str ], line_number : int ) -> int : \"\"\" Parse a new component in the RAW string list. :param lines: A list of all the lines in the iCalendar file. :param line_number: The line number at which this component starts. :return: The line number at which this component ends. \"\"\" self . _lines = lines return super () . parse_component ( lines = lines , line_number = line_number )","title":"parse_component"},{"location":"code/client/","text":"The client When you are looking to integrate iCal-library with your project, the client is the first place to look. If you have a service that periodically restarts, you might want to take a look at the CacheClient . client parse_icalendar_file ( file ) Parse an iCalendar file and return a parsed VCalendar instance. Parameters: Name Type Description Default file Union [ str , Path ] A file on the local filesystem that contains the icalendar definition. required Returns: Type Description VCalendar a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. Source code in ical_library/client.py 27 28 29 30 31 32 33 34 def parse_icalendar_file ( file : Union [ str , Path ]) -> VCalendar : \"\"\" Parse an iCalendar file and return a parsed VCalendar instance. :param file: A file on the local filesystem that contains the icalendar definition. :return: a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. \"\"\" with open ( file , \"r\" ) as ical_file : return parse_lines_into_calendar ( ical_file . read ()) parse_icalendar_url ( url , ** kwargs ) Given a URL to an iCalendar file, return a parsed VCalendar instance. Parameters: Name Type Description Default url str The URL to the iCalendar file. required kwargs Any Any keyword arguments to pass onto the urllib.request.urlopen call. {} Returns: Type Description VCalendar a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. Source code in ical_library/client.py 37 38 39 40 41 42 43 44 45 46 def parse_icalendar_url ( url : str , ** kwargs : Any ) -> VCalendar : \"\"\" Given a URL to an iCalendar file, return a parsed VCalendar instance. :param url: The URL to the iCalendar file. :param kwargs: Any keyword arguments to pass onto the `urllib.request.urlopen` call. :return: a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. \"\"\" response = request . urlopen ( url , ** kwargs ) text = response . read () . decode ( \"utf-8\" ) return parse_lines_into_calendar ( text ) parse_lines_into_calendar ( raw_text ) Given the lines of an iCalendar file, return a parsed VCalendar instance. Parameters: Name Type Description Default raw_text str The raw text of the iCalendar file/website. required Returns: Type Description VCalendar a VCalendar with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. Source code in ical_library/client.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def parse_lines_into_calendar ( raw_text : str ) -> VCalendar : \"\"\" Given the lines of an iCalendar file, return a parsed VCalendar instance. :param raw_text: The raw text of the iCalendar file/website. :return: a VCalendar with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. \"\"\" lines : List [ str ] = [] for line in re . split ( r \"\\n\" , raw_text ): line_content = re . sub ( r \"^\\n|^\\r|\\n$|\\r$\" , \"\" , line ) if len ( line_content ) > 0 : lines . append ( line_content ) new_instance = VCalendar () if lines [ 0 ] != \"BEGIN:VCALENDAR\" : raise ValueError ( f \"This is not a ICalendar as it started with { lines [ 0 ] =} .\" ) new_instance . parse_component ( lines , line_number = 1 ) return new_instance","title":"Client"},{"location":"code/client/#the-client","text":"When you are looking to integrate iCal-library with your project, the client is the first place to look. If you have a service that periodically restarts, you might want to take a look at the CacheClient .","title":"The client"},{"location":"code/client/#ical_library.client","text":"","title":"client"},{"location":"code/client/#ical_library.client.parse_icalendar_file","text":"Parse an iCalendar file and return a parsed VCalendar instance. Parameters: Name Type Description Default file Union [ str , Path ] A file on the local filesystem that contains the icalendar definition. required Returns: Type Description VCalendar a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. Source code in ical_library/client.py 27 28 29 30 31 32 33 34 def parse_icalendar_file ( file : Union [ str , Path ]) -> VCalendar : \"\"\" Parse an iCalendar file and return a parsed VCalendar instance. :param file: A file on the local filesystem that contains the icalendar definition. :return: a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. \"\"\" with open ( file , \"r\" ) as ical_file : return parse_lines_into_calendar ( ical_file . read ())","title":"parse_icalendar_file"},{"location":"code/client/#ical_library.client.parse_icalendar_url","text":"Given a URL to an iCalendar file, return a parsed VCalendar instance. Parameters: Name Type Description Default url str The URL to the iCalendar file. required kwargs Any Any keyword arguments to pass onto the urllib.request.urlopen call. {} Returns: Type Description VCalendar a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. Source code in ical_library/client.py 37 38 39 40 41 42 43 44 45 46 def parse_icalendar_url ( url : str , ** kwargs : Any ) -> VCalendar : \"\"\" Given a URL to an iCalendar file, return a parsed VCalendar instance. :param url: The URL to the iCalendar file. :param kwargs: Any keyword arguments to pass onto the `urllib.request.urlopen` call. :return: a VCalendar instance with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. \"\"\" response = request . urlopen ( url , ** kwargs ) text = response . read () . decode ( \"utf-8\" ) return parse_lines_into_calendar ( text )","title":"parse_icalendar_url"},{"location":"code/client/#ical_library.client.parse_lines_into_calendar","text":"Given the lines of an iCalendar file, return a parsed VCalendar instance. Parameters: Name Type Description Default raw_text str The raw text of the iCalendar file/website. required Returns: Type Description VCalendar a VCalendar with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. Source code in ical_library/client.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def parse_lines_into_calendar ( raw_text : str ) -> VCalendar : \"\"\" Given the lines of an iCalendar file, return a parsed VCalendar instance. :param raw_text: The raw text of the iCalendar file/website. :return: a VCalendar with all it's iCalendar components like VEvents, VToDos, VTimeZones etc. \"\"\" lines : List [ str ] = [] for line in re . split ( r \"\\n\" , raw_text ): line_content = re . sub ( r \"^\\n|^\\r|\\n$|\\r$\" , \"\" , line ) if len ( line_content ) > 0 : lines . append ( line_content ) new_instance = VCalendar () if lines [ 0 ] != \"BEGIN:VCALENDAR\" : raise ValueError ( f \"This is not a ICalendar as it started with { lines [ 0 ] =} .\" ) new_instance . parse_component ( lines , line_number = 1 ) return new_instance","title":"parse_lines_into_calendar"},{"location":"code/components/","text":"All Components If you haven't already, first check out Component over at base classes . These are part of the components you can encounter in a iCalendar data file. The others are mentioned in Recurring components and Timezone components . Simple components We start out with the components that are relatively straight forward. There is no recurring option here. VFreeBusy Bases: Component This class represents the VFREEBUSY component specified in RFC 5545 in '3.6.4. Free/Busy Component'. A \"VFREEBUSY\" calendar component is a grouping of component properties that represents either a request for free or busy time information, a reply to a request for free or busy time information, or a published set of busy time information. Parameters: Name Type Description Default name The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None contact Optional [ Contact ] The Contact property. Optional, but may occur at most once. None dtstart Optional [ DTStart ] The DTStart property. Optional, but may occur at most once. None dtend Optional [ DTEnd ] The DTEnd property. Optional, but may occur at most once. None organizer Optional [ Organizer ] The Organizer property. Optional, but may occur at most once. None url Optional [ URL ] The URL property. Optional, but may occur at most once. None attendee Optional [ List [ Attendee ]] The Attendee property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None freebusy Optional [ List [ FreeBusyProperty ]] The FreeBusyProperty property. Optional, but may occur multiple times. None rstatus Optional [ List [ RequestStatus ]] The RequestStatus property. Optional, but may occur multiple times. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_free_busy.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class VFreeBusy ( Component ): \"\"\" This class represents the VFREEBUSY component specified in RFC 5545 in '3.6.4. Free/Busy Component'. A \"VFREEBUSY\" calendar component is a grouping of component properties that represents either a request for free or busy time information, a reply to a request for free or busy time information, or a published set of busy time information. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param contact: The Contact property. Optional, but may occur at most once. :param dtstart: The DTStart property. Optional, but may occur at most once. :param dtend: The DTEnd property. Optional, but may occur at most once. :param organizer: The Organizer property. Optional, but may occur at most once. :param url: The URL property. Optional, but may occur at most once. :param attendee: The Attendee property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param freebusy: The FreeBusyProperty property. Optional, but may occur multiple times. :param rstatus: The RequestStatus property. Optional, but may occur multiple times. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , contact : Optional [ Contact ] = None , dtstart : Optional [ DTStart ] = None , dtend : Optional [ DTEnd ] = None , organizer : Optional [ Organizer ] = None , url : Optional [ URL ] = None , attendee : Optional [ List [ Attendee ]] = None , comment : Optional [ List [ Comment ]] = None , freebusy : Optional [ List [ FreeBusyProperty ]] = None , rstatus : Optional [ List [ RequestStatus ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( \"VFREEBUSY\" , parent = parent ) # Required self . _dtstamp : Optional [ DTStamp ] = self . as_parent ( dtstamp ) self . _uid : Optional [ UID ] = self . as_parent ( uid ) # Optional, may only occur once self . contact : Optional [ Contact ] = self . as_parent ( contact ) self . dtstart : Optional [ DTStart ] = self . as_parent ( dtstart ) self . dtend : Optional [ DTEnd ] = self . as_parent ( dtend ) self . organizer : Optional [ Organizer ] = self . as_parent ( organizer ) self . url : Optional [ URL ] = self . as_parent ( url ) # Optional, may occur more than once self . attendee : Optional [ List [ Attendee ]] = self . as_parent ( attendee ) self . comment : Optional [ List [ Comment ]] = self . as_parent ( comment ) self . freebusy : Optional [ List [ FreeBusyProperty ]] = self . as_parent ( freebusy ) self . rstatus : Optional [ List [ RequestStatus ]] = self . as_parent ( rstatus ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VFreeBusy( { self . dtstart . value if self . dtstart else '' } , { self . dtend . value if self . dtend else '' } )\" @property def dtstamp ( self ) -> DTStamp : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _dtstamp is None : raise MissingRequiredProperty ( self , \"dtstamp\" ) return self . _dtstamp @dtstamp . setter def dtstamp ( self , value : DTStamp ): \"\"\"A setter to set the required property.\"\"\" self . _dtstamp = value @property def uid ( self ) -> UID : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _uid is None : raise MissingRequiredProperty ( self , \"uid\" ) return self . _uid @uid . setter def uid ( self , value : UID ): \"\"\"A setter to set the required property.\"\"\" self . _uid = value @property def timespan ( self ) -> Optional [ TimespanWithParent ]: start = self . dtstart . datetime_or_date_value if self . dtstart else None end = self . dtend . datetime_or_date_value if self . dtend else None if start is None : return None if end is None : TimespanWithParent ( parent = self , begin = start , end = start ) return TimespanWithParent ( parent = self , begin = start , end = end ) dtstamp : DTStamp property writable A getter to ensure the required property is set. uid : UID property writable A getter to ensure the required property is set. VAlarm Bases: Component This class represents the VAlarm component specified in RFC 5545 in '3.6.6. Alarm Component'. A \"VALARM\" calendar component is a grouping of component properties that is a reminder or alarm for an event or a to-do. For example, it may be used to define a reminder for a pending event or an overdue to-do. The \"VALARM\" calendar component MUST only appear within either a \"VEVENT\" or \"VTODO\" calendar component Parameters: Name Type Description Default action Optional [ Action ] The Action property. Required and must occur exactly once. None trigger Optional [ Trigger ] The Trigger property. Required and must occur exactly once. None duration Optional [ ICALDuration ] The ICALDuration property. Optional, but may occur at most once. If this item is present, repeat may not be present. None repeat Optional [ Repeat ] The Repeat property. Optional, but may occur at most once. If this item is present, duration may not be present. None attach Optional [ Attach ] The Attach property. Optional, but may occur at most once. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_alarm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class VAlarm ( Component ): \"\"\" This class represents the VAlarm component specified in RFC 5545 in '3.6.6. Alarm Component'. A \"VALARM\" calendar component is a grouping of component properties that is a reminder or alarm for an event or a to-do. For example, it may be used to define a reminder for a pending event or an overdue to-do. The \"VALARM\" calendar component MUST only appear within either a \"VEVENT\" or \"VTODO\" calendar component :param action: The Action property. Required and must occur exactly once. :param trigger: The Trigger property. Required and must occur exactly once. :param duration: The ICALDuration property. Optional, but may occur at most once. If this item is present, repeat may not be present. :param repeat: The Repeat property. Optional, but may occur at most once. If this item is present, duration may not be present. :param attach: The Attach property. Optional, but may occur at most once. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , action : Optional [ Action ] = None , trigger : Optional [ Trigger ] = None , duration : Optional [ ICALDuration ] = None , repeat : Optional [ Repeat ] = None , attach : Optional [ Attach ] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( \"VALARM\" , parent = parent ) # Required self . _action : Optional [ Action ] = self . as_parent ( action ) self . _trigger : Optional [ Trigger ] = self . as_parent ( trigger ) # Both optional and may only occur once. But if one occurs, the other also has to occur. self . duration : Optional [ ICALDuration ] = self . as_parent ( duration ) self . repeat : Optional [ Repeat ] = self . as_parent ( repeat ) # Optional, may only occur once self . attach : Optional [ Attach ] = self . as_parent ( attach ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VAlarm( { self . action . value } : { self . trigger . value } )\" @property def action ( self ) -> Action : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _action is None : raise MissingRequiredProperty ( self , \"action\" ) return self . _action @action . setter def action ( self , value : Action ): \"\"\"A setter to set the required property.\"\"\" self . _action = value @property def trigger ( self ) -> Trigger : \"\"\"Getter that ensures the required property is set.\"\"\" if self . _trigger is None : raise MissingRequiredProperty ( self , \"trigger\" ) return self . _trigger @trigger . setter def trigger ( self , value : Trigger ): \"\"\"A setter to set the required property.\"\"\" self . _trigger = value action : Action property writable A getter to ensure the required property is set. trigger : Trigger property writable Getter that ensures the required property is set.","title":"All Components"},{"location":"code/components/#all-components","text":"If you haven't already, first check out Component over at base classes . These are part of the components you can encounter in a iCalendar data file. The others are mentioned in Recurring components and Timezone components .","title":"All Components"},{"location":"code/components/#simple-components","text":"We start out with the components that are relatively straight forward. There is no recurring option here.","title":"Simple components"},{"location":"code/components/#ical_library.ical_components.VFreeBusy","text":"Bases: Component This class represents the VFREEBUSY component specified in RFC 5545 in '3.6.4. Free/Busy Component'. A \"VFREEBUSY\" calendar component is a grouping of component properties that represents either a request for free or busy time information, a reply to a request for free or busy time information, or a published set of busy time information. Parameters: Name Type Description Default name The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None contact Optional [ Contact ] The Contact property. Optional, but may occur at most once. None dtstart Optional [ DTStart ] The DTStart property. Optional, but may occur at most once. None dtend Optional [ DTEnd ] The DTEnd property. Optional, but may occur at most once. None organizer Optional [ Organizer ] The Organizer property. Optional, but may occur at most once. None url Optional [ URL ] The URL property. Optional, but may occur at most once. None attendee Optional [ List [ Attendee ]] The Attendee property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None freebusy Optional [ List [ FreeBusyProperty ]] The FreeBusyProperty property. Optional, but may occur multiple times. None rstatus Optional [ List [ RequestStatus ]] The RequestStatus property. Optional, but may occur multiple times. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_free_busy.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class VFreeBusy ( Component ): \"\"\" This class represents the VFREEBUSY component specified in RFC 5545 in '3.6.4. Free/Busy Component'. A \"VFREEBUSY\" calendar component is a grouping of component properties that represents either a request for free or busy time information, a reply to a request for free or busy time information, or a published set of busy time information. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param contact: The Contact property. Optional, but may occur at most once. :param dtstart: The DTStart property. Optional, but may occur at most once. :param dtend: The DTEnd property. Optional, but may occur at most once. :param organizer: The Organizer property. Optional, but may occur at most once. :param url: The URL property. Optional, but may occur at most once. :param attendee: The Attendee property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param freebusy: The FreeBusyProperty property. Optional, but may occur multiple times. :param rstatus: The RequestStatus property. Optional, but may occur multiple times. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , contact : Optional [ Contact ] = None , dtstart : Optional [ DTStart ] = None , dtend : Optional [ DTEnd ] = None , organizer : Optional [ Organizer ] = None , url : Optional [ URL ] = None , attendee : Optional [ List [ Attendee ]] = None , comment : Optional [ List [ Comment ]] = None , freebusy : Optional [ List [ FreeBusyProperty ]] = None , rstatus : Optional [ List [ RequestStatus ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( \"VFREEBUSY\" , parent = parent ) # Required self . _dtstamp : Optional [ DTStamp ] = self . as_parent ( dtstamp ) self . _uid : Optional [ UID ] = self . as_parent ( uid ) # Optional, may only occur once self . contact : Optional [ Contact ] = self . as_parent ( contact ) self . dtstart : Optional [ DTStart ] = self . as_parent ( dtstart ) self . dtend : Optional [ DTEnd ] = self . as_parent ( dtend ) self . organizer : Optional [ Organizer ] = self . as_parent ( organizer ) self . url : Optional [ URL ] = self . as_parent ( url ) # Optional, may occur more than once self . attendee : Optional [ List [ Attendee ]] = self . as_parent ( attendee ) self . comment : Optional [ List [ Comment ]] = self . as_parent ( comment ) self . freebusy : Optional [ List [ FreeBusyProperty ]] = self . as_parent ( freebusy ) self . rstatus : Optional [ List [ RequestStatus ]] = self . as_parent ( rstatus ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VFreeBusy( { self . dtstart . value if self . dtstart else '' } , { self . dtend . value if self . dtend else '' } )\" @property def dtstamp ( self ) -> DTStamp : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _dtstamp is None : raise MissingRequiredProperty ( self , \"dtstamp\" ) return self . _dtstamp @dtstamp . setter def dtstamp ( self , value : DTStamp ): \"\"\"A setter to set the required property.\"\"\" self . _dtstamp = value @property def uid ( self ) -> UID : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _uid is None : raise MissingRequiredProperty ( self , \"uid\" ) return self . _uid @uid . setter def uid ( self , value : UID ): \"\"\"A setter to set the required property.\"\"\" self . _uid = value @property def timespan ( self ) -> Optional [ TimespanWithParent ]: start = self . dtstart . datetime_or_date_value if self . dtstart else None end = self . dtend . datetime_or_date_value if self . dtend else None if start is None : return None if end is None : TimespanWithParent ( parent = self , begin = start , end = start ) return TimespanWithParent ( parent = self , begin = start , end = end )","title":"VFreeBusy"},{"location":"code/components/#ical_library.ical_components.VFreeBusy.dtstamp","text":"A getter to ensure the required property is set.","title":"dtstamp"},{"location":"code/components/#ical_library.ical_components.VFreeBusy.uid","text":"A getter to ensure the required property is set.","title":"uid"},{"location":"code/components/#ical_library.ical_components.VAlarm","text":"Bases: Component This class represents the VAlarm component specified in RFC 5545 in '3.6.6. Alarm Component'. A \"VALARM\" calendar component is a grouping of component properties that is a reminder or alarm for an event or a to-do. For example, it may be used to define a reminder for a pending event or an overdue to-do. The \"VALARM\" calendar component MUST only appear within either a \"VEVENT\" or \"VTODO\" calendar component Parameters: Name Type Description Default action Optional [ Action ] The Action property. Required and must occur exactly once. None trigger Optional [ Trigger ] The Trigger property. Required and must occur exactly once. None duration Optional [ ICALDuration ] The ICALDuration property. Optional, but may occur at most once. If this item is present, repeat may not be present. None repeat Optional [ Repeat ] The Repeat property. Optional, but may occur at most once. If this item is present, duration may not be present. None attach Optional [ Attach ] The Attach property. Optional, but may occur at most once. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_alarm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class VAlarm ( Component ): \"\"\" This class represents the VAlarm component specified in RFC 5545 in '3.6.6. Alarm Component'. A \"VALARM\" calendar component is a grouping of component properties that is a reminder or alarm for an event or a to-do. For example, it may be used to define a reminder for a pending event or an overdue to-do. The \"VALARM\" calendar component MUST only appear within either a \"VEVENT\" or \"VTODO\" calendar component :param action: The Action property. Required and must occur exactly once. :param trigger: The Trigger property. Required and must occur exactly once. :param duration: The ICALDuration property. Optional, but may occur at most once. If this item is present, repeat may not be present. :param repeat: The Repeat property. Optional, but may occur at most once. If this item is present, duration may not be present. :param attach: The Attach property. Optional, but may occur at most once. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , action : Optional [ Action ] = None , trigger : Optional [ Trigger ] = None , duration : Optional [ ICALDuration ] = None , repeat : Optional [ Repeat ] = None , attach : Optional [ Attach ] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( \"VALARM\" , parent = parent ) # Required self . _action : Optional [ Action ] = self . as_parent ( action ) self . _trigger : Optional [ Trigger ] = self . as_parent ( trigger ) # Both optional and may only occur once. But if one occurs, the other also has to occur. self . duration : Optional [ ICALDuration ] = self . as_parent ( duration ) self . repeat : Optional [ Repeat ] = self . as_parent ( repeat ) # Optional, may only occur once self . attach : Optional [ Attach ] = self . as_parent ( attach ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VAlarm( { self . action . value } : { self . trigger . value } )\" @property def action ( self ) -> Action : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _action is None : raise MissingRequiredProperty ( self , \"action\" ) return self . _action @action . setter def action ( self , value : Action ): \"\"\"A setter to set the required property.\"\"\" self . _action = value @property def trigger ( self ) -> Trigger : \"\"\"Getter that ensures the required property is set.\"\"\" if self . _trigger is None : raise MissingRequiredProperty ( self , \"trigger\" ) return self . _trigger @trigger . setter def trigger ( self , value : Trigger ): \"\"\"A setter to set the required property.\"\"\" self . _trigger = value","title":"VAlarm"},{"location":"code/components/#ical_library.ical_components.VAlarm.action","text":"A getter to ensure the required property is set.","title":"action"},{"location":"code/components/#ical_library.ical_components.VAlarm.trigger","text":"Getter that ensures the required property is set.","title":"trigger"},{"location":"code/exceptions/","text":"Exceptions These are all the custom exceptions you might encounter when using iCal-library . CalendarParentRelationError Bases: ValueError Indicate finding the tree root failed as it did not find a VCalendar root. Source code in ical_library/exceptions.py 7 8 9 10 class CalendarParentRelationError ( ValueError ): \"\"\"Indicate finding the tree root failed as it did not find a VCalendar root.\"\"\" pass VEventExpansionFailed Bases: ValueError Indicate the expansion based on recurring properties failed. Source code in ical_library/exceptions.py 13 14 15 16 class VEventExpansionFailed ( ValueError ): \"\"\"Indicate the expansion based on recurring properties failed.\"\"\" pass MissingRequiredProperty Bases: ValueError Indicate a required property is not set for a Component. Source code in ical_library/exceptions.py 19 20 21 22 23 24 25 26 27 28 29 30 31 class MissingRequiredProperty ( ValueError ): \"\"\"Indicate a required property is not set for a Component.\"\"\" def __init__ ( self , component : \"Component\" , missing_property_name : str ): self . component = component self . missing_property_name = missing_property_name def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return ( f \"The required property named { self . missing_property_name } was not set for \" f \" { self . component . __class__ . __name__ } \" )","title":"Exceptions"},{"location":"code/exceptions/#exceptions","text":"These are all the custom exceptions you might encounter when using iCal-library .","title":"Exceptions"},{"location":"code/exceptions/#ical_library.CalendarParentRelationError","text":"Bases: ValueError Indicate finding the tree root failed as it did not find a VCalendar root. Source code in ical_library/exceptions.py 7 8 9 10 class CalendarParentRelationError ( ValueError ): \"\"\"Indicate finding the tree root failed as it did not find a VCalendar root.\"\"\" pass","title":"CalendarParentRelationError"},{"location":"code/exceptions/#ical_library.VEventExpansionFailed","text":"Bases: ValueError Indicate the expansion based on recurring properties failed. Source code in ical_library/exceptions.py 13 14 15 16 class VEventExpansionFailed ( ValueError ): \"\"\"Indicate the expansion based on recurring properties failed.\"\"\" pass","title":"VEventExpansionFailed"},{"location":"code/exceptions/#ical_library.MissingRequiredProperty","text":"Bases: ValueError Indicate a required property is not set for a Component. Source code in ical_library/exceptions.py 19 20 21 22 23 24 25 26 27 28 29 30 31 class MissingRequiredProperty ( ValueError ): \"\"\"Indicate a required property is not set for a Component.\"\"\" def __init__ ( self , component : \"Component\" , missing_property_name : str ): self . component = component self . missing_property_name = missing_property_name def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return ( f \"The required property named { self . missing_property_name } was not set for \" f \" { self . component . __class__ . __name__ } \" )","title":"MissingRequiredProperty"},{"location":"code/properties/","text":"All Properties All Properties are extending the Property class. Let's first start with the base class and then list all the other properties. Property Bases: ICalBaseClass This is the base class for any property (according to the RFC 5545 specification) in iCal-library. A property always exists of three parts: The name of the property. The property parameters, this is optional and does not need to be present. The value of the property. A line containing a property typically has the following format: PROPERTY-NAME;parameterKey=parameterValue,anotherParameterKey=anotherValue:actual-value Any property that is predefined according to the RFC 5545 should inherit this class, e.g. UID, RRule. Only x-properties or iana-properties should instantiate the Property class directly. Parameters: Name Type Description Default value Optional [ str ] The value of the property. required name Optional [ str ] The properties name, e.g. RRULE . None property_parameters Optional [ str ] The property parameters for this definition. None parent Component Instance of the :class: Component it is a part of. None Source code in ical_library/base_classes/property.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class Property ( ICalBaseClass ): \"\"\" This is the base class for any property (according to the RFC 5545 specification) in iCal-library. A property always exists of three parts: - The name of the property. - The property parameters, this is optional and does not need to be present. - The value of the property. A line containing a property typically has the following format: `PROPERTY-NAME;parameterKey=parameterValue,anotherParameterKey=anotherValue:actual-value` Any property that is predefined according to the RFC 5545 should inherit this class, e.g. UID, RRule. Only x-properties or iana-properties should instantiate the Property class directly. :param value: The value of the property. :param name: The properties name, e.g. `RRULE`. :param property_parameters: The property parameters for this definition. :param parent: Instance of the :class:`Component` it is a part of. \"\"\" def __init__ ( self , value : Optional [ str ], name : Optional [ str ] = None , property_parameters : Optional [ str ] = None , parent : \"Component\" = None , ): name = name if self . __class__ == Property else self . __class__ . get_ical_name_of_class () super () . __init__ ( name = name , parent = parent or ComponentContext . get_current_component ()) if parent is None and self . parent is not None : self . parent . set_property ( self ) self . _property_parameters : Optional [ str ] = property_parameters self . _value : Optional [ str ] = value def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \" { self . __class__ . __name__ } ( { self . as_original_string } )\" def __eq__ ( self : \"Property\" , other : \"Property\" ) -> bool : \"\"\"Return whether the current instance and the other instance are the same.\"\"\" if type ( self ) != type ( other ): return False return self . as_original_string == other . as_original_string @property @instance_lru_cache () def property_parameters ( self ) -> Dict [ str , str ]: \"\"\" Return (and cache) all the property's parameters as a dictionary of strings. Note: When the instance is collected by the garbage collection, the cache is automatically deleted as well. :return: all the property's parameters as a dictionary of strings \"\"\" property_parameters_str = self . _property_parameters or \"\" return { key_and_value . split ( \"=\" )[ 0 ]: key_and_value . split ( \"=\" )[ 1 ] for key_and_value in property_parameters_str . split ( \",\" ) if key_and_value . count ( \"=\" ) == 1 } def has_property_parameter ( self , key : str ) -> Optional [ bool ]: \"\"\" Return whether this property has a property parameter with a specific *key*. :param key: What key to search for. :return: boolean whether this property has a property parameter with a specific *key*. \"\"\" return key in self . property_parameters def get_property_parameter ( self , key : str ) -> Optional [ str ]: \"\"\" Get a property parameter's value with a specific key. :param key: The identifier of the property parameter. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , None ) def get_property_parameter_default ( self , key : str , default : str ) -> str : \"\"\" Get a property parameter's value with a specific key, where the default may not be None. :param key: The identifier of the property parameter. :param default: A value to return when the property parameter is not present, which may not be None. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , default ) @property def value ( self ) -> Optional [ str ]: \"\"\"Return the value of this property.\"\"\" return self . _value @property def as_original_string ( self ) -> str : \"\"\" Return the iCalendar representation of the parameter. :return: the iCalendar string representation. \"\"\" add_subs = f \"; { self . _property_parameters } \" if self . _property_parameters else \"\" return f \" { self . _name }{ add_subs } : { self . _value } \" as_original_string : str property Return the iCalendar representation of the parameter. Returns: Type Description the iCalendar string representation. property_parameters : Dict [ str , str ] property Return (and cache) all the property's parameters as a dictionary of strings. Note: When the instance is collected by the garbage collection, the cache is automatically deleted as well. Returns: Type Description all the property's parameters as a dictionary of strings value : Optional [ str ] property Return the value of this property. get_property_parameter ( key ) Get a property parameter's value with a specific key. Parameters: Name Type Description Default key str The identifier of the property parameter. required Returns: Type Description Optional [ str ] The requested property parameter, or if that is not present, the default value. Source code in ical_library/base_classes/property.py 84 85 86 87 88 89 90 91 def get_property_parameter ( self , key : str ) -> Optional [ str ]: \"\"\" Get a property parameter's value with a specific key. :param key: The identifier of the property parameter. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , None ) get_property_parameter_default ( key , default ) Get a property parameter's value with a specific key, where the default may not be None. Parameters: Name Type Description Default key str The identifier of the property parameter. required default str A value to return when the property parameter is not present, which may not be None. required Returns: Type Description str The requested property parameter, or if that is not present, the default value. Source code in ical_library/base_classes/property.py 93 94 95 96 97 98 99 100 101 def get_property_parameter_default ( self , key : str , default : str ) -> str : \"\"\" Get a property parameter's value with a specific key, where the default may not be None. :param key: The identifier of the property parameter. :param default: A value to return when the property parameter is not present, which may not be None. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , default ) has_property_parameter ( key ) Return whether this property has a property parameter with a specific key . Parameters: Name Type Description Default key str What key to search for. required Returns: Type Description Optional [ bool ] boolean whether this property has a property parameter with a specific key . Source code in ical_library/base_classes/property.py 75 76 77 78 79 80 81 82 def has_property_parameter ( self , key : str ) -> Optional [ bool ]: \"\"\" Return whether this property has a property parameter with a specific *key*. :param key: What key to search for. :return: boolean whether this property has a property parameter with a specific *key*. \"\"\" return key in self . property_parameters Action Bases: Property The ACTION property defines the action to be invoked when an alarm is triggered. Source code in ical_library/ical_properties/pass_properties.py 126 127 128 129 class Action ( Property ): \"\"\"The ACTION property defines the action to be invoked when an alarm is triggered.\"\"\" pass Attach Bases: Property The ATTACH property provides the capability to associate a document object with a calendar component. Source code in ical_library/ical_properties/pass_properties.py 76 77 78 79 class Attach ( Property ): \"\"\"The ATTACH property provides the capability to associate a document object with a calendar component.\"\"\" pass Attendee Bases: _CalAddress The ATTENDEE property defines an \"Attendee\" within a calendar component. Source code in ical_library/ical_properties/cal_address.py 40 41 42 43 class Attendee ( _CalAddress ): \"\"\"The ATTENDEE property defines an \"Attendee\" within a calendar component.\"\"\" pass CalScale Bases: Property The CALSCALE property defines the calendar scale used for the calendar information specified in the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 19 20 21 22 23 24 25 class CalScale ( Property ): \"\"\" The CALSCALE property defines the calendar scale used for the calendar information specified in the iCalendar object. \"\"\" pass Categories Bases: Property The CATEGORIES property defines the categories for a calendar component. Source code in ical_library/ical_properties/pass_properties.py 82 83 84 85 class Categories ( Property ): \"\"\"The CATEGORIES property defines the categories for a calendar component.\"\"\" pass Class Bases: Property The CLASS property defines the access classification for a calendar component. Source code in ical_library/ical_properties/pass_properties.py 34 35 36 37 class Class ( Property ): \"\"\"The CLASS property defines the access classification for a calendar component.\"\"\" pass Comment Bases: Property The COMMENT property specifies non-processing information intended to provide a comment to the calendar user. Source code in ical_library/ical_properties/pass_properties.py 138 139 140 141 class Comment ( Property ): \"\"\"The COMMENT property specifies non-processing information intended to provide a comment to the calendar user.\"\"\" pass Completed Bases: _DTSingular The COMPLETED property defines the date and time that a to-do was actually completed. Source code in ical_library/ical_properties/dt.py 106 107 108 109 class Completed ( _DTSingular ): \"\"\"The COMPLETED property defines the date and time that a to-do was actually completed.\"\"\" pass Contact Bases: Property The CONTACT property is used to represent contact information or alternately a reference to contact information associated with the calendar component. Source code in ical_library/ical_properties/pass_properties.py 88 89 90 91 92 93 94 class Contact ( Property ): \"\"\" The CONTACT property is used to represent contact information or alternately a reference to contact information associated with the calendar component. \"\"\" pass Created Bases: _DTSingular The CREATED property defines the date and time that the calendar information was created by the calendar user agent in the calendar store. Source code in ical_library/ical_properties/dt.py 113 114 115 116 117 118 119 class Created ( _DTSingular ): \"\"\" The CREATED property defines the date and time that the calendar information was created by the calendar user agent in the calendar store. \"\"\" pass DTEnd Bases: _DTBoth The DTEND property specifies the date and time that a calendar component ends. Source code in ical_library/ical_properties/dt.py 60 61 62 63 class DTEnd ( _DTBoth ): \"\"\"The DTEND property specifies the date and time that a calendar component ends.\"\"\" pass DTStamp Bases: _DTBoth The DTSTAMP property is defined as followed. In the case of an iCalendar object that specifies a \"METHOD\" property, this property specifies the date and time that the instance of the iCalendar object was created. In the case of an iCalendar object that doesn't specify a \"METHOD\" property, this property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. Source code in ical_library/ical_properties/dt.py 93 94 95 96 97 98 99 100 101 102 class DTStamp ( _DTBoth ): \"\"\"The DTSTAMP property is defined as followed. In the case of an iCalendar object that specifies a \"METHOD\" property, this property specifies the date and time that the instance of the iCalendar object was created. In the case of an iCalendar object that doesn't specify a \"METHOD\" property, this property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. \"\"\" pass DTStart Bases: _DTBoth The DTSTART property specifies when the calendar component begins.. Source code in ical_library/ical_properties/dt.py 53 54 55 56 class DTStart ( _DTBoth ): \"\"\"The DTSTART property specifies when the calendar component begins..\"\"\" pass Description Bases: Property The DESCRIPTION property provides a more complete description of the calendar component than that provided by the \"SUMMARY\" property. Source code in ical_library/ical_properties/pass_properties.py 40 41 42 43 44 45 46 class Description ( Property ): \"\"\" The DESCRIPTION property provides a more complete description of the calendar component than that provided by the \"SUMMARY\" property. \"\"\" pass Due Bases: _DTBoth This DUE property defines the date and time that a to-do is expected to be completed.. Source code in ical_library/ical_properties/dt.py 67 68 69 70 class Due ( _DTBoth ): \"\"\"This DUE property defines the date and time that a to-do is expected to be completed..\"\"\" pass EXDate Bases: _ExOrRDate The EXDATE property defines the list of DATE-TIME exceptions for recurring events, to-dos, journal entries, or time zone definitions. Source code in ical_library/ical_properties/periods.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class EXDate ( _ExOrRDate ): \"\"\" The EXDATE property defines the list of DATE-TIME exceptions for recurring events, to-dos, journal entries, or time zone definitions. \"\"\" @property def kind ( self ) -> Optional [ Literal [ \"DATE-TIME\" , \"DATE\" ]]: \"\"\"The kind of the values. It is either DATE-TIME or DATE. The default is DATE-TIME.\"\"\" return self . property_parameters . get ( \"VALUE\" , \"DATE-TIME\" ) @property def excluded_date_times ( self ) -> Union [ List [ DateTime ], List [ Date ]]: \"\"\"A list of all excluded Dates or DateTimes. The type will be according to kind reported by `self.kind()`.\"\"\" if self . kind == \"DATE-TIME\" : return self . _parse_datetime_values () elif self . kind == \"DATE\" : return self . _parse_date_values () else : raise ValueError ( f \" { self . kind =} should be one in ['DATE-TIME', 'DATE'].\" ) excluded_date_times : Union [ List [ DateTime ], List [ Date ]] property A list of all excluded Dates or DateTimes. The type will be according to kind reported by self.kind() . kind : Optional [ Literal [ 'DATE-TIME' , 'DATE' ]] property The kind of the values. It is either DATE-TIME or DATE. The default is DATE-TIME. FreeBusyProperty Bases: _PeriodFunctionality The FREEBUSY property defines one or more free or busy time intervals. Note: This class is called FreeBusyProperty to not be confused with the VFreeBusy component. Source code in ical_library/ical_properties/periods.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class FreeBusyProperty ( _PeriodFunctionality ): \"\"\" The FREEBUSY property defines one or more free or busy time intervals. Note: This class is called FreeBusyProperty to not be confused with the VFreeBusy component. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *FREEBUSYPROPERTY* but *FREEBUSY*.\"\"\" return \"FREEBUSY\" @property def free_busy_type ( self ) -> str : \"\"\" Specifies the free or busy time type. Values are usually in the following list but can be anything: FREE, BUSY, BUSY-UNAVAILABLE, BUSY-TENTATIVE \"\"\" return self . get_property_parameter_default ( \"FBTYPE\" , \"BUSY\" ) @property def periods ( self ) -> List [ Tuple [ DateTime , DateTime ]]: \"\"\" All the periods present in this property for which we define a free or busy time. :return: A list of tuples, where each tuple values consists of two DateTimes indicating the start and end respectively. \"\"\" return self . _parse_period_values () free_busy_type : str property Specifies the free or busy time type. Values are usually in the following list but can be anything: FREE, BUSY, BUSY-UNAVAILABLE, BUSY-TENTATIVE periods : List [ Tuple [ DateTime , DateTime ]] property All the periods present in this property for which we define a free or busy time. Returns: Type Description A list of tuples, where each tuple values consists of two DateTimes indicating the start and end respectively. get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not FREEBUSYPROPERTY but FREEBUSY . Source code in ical_library/ical_properties/periods.py 121 122 123 124 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *FREEBUSYPROPERTY* but *FREEBUSY*.\"\"\" return \"FREEBUSY\" GEO Bases: Property The GEO property specifies information related to the global position for the activity specified by a calendar component. Source code in ical_library/ical_properties/geo.py 6 7 8 9 10 11 12 13 14 15 16 class GEO ( Property ): \"\"\" The GEO property specifies information related to the global position for the activity specified by a calendar component. \"\"\" @property def geo_value ( self ) -> Tuple [ float , float ]: \"\"\"Return the value as two floats representing the latitude and longitude.\"\"\" latitude , longitude = self . value . split ( \";\" ) return float ( latitude ), float ( longitude ) geo_value : Tuple [ float , float ] property Return the value as two floats representing the latitude and longitude. ICALDuration Bases: Property The DURATION property specifies a positive duration of time. Source code in ical_library/ical_properties/ical_duration.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ICALDuration ( Property ): \"\"\"The DURATION property specifies a positive duration of time.\"\"\" @property def duration ( self ) -> pendulum . Duration : \"\"\"Return the value as a parsed pendulum.Duration. Example value: PT1H0M0S.\"\"\" parsed_value : pendulum . Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , pendulum . Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *ICALDURATION* but *DURATION*.\"\"\" return \"DURATION\" duration : pendulum . Duration property Return the value as a parsed pendulum.Duration. Example value: PT1H0M0S. get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not ICALDURATION but DURATION . Source code in ical_library/ical_properties/ical_duration.py 17 18 19 20 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *ICALDURATION* but *DURATION*.\"\"\" return \"DURATION\" LastModified Bases: _DTSingular The LAST-MODIFIED property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. Source code in ical_library/ical_properties/dt.py 123 124 125 126 127 128 129 130 131 132 class LastModified ( _DTSingular ): \"\"\" The LAST-MODIFIED property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"LAST-MODIFIED\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not LASTMODIFIED but LAST-MODIFIED . Source code in ical_library/ical_properties/dt.py 129 130 131 132 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"LAST-MODIFIED\" Location Bases: Property The LOCATION property defines the intended venue for the activity defined by a calendar component. Source code in ical_library/ical_properties/pass_properties.py 49 50 51 52 class Location ( Property ): \"\"\"The LOCATION property defines the intended venue for the activity defined by a calendar component.\"\"\" pass Method Bases: Property The METHOD property defines the iCalendar object method associated with the calendar object. Source code in ical_library/ical_properties/pass_properties.py 28 29 30 31 class Method ( Property ): \"\"\"The METHOD property defines the iCalendar object method associated with the calendar object.\"\"\" pass Organizer Bases: _CalAddress The ORGANIZER property defines the organizer for a calendar component. Source code in ical_library/ical_properties/cal_address.py 46 47 48 49 class Organizer ( _CalAddress ): \"\"\"The ORGANIZER property defines the organizer for a calendar component.\"\"\" pass PercentComplete Bases: _IntProperty The PERCENT-COMPLETE property is used by an assignee or delegatee of a to-do to convey the percent completion of a to-do to the \"Organizer\". Source code in ical_library/ical_properties/ints.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class PercentComplete ( _IntProperty ): \"\"\" The PERCENT-COMPLETE property is used by an assignee or delegatee of a to-do to convey the percent completion of a to-do to the \"Organizer\". \"\"\" @property def percentage ( self ) -> int : return self . int_value @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *PERCENTCOMPLETE* but *PERCENT-COMPLETE*.\"\"\" return \"PERCENT-COMPLETE\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not PERCENTCOMPLETE but PERCENT-COMPLETE . Source code in ical_library/ical_properties/ints.py 43 44 45 46 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *PERCENTCOMPLETE* but *PERCENT-COMPLETE*.\"\"\" return \"PERCENT-COMPLETE\" Priority Bases: _IntProperty The PRIORITY property represents the relative priority for a calendar component. Source code in ical_library/ical_properties/ints.py 13 14 15 16 class Priority ( _IntProperty ): \"\"\"The PRIORITY property represents the relative priority for a calendar component.\"\"\" pass ProdID Bases: Property The PRODID property specifies the identifier for the product that created the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 4 5 6 7 class ProdID ( Property ): \"\"\"The PRODID property specifies the identifier for the product that created the iCalendar object.\"\"\" pass RDate Bases: _ExOrRDate The RDATE property defines the list of DATE-TIME values for recurring events, to-dos, journal entries, or time zone definitions. Source code in ical_library/ical_properties/periods.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class RDate ( _ExOrRDate ): \"\"\" The RDATE property defines the list of DATE-TIME values for recurring events, to-dos, journal entries, or time zone definitions. \"\"\" @property def kind ( self ) -> Optional [ Literal [ \"DATE-TIME\" , \"DATE\" , \"PERIOD\" ]]: \"\"\"The kind of the values. It is either DATE-TIME, DATE or PERIOD. The default is DATE-TIME.\"\"\" return self . property_parameters . get ( \"VALUE\" , \"DATE-TIME\" ) @property def all_values ( self ) -> Union [ List [ DateTime ], List [ Date ], List [ Tuple [ DateTime , DateTime ]]]: \"\"\" A list of all recurring Dates, DateTimes or Periods. The periods are defined by tuples containing two datetimes representing the start and stop respectively. The returned types in the list will be according to the kind reported by `self.kind()`. \"\"\" if self . kind == \"DATE-TIME\" : return self . _parse_datetime_values () elif self . kind == \"DATE\" : return self . _parse_date_values () elif self . kind == \"PERIOD\" : return self . _parse_period_values () else : raise ValueError ( f \" { self . kind =} should be one in ['DATE-TIME', 'DATE', 'PERIOD'].\" ) def compute_max_end_date ( self , component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" max_value : Optional [ DateTime ] = None for value in self . all_values : if isinstance ( value , Date ): # This covers both Date and DateTime dt : DateTime = dt_utils . convert_time_object_to_datetime ( value ) dt : DateTime = dt + component_duration # type: ignore # Pendulum at fault here. dt = dt_utils . convert_time_object_to_aware_datetime ( dt ) if max_value is None or dt > max_value : max_value = dt elif isinstance ( value , tuple ) and len ( value ) == 2 : dt : DateTime = dt_utils . convert_time_object_to_aware_datetime ( value [ 1 ]) if max_value is None or dt > max_value : max_value = dt else : raise ValueError ( f \"Unexpected value encountered: { value } .\" ) return max_value or DateTime . max all_values : Union [ List [ DateTime ], List [ Date ], List [ Tuple [ DateTime , DateTime ]]] property A list of all recurring Dates, DateTimes or Periods. The periods are defined by tuples containing two datetimes representing the start and stop respectively. The returned types in the list will be according to the kind reported by self.kind() . kind : Optional [ Literal [ 'DATE-TIME' , 'DATE' , 'PERIOD' ]] property The kind of the values. It is either DATE-TIME, DATE or PERIOD. The default is DATE-TIME. compute_max_end_date ( component_duration ) To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). Parameters: Name Type Description Default component_duration Duration The duration of the component which has the recurring properties. required Returns: Type Description DateTime An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date Source code in ical_library/ical_properties/periods.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def compute_max_end_date ( self , component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" max_value : Optional [ DateTime ] = None for value in self . all_values : if isinstance ( value , Date ): # This covers both Date and DateTime dt : DateTime = dt_utils . convert_time_object_to_datetime ( value ) dt : DateTime = dt + component_duration # type: ignore # Pendulum at fault here. dt = dt_utils . convert_time_object_to_aware_datetime ( dt ) if max_value is None or dt > max_value : max_value = dt elif isinstance ( value , tuple ) and len ( value ) == 2 : dt : DateTime = dt_utils . convert_time_object_to_aware_datetime ( value [ 1 ]) if max_value is None or dt > max_value : max_value = dt else : raise ValueError ( f \"Unexpected value encountered: { value } .\" ) return max_value or DateTime . max RRule Bases: Property The RRULE property defines a rule or repeating pattern for recurring events, to-dos, journal entries, or time zone definitions. For more in depth restrictions and possibilities we refer you to the RTFC 5545 section 3.3.10. Recurrence Rule . Source code in ical_library/ical_properties/rrule.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class RRule ( Property ): \"\"\" The RRULE property defines a rule or repeating pattern for recurring events, to-dos, journal entries, or time zone definitions. For more in depth restrictions and possibilities we refer you to the `RTFC 5545` section `3.3.10. Recurrence Rule`. \"\"\" @property @instance_lru_cache () def value_as_dict ( self ) -> Dict [ str , str ]: \"\"\" Parse all recurrence rule parts as a dictionary, so it can be used as an easy lookup. :return: A dict mapping of str to str containing all recurrence rule parts. \"\"\" all_values = [ tuple ( key_and_value . split ( \"=\" )) for key_and_value in self . _value . split ( \";\" )] return { key : value for key , value in all_values } @property def freq ( self ) -> str : \"\"\" The FREQUENCY rule identifies the type of recurrence rule. Possible values are: SECONDLY, MINUTELY, HOURLY, DAILY, WEEKLY, MONTHLY and YEARLY. This is the only required field. :return: The frequency as a string. \"\"\" return self . value_as_dict [ \"FREQ\" ] @property def freq_dateutil ( self ) -> int : \"\"\" Return the frequency in the format dateutil expects which is a map of the string to an integer. :return: An integer in the range of 0 to 6. \"\"\" return getattr ( base_for_time_periods , self . freq ) @property def until ( self ) -> Optional [ Union [ Date , DateTime ]]: \"\"\" The UNTIL rule defines a DATE or DATE-TIME value that bounds the recurrence rule in an inclusive manner. This is optional but may not occur together with COUNT. :return: None or a positive integer. \"\"\" if ( until_value := self . value_as_dict . get ( \"UNTIL\" , None )) is not None : return dt_utils . parse_date_or_datetime ( until_value ) return None @property def count ( self ) -> Optional [ int ]: \"\"\" The COUNT rule defines the number of occurrences at which to range-bound the recurrence. This is optional but may not occur together with UNTIL. :return: None or a positive integer. \"\"\" count_value = self . value_as_dict . get ( \"COUNT\" , None ) return int ( count_value ) if count_value else None @property def interval ( self ) -> int : \"\"\" The INTERVAL rule contains a positive integer representing at which intervals the recurrence rule repeats. :return: A positive integer. \"\"\" return int ( self . value_as_dict . get ( \"INTERVAL\" , 1 )) @staticmethod def convert_str_to_optional_integer_tuple ( value : Optional [ str ]) -> Optional [ Tuple [ int , ... ]]: \"\"\" Converts a string to a Tuple of integers. :return: None or a Tuple of integers if the value exists, otherwise None. \"\"\" if not value : return None return tuple ( int ( item ) for item in value . split ( \",\" )) @property def by_second ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYSECOND rule part specifies a COMMA-separated list of seconds within a minute. :return: None or a list of integers in the range of 0 to 60. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYSECOND\" )) @property def by_minute ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMINUTE rule part specifies a COMMA-separated list of minutes within an hour. :return: None or a list of integers in the range of 0 to 59. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMINUTE\" )) @property def by_hour ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYHOUR rule part specifies a COMMA-separated list of hours of the day. :return: None or a list of integers in the range of 0 to 23. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYHOUR\" )) def by_day ( self ) -> Optional [ List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]]]: \"\"\" The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU :return None or a list of tuples of two values. The first value represents possible specified nth occurrence or None. The second value the day of the week as a SU, MO, TU, WE, TH, FR or SA. \"\"\" value = self . value_as_dict . get ( \"BYDAY\" ) if not value : return None list_of_days : List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]] = [] for a_day in value . split ( \",\" ): a_day = a_day . strip () nth_occurence : Optional [ int ] = int ( a_day [: - 2 ]) if len ( a_day ) > 2 else None day_of_week : str = a_day [ - 2 :] if day_of_week not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError list_of_days . append (( nth_occurence , day_of_week )) # type: ignore return list_of_days @property def by_day_dateutil ( self ) -> Optional [ Tuple [ weekday , ... ]]: \"\"\" Return the by_day in the format dateutil expects which is a tuple of weekday instance. :return: None or a tuple of weekday instances which is a type native to dateutil. \"\"\" day_list : List [ weekday ] = [] by_day = self . by_day () if by_day is None : return None for optional_nth_occurrence , weekday_str in by_day : try : if optional_nth_occurrence is not None : day_list . append ( getattr ( base_for_time_periods , weekday_str )( optional_nth_occurrence )) else : day_list . append ( getattr ( base_for_time_periods , weekday_str )) except Exception as exc : raise ValueError ( f \" { optional_nth_occurrence =} , { weekday_str =} \" ) from exc return tuple ( day_list ) @property def by_month_day ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMONTHDAY rule part specifies a COMMA-separated list of days of the month. For example: -10 represents the tenth to the last day of the month. :return: None or a tuple of integers in the range of 1 to 31 or -31 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMONTHDAY\" )) @property def by_year_day ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYYEARDAY rule part specifies a COMMA-separated list of days of the year. For example: -1 represents the last day of the year (December 31st). :return: None or a tuple of integers in the range of 1 to 366 or -366 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYYEARDAY\" )) @property def by_week_no ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYWEEKNO rule part specifies a COMMA-separated list of ordinals specifying weeks of the year. For example: 3 represents the third week of the year. :return: None or an integer in the range of 1 to 53 or -53 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYWEEKNO\" )) @property def by_month ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMONTH rule part specifies a COMMA-separated list of months of the year. :return: None or a list of integers in the range of 1 to 12. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMONTH\" )) @property def by_set_pos ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYSETPOS rule part specifies a COMMA-separated list of values that corresponds to the nth occurrence within the set of recurrence instances specified by the rule. BYSETPOS operates on a set of recurrence instances in one interval of the recurrence rule. For example, in a WEEKLY rule, the interval would be one week A set of recurrence instances starts at the beginning of the interval defined by the FREQ rule part. :return: None or a list of integers in the range of 1 to 366 or -366 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYSETPOS\" )) @property def wkst ( self ) -> Optional [ str ]: \"\"\" The WKST rule part specifies the day on which the workweek starts. :return: A string that is the value of MO, TU, WE, TH, FR, SA, or SU or None. \"\"\" day = self . value_as_dict . get ( \"WKST\" ) if not day : return None if day not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError ( f \" { day =} is not in the list of weekdays.\" ) return day @property def wkst_dateutil ( self ) -> Optional [ int ]: \"\"\" Return the wkst in the format dateutil expects which is an integer. 0 for MO, 1 for TU, 2 for WE, ... :return: An integer in the range of 0 to 6 or None. \"\"\" day = self . wkst return getattr ( base_for_time_periods , day ) if self . wkst is not None else None @property def by_easter ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" According to dateutil, this is an extension of the RFC specification.. I can't find it. If anyone can, please file an issue or a PR to add it here as a reference. The BYEASTER rule part specifies the offset from the Easter Sunday. :return: None or an integer in the range of 1 to 366 or -366 to -1 or None. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYEASTER\" )) def compute_max_end_date ( self , starting_datetime : Union [ Date , DateTime ], component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" if self . until : return dt_utils . convert_time_object_to_aware_datetime ( self . until ) + component_duration # type: ignore elif self . count : if self . count < 1000 : max_datetime = DateTime . max if isinstance ( starting_datetime , DateTime ) else Date ( 9999 , 12 , 31 ) * _ , last = self . sequence_iterator ( starting_datetime = starting_datetime , max_datetime = max_datetime ) return dt_utils . convert_time_object_to_aware_datetime ( last ) + component_duration # type: ignore return DateTime . max def sequence_iterator ( self , starting_datetime : Union [ Date , DateTime ], max_datetime : Union [ Date , DateTime ] ) -> Iterator [ DateTime ]: \"\"\" Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param max_datetime: The maximum datetime. If we reach this datetime, we stop the iteration.. :return: Yield all datetimes(except itself) in the sequence. \"\"\" if type ( starting_datetime ) != type ( max_datetime ): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of the same type.\" ) if isinstance ( starting_datetime , DateTime ): if ( starting_datetime . tz or max_datetime . tz ) and ( not starting_datetime . tz or not max_datetime . tz ): raise TypeError ( f \"The tz info should be consistent: { starting_datetime =} , { max_datetime =} .\" ) if not isinstance ( starting_datetime , ( Date , DateTime )) or not isinstance ( max_datetime , ( Date , DateTime )): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of Date or DateTime.\" ) if starting_datetime > max_datetime : raise ValueError ( f \"This should not be the case: { starting_datetime =} >= { max_datetime =} .\" ) if not ( is_datetime_format := isinstance ( starting_datetime , DateTime ) and isinstance ( max_datetime , DateTime )): starting_datetime = DateTime ( starting_datetime . year , starting_datetime . month , starting_datetime . day ) max_datetime = DateTime ( max_datetime . year , max_datetime . month , max_datetime . day ) starting_datetime = starting_datetime max_datetime = max_datetime starting_tz = starting_datetime . tz until = self . until if until : if not isinstance ( until , DateTime ): until = DateTime ( until . year , until . month , until . day ) until = until . replace ( tzinfo = None ) if starting_tz is None else until . in_timezone ( starting_tz ) keyword_arguments = { \"until\" : until , \"count\" : self . count , \"interval\" : self . interval , \"bysecond\" : self . by_second , \"byminute\" : self . by_minute , \"byhour\" : self . by_hour , \"byweekday\" : self . by_day_dateutil , \"bymonthday\" : self . by_month_day , \"byyearday\" : self . by_year_day , \"byweekno\" : self . by_week_no , \"bymonth\" : self . by_month , \"bysetpos\" : self . by_set_pos , \"wkst\" : self . wkst_dateutil , \"byeaster\" : self . by_easter , } no_none_keywords = { key : value for key , value in keyword_arguments . items () if value is not None } dt_iterator = rrule ( dtstart = starting_datetime , freq = self . freq_dateutil , ** no_none_keywords ) for dt in dt_iterator : if dt > max_datetime : break p_instance = pendulum . instance ( dt , tz = None ) yield p_instance if is_datetime_format else p_instance . date () by_day_dateutil : Optional [ Tuple [ weekday , ... ]] property Return the by_day in the format dateutil expects which is a tuple of weekday instance. Returns: Type Description None or a tuple of weekday instances which is a type native to dateutil. by_easter : Optional [ Tuple [ int , ... ]] property According to dateutil, this is an extension of the RFC specification.. I can't find it. If anyone can, please file an issue or a PR to add it here as a reference. The BYEASTER rule part specifies the offset from the Easter Sunday. Returns: Type Description None or an integer in the range of 1 to 366 or -366 to -1 or None. by_hour : Optional [ Tuple [ int , ... ]] property The BYHOUR rule part specifies a COMMA-separated list of hours of the day. Returns: Type Description None or a list of integers in the range of 0 to 23. by_minute : Optional [ Tuple [ int , ... ]] property The BYMINUTE rule part specifies a COMMA-separated list of minutes within an hour. Returns: Type Description None or a list of integers in the range of 0 to 59. by_month : Optional [ Tuple [ int , ... ]] property The BYMONTH rule part specifies a COMMA-separated list of months of the year. Returns: Type Description None or a list of integers in the range of 1 to 12. by_month_day : Optional [ Tuple [ int , ... ]] property The BYMONTHDAY rule part specifies a COMMA-separated list of days of the month. For example: -10 represents the tenth to the last day of the month. Returns: Type Description None or a tuple of integers in the range of 1 to 31 or -31 to -1. by_second : Optional [ Tuple [ int , ... ]] property The BYSECOND rule part specifies a COMMA-separated list of seconds within a minute. Returns: Type Description None or a list of integers in the range of 0 to 60. by_set_pos : Optional [ Tuple [ int , ... ]] property The BYSETPOS rule part specifies a COMMA-separated list of values that corresponds to the nth occurrence within the set of recurrence instances specified by the rule. BYSETPOS operates on a set of recurrence instances in one interval of the recurrence rule. For example, in a WEEKLY rule, the interval would be one week A set of recurrence instances starts at the beginning of the interval defined by the FREQ rule part. Returns: Type Description None or a list of integers in the range of 1 to 366 or -366 to -1. by_week_no : Optional [ Tuple [ int , ... ]] property The BYWEEKNO rule part specifies a COMMA-separated list of ordinals specifying weeks of the year. For example: 3 represents the third week of the year. Returns: Type Description None or an integer in the range of 1 to 53 or -53 to -1. by_year_day : Optional [ Tuple [ int , ... ]] property The BYYEARDAY rule part specifies a COMMA-separated list of days of the year. For example: -1 represents the last day of the year (December 31st). Returns: Type Description None or a tuple of integers in the range of 1 to 366 or -366 to -1. count : Optional [ int ] property The COUNT rule defines the number of occurrences at which to range-bound the recurrence. This is optional but may not occur together with UNTIL. Returns: Type Description None or a positive integer. freq : str property The FREQUENCY rule identifies the type of recurrence rule. Possible values are: SECONDLY, MINUTELY, HOURLY, DAILY, WEEKLY, MONTHLY and YEARLY. This is the only required field. Returns: Type Description The frequency as a string. freq_dateutil : int property Return the frequency in the format dateutil expects which is a map of the string to an integer. Returns: Type Description An integer in the range of 0 to 6. interval : int property The INTERVAL rule contains a positive integer representing at which intervals the recurrence rule repeats. Returns: Type Description A positive integer. until : Optional [ Union [ Date , DateTime ]] property The UNTIL rule defines a DATE or DATE-TIME value that bounds the recurrence rule in an inclusive manner. This is optional but may not occur together with COUNT. Returns: Type Description None or a positive integer. value_as_dict : Dict [ str , str ] property Parse all recurrence rule parts as a dictionary, so it can be used as an easy lookup. Returns: Type Description A dict mapping of str to str containing all recurrence rule parts. wkst : Optional [ str ] property The WKST rule part specifies the day on which the workweek starts. Returns: Type Description A string that is the value of MO, TU, WE, TH, FR, SA, or SU or None. wkst_dateutil : Optional [ int ] property Return the wkst in the format dateutil expects which is an integer. 0 for MO, 1 for TU, 2 for WE, ... Returns: Type Description An integer in the range of 0 to 6 or None. by_day () The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU Source code in ical_library/ical_properties/rrule.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def by_day ( self ) -> Optional [ List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]]]: \"\"\" The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU :return None or a list of tuples of two values. The first value represents possible specified nth occurrence or None. The second value the day of the week as a SU, MO, TU, WE, TH, FR or SA. \"\"\" value = self . value_as_dict . get ( \"BYDAY\" ) if not value : return None list_of_days : List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]] = [] for a_day in value . split ( \",\" ): a_day = a_day . strip () nth_occurence : Optional [ int ] = int ( a_day [: - 2 ]) if len ( a_day ) > 2 else None day_of_week : str = a_day [ - 2 :] if day_of_week not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError list_of_days . append (( nth_occurence , day_of_week )) # type: ignore return list_of_days compute_max_end_date ( starting_datetime , component_duration ) To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). Parameters: Name Type Description Default starting_datetime Union [ Date , DateTime ] The starting datetime from which we start computing the next occurrences. required component_duration Duration The duration of the component which has the recurring properties. required Returns: Type Description DateTime An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date Source code in ical_library/ical_properties/rrule.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def compute_max_end_date ( self , starting_datetime : Union [ Date , DateTime ], component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" if self . until : return dt_utils . convert_time_object_to_aware_datetime ( self . until ) + component_duration # type: ignore elif self . count : if self . count < 1000 : max_datetime = DateTime . max if isinstance ( starting_datetime , DateTime ) else Date ( 9999 , 12 , 31 ) * _ , last = self . sequence_iterator ( starting_datetime = starting_datetime , max_datetime = max_datetime ) return dt_utils . convert_time_object_to_aware_datetime ( last ) + component_duration # type: ignore return DateTime . max convert_str_to_optional_integer_tuple ( value ) staticmethod Converts a string to a Tuple of integers. Returns: Type Description Optional [ Tuple [ int , ...]] None or a Tuple of integers if the value exists, otherwise None. Source code in ical_library/ical_properties/rrule.py 78 79 80 81 82 83 84 85 86 @staticmethod def convert_str_to_optional_integer_tuple ( value : Optional [ str ]) -> Optional [ Tuple [ int , ... ]]: \"\"\" Converts a string to a Tuple of integers. :return: None or a Tuple of integers if the value exists, otherwise None. \"\"\" if not value : return None return tuple ( int ( item ) for item in value . split ( \",\" )) sequence_iterator ( starting_datetime , max_datetime ) Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. Parameters: Name Type Description Default starting_datetime Union [ Date , DateTime ] The starting datetime from which we start computing the next occurrences. required max_datetime Union [ Date , DateTime ] The maximum datetime. If we reach this datetime, we stop the iteration.. required Returns: Type Description Iterator [ DateTime ] Yield all datetimes(except itself) in the sequence. Source code in ical_library/ical_properties/rrule.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def sequence_iterator ( self , starting_datetime : Union [ Date , DateTime ], max_datetime : Union [ Date , DateTime ] ) -> Iterator [ DateTime ]: \"\"\" Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param max_datetime: The maximum datetime. If we reach this datetime, we stop the iteration.. :return: Yield all datetimes(except itself) in the sequence. \"\"\" if type ( starting_datetime ) != type ( max_datetime ): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of the same type.\" ) if isinstance ( starting_datetime , DateTime ): if ( starting_datetime . tz or max_datetime . tz ) and ( not starting_datetime . tz or not max_datetime . tz ): raise TypeError ( f \"The tz info should be consistent: { starting_datetime =} , { max_datetime =} .\" ) if not isinstance ( starting_datetime , ( Date , DateTime )) or not isinstance ( max_datetime , ( Date , DateTime )): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of Date or DateTime.\" ) if starting_datetime > max_datetime : raise ValueError ( f \"This should not be the case: { starting_datetime =} >= { max_datetime =} .\" ) if not ( is_datetime_format := isinstance ( starting_datetime , DateTime ) and isinstance ( max_datetime , DateTime )): starting_datetime = DateTime ( starting_datetime . year , starting_datetime . month , starting_datetime . day ) max_datetime = DateTime ( max_datetime . year , max_datetime . month , max_datetime . day ) starting_datetime = starting_datetime max_datetime = max_datetime starting_tz = starting_datetime . tz until = self . until if until : if not isinstance ( until , DateTime ): until = DateTime ( until . year , until . month , until . day ) until = until . replace ( tzinfo = None ) if starting_tz is None else until . in_timezone ( starting_tz ) keyword_arguments = { \"until\" : until , \"count\" : self . count , \"interval\" : self . interval , \"bysecond\" : self . by_second , \"byminute\" : self . by_minute , \"byhour\" : self . by_hour , \"byweekday\" : self . by_day_dateutil , \"bymonthday\" : self . by_month_day , \"byyearday\" : self . by_year_day , \"byweekno\" : self . by_week_no , \"bymonth\" : self . by_month , \"bysetpos\" : self . by_set_pos , \"wkst\" : self . wkst_dateutil , \"byeaster\" : self . by_easter , } no_none_keywords = { key : value for key , value in keyword_arguments . items () if value is not None } dt_iterator = rrule ( dtstart = starting_datetime , freq = self . freq_dateutil , ** no_none_keywords ) for dt in dt_iterator : if dt > max_datetime : break p_instance = pendulum . instance ( dt , tz = None ) yield p_instance if is_datetime_format else p_instance . date () RecurrenceID Bases: _DTBoth The RECURRENCE-ID property is defined as followed. This property is used in conjunction with the \"UID\" and \"SEQUENCE\" properties to identify a specific instance of a recurring \"VEVENT\", \"VTODO\", or \"VJOURNAL\" calendar component. The property value is the original value of the \"DTSTART\" property of the recurrence instance. Value Type: The default value type is DATE-TIME. The value type can be set to a DATE value type. This property MUST have the same value type as the \"DTSTART\" property contained within the recurring component. Furthermore, this property MUST be specified as a date with local time if and only if the \"DTSTART\" property contained within the recurring component is specified as a date with local time. Source code in ical_library/ical_properties/dt.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class RecurrenceID ( _DTBoth ): \"\"\" The RECURRENCE-ID property is defined as followed. This property is used in conjunction with the \"UID\" and \"SEQUENCE\" properties to identify a specific instance of a recurring \"VEVENT\", \"VTODO\", or \"VJOURNAL\" calendar component. The property value is the original value of the \"DTSTART\" property of the recurrence instance. Value Type: The default value type is DATE-TIME. The value type can be set to a DATE value type. This property MUST have the same value type as the \"DTSTART\" property contained within the recurring component. Furthermore, this property MUST be specified as a date with local time if and only if the \"DTSTART\" property contained within the recurring component is specified as a date with local time. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"RECURRENCE-ID\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not LASTMODIFIED but LAST-MODIFIED . Source code in ical_library/ical_properties/dt.py 86 87 88 89 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"RECURRENCE-ID\" RelatedTo Bases: Property The RELATED-TO property is used to represent a relationship or reference between one calendar component and another. Source code in ical_library/ical_properties/pass_properties.py 106 107 108 109 110 111 112 113 114 class RelatedTo ( Property ): \"\"\" The RELATED-TO property is used to represent a relationship or reference between one calendar component and another. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *RELATEDTO* but *RELATED-TO*.\"\"\" return \"RELATED-TO\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not RELATEDTO but RELATED-TO . Source code in ical_library/ical_properties/pass_properties.py 111 112 113 114 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *RELATEDTO* but *RELATED-TO*.\"\"\" return \"RELATED-TO\" Repeat Bases: _IntProperty The REPEAT property defines the number of times the alarm should be repeated, after the initial trigger. Source code in ical_library/ical_properties/ints.py 27 28 29 30 class Repeat ( _IntProperty ): \"\"\"The REPEAT property defines the number of times the alarm should be repeated, after the initial trigger.\"\"\" pass RequestStatus Bases: Property The REQUEST-STATUS property defines the status code returned for a scheduling request. Source code in ical_library/ical_properties/pass_properties.py 97 98 99 100 101 102 103 class RequestStatus ( Property ): \"\"\"The REQUEST-STATUS property defines the status code returned for a scheduling request.\"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *REQUESTSTATUS* but *REQUEST-STATUS*.\"\"\" return \"REQUEST-STATUS\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not REQUESTSTATUS but REQUEST-STATUS . Source code in ical_library/ical_properties/pass_properties.py 100 101 102 103 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *REQUESTSTATUS* but *REQUEST-STATUS*.\"\"\" return \"REQUEST-STATUS\" Resources Bases: Property The RESOURCES property defines the equipment or resources anticipated for an activity specified by a calendar component. Source code in ical_library/ical_properties/pass_properties.py 117 118 119 120 121 122 123 class Resources ( Property ): \"\"\" The RESOURCES property defines the equipment or resources anticipated for an activity specified by a calendar component. \"\"\" pass Sequence Bases: _IntProperty The SEQUENCE property defines the revision sequence number of the calendar component within a sequence of revisions. Source code in ical_library/ical_properties/ints.py 19 20 21 22 23 24 class Sequence ( _IntProperty ): \"\"\" The SEQUENCE property defines the revision sequence number of the calendar component within a sequence of revisions. \"\"\" pass Status Bases: Property The STATUS property defines the overall status or confirmation for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 55 56 57 58 class Status ( Property ): \"\"\"The STATUS property defines the overall status or confirmation for the calendar component.\"\"\" pass Summary Bases: Property The SUMMARY property defines a short summary or subject for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 168 169 170 171 172 173 class Summary ( Property ): \"\"\" The SUMMARY property defines a short summary or subject for the calendar component. \"\"\" pass TZID Bases: Property The TZID property specifies the text value that uniquely identifies the \"VTIMEZONE\" calendar component in the scope of an iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 150 151 152 153 154 155 156 class TZID ( Property ): \"\"\" The TZID property specifies the text value that uniquely identifies the \"VTIMEZONE\" calendar component in the scope of an iCalendar object. \"\"\" pass TZName Bases: Property The TZNAME property specifies the customary designation for a time zone description. Source code in ical_library/ical_properties/pass_properties.py 144 145 146 147 class TZName ( Property ): \"\"\"The TZNAME property specifies the customary designation for a time zone description.\"\"\" pass TZOffsetFrom Bases: _TZOffset The TZOFFSETFROM property specifies the offset that is in use prior to this time zone observance. Source code in ical_library/ical_properties/tz_offset.py 33 34 35 36 class TZOffsetFrom ( _TZOffset ): \"\"\"The TZOFFSETFROM property specifies the offset that is in use prior to this time zone observance.\"\"\" pass TZOffsetTo Bases: _TZOffset The TZOFFSETTO property specifies the offset that is in use prior to this time zone observance. Source code in ical_library/ical_properties/tz_offset.py 27 28 29 30 class TZOffsetTo ( _TZOffset ): \"\"\"The TZOFFSETTO property specifies the offset that is in use prior to this time zone observance.\"\"\" pass TZURL Bases: Property The TZURL property provides a means for a \"VTIMEZONE\" component to point to a network location that can be used to retrieve an up- to-date version of itself. Source code in ical_library/ical_properties/pass_properties.py 159 160 161 162 163 164 165 class TZURL ( Property ): \"\"\" The TZURL property provides a means for a \"VTIMEZONE\" component to point to a network location that can be used to retrieve an up- to-date version of itself. \"\"\" pass TimeTransparency Bases: Property The TRANSP property defines whether an event is transparent to busy time searches. Source code in ical_library/ical_properties/pass_properties.py 61 62 63 64 65 66 67 class TimeTransparency ( Property ): \"\"\"The TRANSP property defines whether an event is transparent to busy time searches.\"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *TIMETRANSPARANCY* but *TRANSP*.\"\"\" return \"TRANSP\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not TIMETRANSPARANCY but TRANSP . Source code in ical_library/ical_properties/pass_properties.py 64 65 66 67 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *TIMETRANSPARANCY* but *TRANSP*.\"\"\" return \"TRANSP\" Trigger Bases: Property The TRIGGER property specifies when an alarm will trigger. Source code in ical_library/ical_properties/trigger.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Trigger ( Property ): \"\"\"The TRIGGER property specifies when an alarm will trigger.\"\"\" @property def kind ( self ) -> Literal [ \"DATE-TIME\" , \"DURATION\" ]: \"\"\"Return the type of the property value.\"\"\" kind_of_value = self . get_property_parameter ( \"VALUE\" ) return \"DATE-TIME\" if kind_of_value and kind_of_value == \"DATE-TIME\" else \"DURATION\" # noqa def parse_value ( self ) -> Union [ Duration , DateTime ]: \"\"\"Parse the value of this property based on the VALUE property parameter.\"\"\" if self . kind == \"DURATION\" : parsed_value : Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value else : parsed_value : DateTime = pendulum . parse ( self . value ) if not isinstance ( parsed_value , DateTime ): raise TypeError ( f \"Invalid value passed for DateTime: { self . value =} \" ) return parsed_value def trigger_relation ( self ) -> Literal [ \"START\" , \"END\" ]: \"\"\"Get the trigger relation, whether the duration should be relative to the start or the end of a component.\"\"\" return \"START\" if self . get_property_parameter_default ( \"RELATED\" , \"START\" ) == \"START\" else \"END\" # noqa kind : Literal [ 'DATE-TIME' , 'DURATION' ] property Return the type of the property value. parse_value () Parse the value of this property based on the VALUE property parameter. Source code in ical_library/ical_properties/trigger.py 18 19 20 21 22 23 24 25 26 27 28 29 def parse_value ( self ) -> Union [ Duration , DateTime ]: \"\"\"Parse the value of this property based on the VALUE property parameter.\"\"\" if self . kind == \"DURATION\" : parsed_value : Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value else : parsed_value : DateTime = pendulum . parse ( self . value ) if not isinstance ( parsed_value , DateTime ): raise TypeError ( f \"Invalid value passed for DateTime: { self . value =} \" ) return parsed_value trigger_relation () Get the trigger relation, whether the duration should be relative to the start or the end of a component. Source code in ical_library/ical_properties/trigger.py 31 32 33 def trigger_relation ( self ) -> Literal [ \"START\" , \"END\" ]: \"\"\"Get the trigger relation, whether the duration should be relative to the start or the end of a component.\"\"\" return \"START\" if self . get_property_parameter_default ( \"RELATED\" , \"START\" ) == \"START\" else \"END\" # noqa UID Bases: Property The UID property defines the persistent, globally unique identifier for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 132 133 134 135 class UID ( Property ): \"\"\"The UID property defines the persistent, globally unique identifier for the calendar component.\"\"\" pass URL Bases: Property The URL property defines a Uniform Resource Locator (URL) associated with the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 70 71 72 73 class URL ( Property ): \"\"\"The URL property defines a Uniform Resource Locator (URL) associated with the iCalendar object.\"\"\" pass Version Bases: Property The VERSION property specifies the identifier corresponding to the highest version number or the minimum and maximum range of the iCalendar specification that is required in order to interpret the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 10 11 12 13 14 15 16 class Version ( Property ): \"\"\" The VERSION property specifies the identifier corresponding to the highest version number or the minimum and maximum range of the iCalendar specification that is required in order to interpret the iCalendar object. \"\"\" pass","title":"All Properties"},{"location":"code/properties/#all-properties","text":"All Properties are extending the Property class. Let's first start with the base class and then list all the other properties.","title":"All Properties"},{"location":"code/properties/#ical_library.base_classes.Property","text":"Bases: ICalBaseClass This is the base class for any property (according to the RFC 5545 specification) in iCal-library. A property always exists of three parts: The name of the property. The property parameters, this is optional and does not need to be present. The value of the property. A line containing a property typically has the following format: PROPERTY-NAME;parameterKey=parameterValue,anotherParameterKey=anotherValue:actual-value Any property that is predefined according to the RFC 5545 should inherit this class, e.g. UID, RRule. Only x-properties or iana-properties should instantiate the Property class directly. Parameters: Name Type Description Default value Optional [ str ] The value of the property. required name Optional [ str ] The properties name, e.g. RRULE . None property_parameters Optional [ str ] The property parameters for this definition. None parent Component Instance of the :class: Component it is a part of. None Source code in ical_library/base_classes/property.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class Property ( ICalBaseClass ): \"\"\" This is the base class for any property (according to the RFC 5545 specification) in iCal-library. A property always exists of three parts: - The name of the property. - The property parameters, this is optional and does not need to be present. - The value of the property. A line containing a property typically has the following format: `PROPERTY-NAME;parameterKey=parameterValue,anotherParameterKey=anotherValue:actual-value` Any property that is predefined according to the RFC 5545 should inherit this class, e.g. UID, RRule. Only x-properties or iana-properties should instantiate the Property class directly. :param value: The value of the property. :param name: The properties name, e.g. `RRULE`. :param property_parameters: The property parameters for this definition. :param parent: Instance of the :class:`Component` it is a part of. \"\"\" def __init__ ( self , value : Optional [ str ], name : Optional [ str ] = None , property_parameters : Optional [ str ] = None , parent : \"Component\" = None , ): name = name if self . __class__ == Property else self . __class__ . get_ical_name_of_class () super () . __init__ ( name = name , parent = parent or ComponentContext . get_current_component ()) if parent is None and self . parent is not None : self . parent . set_property ( self ) self . _property_parameters : Optional [ str ] = property_parameters self . _value : Optional [ str ] = value def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \" { self . __class__ . __name__ } ( { self . as_original_string } )\" def __eq__ ( self : \"Property\" , other : \"Property\" ) -> bool : \"\"\"Return whether the current instance and the other instance are the same.\"\"\" if type ( self ) != type ( other ): return False return self . as_original_string == other . as_original_string @property @instance_lru_cache () def property_parameters ( self ) -> Dict [ str , str ]: \"\"\" Return (and cache) all the property's parameters as a dictionary of strings. Note: When the instance is collected by the garbage collection, the cache is automatically deleted as well. :return: all the property's parameters as a dictionary of strings \"\"\" property_parameters_str = self . _property_parameters or \"\" return { key_and_value . split ( \"=\" )[ 0 ]: key_and_value . split ( \"=\" )[ 1 ] for key_and_value in property_parameters_str . split ( \",\" ) if key_and_value . count ( \"=\" ) == 1 } def has_property_parameter ( self , key : str ) -> Optional [ bool ]: \"\"\" Return whether this property has a property parameter with a specific *key*. :param key: What key to search for. :return: boolean whether this property has a property parameter with a specific *key*. \"\"\" return key in self . property_parameters def get_property_parameter ( self , key : str ) -> Optional [ str ]: \"\"\" Get a property parameter's value with a specific key. :param key: The identifier of the property parameter. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , None ) def get_property_parameter_default ( self , key : str , default : str ) -> str : \"\"\" Get a property parameter's value with a specific key, where the default may not be None. :param key: The identifier of the property parameter. :param default: A value to return when the property parameter is not present, which may not be None. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , default ) @property def value ( self ) -> Optional [ str ]: \"\"\"Return the value of this property.\"\"\" return self . _value @property def as_original_string ( self ) -> str : \"\"\" Return the iCalendar representation of the parameter. :return: the iCalendar string representation. \"\"\" add_subs = f \"; { self . _property_parameters } \" if self . _property_parameters else \"\" return f \" { self . _name }{ add_subs } : { self . _value } \"","title":"Property"},{"location":"code/properties/#ical_library.base_classes.Property.as_original_string","text":"Return the iCalendar representation of the parameter. Returns: Type Description the iCalendar string representation.","title":"as_original_string"},{"location":"code/properties/#ical_library.base_classes.Property.property_parameters","text":"Return (and cache) all the property's parameters as a dictionary of strings. Note: When the instance is collected by the garbage collection, the cache is automatically deleted as well. Returns: Type Description all the property's parameters as a dictionary of strings","title":"property_parameters"},{"location":"code/properties/#ical_library.base_classes.Property.value","text":"Return the value of this property.","title":"value"},{"location":"code/properties/#ical_library.base_classes.Property.get_property_parameter","text":"Get a property parameter's value with a specific key. Parameters: Name Type Description Default key str The identifier of the property parameter. required Returns: Type Description Optional [ str ] The requested property parameter, or if that is not present, the default value. Source code in ical_library/base_classes/property.py 84 85 86 87 88 89 90 91 def get_property_parameter ( self , key : str ) -> Optional [ str ]: \"\"\" Get a property parameter's value with a specific key. :param key: The identifier of the property parameter. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , None )","title":"get_property_parameter"},{"location":"code/properties/#ical_library.base_classes.Property.get_property_parameter_default","text":"Get a property parameter's value with a specific key, where the default may not be None. Parameters: Name Type Description Default key str The identifier of the property parameter. required default str A value to return when the property parameter is not present, which may not be None. required Returns: Type Description str The requested property parameter, or if that is not present, the default value. Source code in ical_library/base_classes/property.py 93 94 95 96 97 98 99 100 101 def get_property_parameter_default ( self , key : str , default : str ) -> str : \"\"\" Get a property parameter's value with a specific key, where the default may not be None. :param key: The identifier of the property parameter. :param default: A value to return when the property parameter is not present, which may not be None. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , default )","title":"get_property_parameter_default"},{"location":"code/properties/#ical_library.base_classes.Property.has_property_parameter","text":"Return whether this property has a property parameter with a specific key . Parameters: Name Type Description Default key str What key to search for. required Returns: Type Description Optional [ bool ] boolean whether this property has a property parameter with a specific key . Source code in ical_library/base_classes/property.py 75 76 77 78 79 80 81 82 def has_property_parameter ( self , key : str ) -> Optional [ bool ]: \"\"\" Return whether this property has a property parameter with a specific *key*. :param key: What key to search for. :return: boolean whether this property has a property parameter with a specific *key*. \"\"\" return key in self . property_parameters","title":"has_property_parameter"},{"location":"code/properties/#ical_library.ical_properties.Action","text":"Bases: Property The ACTION property defines the action to be invoked when an alarm is triggered. Source code in ical_library/ical_properties/pass_properties.py 126 127 128 129 class Action ( Property ): \"\"\"The ACTION property defines the action to be invoked when an alarm is triggered.\"\"\" pass","title":"Action"},{"location":"code/properties/#ical_library.ical_properties.Attach","text":"Bases: Property The ATTACH property provides the capability to associate a document object with a calendar component. Source code in ical_library/ical_properties/pass_properties.py 76 77 78 79 class Attach ( Property ): \"\"\"The ATTACH property provides the capability to associate a document object with a calendar component.\"\"\" pass","title":"Attach"},{"location":"code/properties/#ical_library.ical_properties.Attendee","text":"Bases: _CalAddress The ATTENDEE property defines an \"Attendee\" within a calendar component. Source code in ical_library/ical_properties/cal_address.py 40 41 42 43 class Attendee ( _CalAddress ): \"\"\"The ATTENDEE property defines an \"Attendee\" within a calendar component.\"\"\" pass","title":"Attendee"},{"location":"code/properties/#ical_library.ical_properties.CalScale","text":"Bases: Property The CALSCALE property defines the calendar scale used for the calendar information specified in the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 19 20 21 22 23 24 25 class CalScale ( Property ): \"\"\" The CALSCALE property defines the calendar scale used for the calendar information specified in the iCalendar object. \"\"\" pass","title":"CalScale"},{"location":"code/properties/#ical_library.ical_properties.Categories","text":"Bases: Property The CATEGORIES property defines the categories for a calendar component. Source code in ical_library/ical_properties/pass_properties.py 82 83 84 85 class Categories ( Property ): \"\"\"The CATEGORIES property defines the categories for a calendar component.\"\"\" pass","title":"Categories"},{"location":"code/properties/#ical_library.ical_properties.Class","text":"Bases: Property The CLASS property defines the access classification for a calendar component. Source code in ical_library/ical_properties/pass_properties.py 34 35 36 37 class Class ( Property ): \"\"\"The CLASS property defines the access classification for a calendar component.\"\"\" pass","title":"Class"},{"location":"code/properties/#ical_library.ical_properties.Comment","text":"Bases: Property The COMMENT property specifies non-processing information intended to provide a comment to the calendar user. Source code in ical_library/ical_properties/pass_properties.py 138 139 140 141 class Comment ( Property ): \"\"\"The COMMENT property specifies non-processing information intended to provide a comment to the calendar user.\"\"\" pass","title":"Comment"},{"location":"code/properties/#ical_library.ical_properties.Completed","text":"Bases: _DTSingular The COMPLETED property defines the date and time that a to-do was actually completed. Source code in ical_library/ical_properties/dt.py 106 107 108 109 class Completed ( _DTSingular ): \"\"\"The COMPLETED property defines the date and time that a to-do was actually completed.\"\"\" pass","title":"Completed"},{"location":"code/properties/#ical_library.ical_properties.Contact","text":"Bases: Property The CONTACT property is used to represent contact information or alternately a reference to contact information associated with the calendar component. Source code in ical_library/ical_properties/pass_properties.py 88 89 90 91 92 93 94 class Contact ( Property ): \"\"\" The CONTACT property is used to represent contact information or alternately a reference to contact information associated with the calendar component. \"\"\" pass","title":"Contact"},{"location":"code/properties/#ical_library.ical_properties.Created","text":"Bases: _DTSingular The CREATED property defines the date and time that the calendar information was created by the calendar user agent in the calendar store. Source code in ical_library/ical_properties/dt.py 113 114 115 116 117 118 119 class Created ( _DTSingular ): \"\"\" The CREATED property defines the date and time that the calendar information was created by the calendar user agent in the calendar store. \"\"\" pass","title":"Created"},{"location":"code/properties/#ical_library.ical_properties.DTEnd","text":"Bases: _DTBoth The DTEND property specifies the date and time that a calendar component ends. Source code in ical_library/ical_properties/dt.py 60 61 62 63 class DTEnd ( _DTBoth ): \"\"\"The DTEND property specifies the date and time that a calendar component ends.\"\"\" pass","title":"DTEnd"},{"location":"code/properties/#ical_library.ical_properties.DTStamp","text":"Bases: _DTBoth The DTSTAMP property is defined as followed. In the case of an iCalendar object that specifies a \"METHOD\" property, this property specifies the date and time that the instance of the iCalendar object was created. In the case of an iCalendar object that doesn't specify a \"METHOD\" property, this property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. Source code in ical_library/ical_properties/dt.py 93 94 95 96 97 98 99 100 101 102 class DTStamp ( _DTBoth ): \"\"\"The DTSTAMP property is defined as followed. In the case of an iCalendar object that specifies a \"METHOD\" property, this property specifies the date and time that the instance of the iCalendar object was created. In the case of an iCalendar object that doesn't specify a \"METHOD\" property, this property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. \"\"\" pass","title":"DTStamp"},{"location":"code/properties/#ical_library.ical_properties.DTStart","text":"Bases: _DTBoth The DTSTART property specifies when the calendar component begins.. Source code in ical_library/ical_properties/dt.py 53 54 55 56 class DTStart ( _DTBoth ): \"\"\"The DTSTART property specifies when the calendar component begins..\"\"\" pass","title":"DTStart"},{"location":"code/properties/#ical_library.ical_properties.Description","text":"Bases: Property The DESCRIPTION property provides a more complete description of the calendar component than that provided by the \"SUMMARY\" property. Source code in ical_library/ical_properties/pass_properties.py 40 41 42 43 44 45 46 class Description ( Property ): \"\"\" The DESCRIPTION property provides a more complete description of the calendar component than that provided by the \"SUMMARY\" property. \"\"\" pass","title":"Description"},{"location":"code/properties/#ical_library.ical_properties.Due","text":"Bases: _DTBoth This DUE property defines the date and time that a to-do is expected to be completed.. Source code in ical_library/ical_properties/dt.py 67 68 69 70 class Due ( _DTBoth ): \"\"\"This DUE property defines the date and time that a to-do is expected to be completed..\"\"\" pass","title":"Due"},{"location":"code/properties/#ical_library.ical_properties.EXDate","text":"Bases: _ExOrRDate The EXDATE property defines the list of DATE-TIME exceptions for recurring events, to-dos, journal entries, or time zone definitions. Source code in ical_library/ical_properties/periods.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class EXDate ( _ExOrRDate ): \"\"\" The EXDATE property defines the list of DATE-TIME exceptions for recurring events, to-dos, journal entries, or time zone definitions. \"\"\" @property def kind ( self ) -> Optional [ Literal [ \"DATE-TIME\" , \"DATE\" ]]: \"\"\"The kind of the values. It is either DATE-TIME or DATE. The default is DATE-TIME.\"\"\" return self . property_parameters . get ( \"VALUE\" , \"DATE-TIME\" ) @property def excluded_date_times ( self ) -> Union [ List [ DateTime ], List [ Date ]]: \"\"\"A list of all excluded Dates or DateTimes. The type will be according to kind reported by `self.kind()`.\"\"\" if self . kind == \"DATE-TIME\" : return self . _parse_datetime_values () elif self . kind == \"DATE\" : return self . _parse_date_values () else : raise ValueError ( f \" { self . kind =} should be one in ['DATE-TIME', 'DATE'].\" )","title":"EXDate"},{"location":"code/properties/#ical_library.ical_properties.EXDate.excluded_date_times","text":"A list of all excluded Dates or DateTimes. The type will be according to kind reported by self.kind() .","title":"excluded_date_times"},{"location":"code/properties/#ical_library.ical_properties.EXDate.kind","text":"The kind of the values. It is either DATE-TIME or DATE. The default is DATE-TIME.","title":"kind"},{"location":"code/properties/#ical_library.ical_properties.FreeBusyProperty","text":"Bases: _PeriodFunctionality The FREEBUSY property defines one or more free or busy time intervals. Note: This class is called FreeBusyProperty to not be confused with the VFreeBusy component. Source code in ical_library/ical_properties/periods.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class FreeBusyProperty ( _PeriodFunctionality ): \"\"\" The FREEBUSY property defines one or more free or busy time intervals. Note: This class is called FreeBusyProperty to not be confused with the VFreeBusy component. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *FREEBUSYPROPERTY* but *FREEBUSY*.\"\"\" return \"FREEBUSY\" @property def free_busy_type ( self ) -> str : \"\"\" Specifies the free or busy time type. Values are usually in the following list but can be anything: FREE, BUSY, BUSY-UNAVAILABLE, BUSY-TENTATIVE \"\"\" return self . get_property_parameter_default ( \"FBTYPE\" , \"BUSY\" ) @property def periods ( self ) -> List [ Tuple [ DateTime , DateTime ]]: \"\"\" All the periods present in this property for which we define a free or busy time. :return: A list of tuples, where each tuple values consists of two DateTimes indicating the start and end respectively. \"\"\" return self . _parse_period_values ()","title":"FreeBusyProperty"},{"location":"code/properties/#ical_library.ical_properties.FreeBusyProperty.free_busy_type","text":"Specifies the free or busy time type. Values are usually in the following list but can be anything: FREE, BUSY, BUSY-UNAVAILABLE, BUSY-TENTATIVE","title":"free_busy_type"},{"location":"code/properties/#ical_library.ical_properties.FreeBusyProperty.periods","text":"All the periods present in this property for which we define a free or busy time. Returns: Type Description A list of tuples, where each tuple values consists of two DateTimes indicating the start and end respectively.","title":"periods"},{"location":"code/properties/#ical_library.ical_properties.FreeBusyProperty.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not FREEBUSYPROPERTY but FREEBUSY . Source code in ical_library/ical_properties/periods.py 121 122 123 124 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *FREEBUSYPROPERTY* but *FREEBUSY*.\"\"\" return \"FREEBUSY\"","title":"get_ical_name_of_class"},{"location":"code/properties/#ical_library.ical_properties.GEO","text":"Bases: Property The GEO property specifies information related to the global position for the activity specified by a calendar component. Source code in ical_library/ical_properties/geo.py 6 7 8 9 10 11 12 13 14 15 16 class GEO ( Property ): \"\"\" The GEO property specifies information related to the global position for the activity specified by a calendar component. \"\"\" @property def geo_value ( self ) -> Tuple [ float , float ]: \"\"\"Return the value as two floats representing the latitude and longitude.\"\"\" latitude , longitude = self . value . split ( \";\" ) return float ( latitude ), float ( longitude )","title":"GEO"},{"location":"code/properties/#ical_library.ical_properties.GEO.geo_value","text":"Return the value as two floats representing the latitude and longitude.","title":"geo_value"},{"location":"code/properties/#ical_library.ical_properties.ICALDuration","text":"Bases: Property The DURATION property specifies a positive duration of time. Source code in ical_library/ical_properties/ical_duration.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ICALDuration ( Property ): \"\"\"The DURATION property specifies a positive duration of time.\"\"\" @property def duration ( self ) -> pendulum . Duration : \"\"\"Return the value as a parsed pendulum.Duration. Example value: PT1H0M0S.\"\"\" parsed_value : pendulum . Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , pendulum . Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *ICALDURATION* but *DURATION*.\"\"\" return \"DURATION\"","title":"ICALDuration"},{"location":"code/properties/#ical_library.ical_properties.ICALDuration.duration","text":"Return the value as a parsed pendulum.Duration. Example value: PT1H0M0S.","title":"duration"},{"location":"code/properties/#ical_library.ical_properties.ICALDuration.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not ICALDURATION but DURATION . Source code in ical_library/ical_properties/ical_duration.py 17 18 19 20 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *ICALDURATION* but *DURATION*.\"\"\" return \"DURATION\"","title":"get_ical_name_of_class"},{"location":"code/properties/#ical_library.ical_properties.LastModified","text":"Bases: _DTSingular The LAST-MODIFIED property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. Source code in ical_library/ical_properties/dt.py 123 124 125 126 127 128 129 130 131 132 class LastModified ( _DTSingular ): \"\"\" The LAST-MODIFIED property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"LAST-MODIFIED\"","title":"LastModified"},{"location":"code/properties/#ical_library.ical_properties.LastModified.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not LASTMODIFIED but LAST-MODIFIED . Source code in ical_library/ical_properties/dt.py 129 130 131 132 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"LAST-MODIFIED\"","title":"get_ical_name_of_class"},{"location":"code/properties/#ical_library.ical_properties.Location","text":"Bases: Property The LOCATION property defines the intended venue for the activity defined by a calendar component. Source code in ical_library/ical_properties/pass_properties.py 49 50 51 52 class Location ( Property ): \"\"\"The LOCATION property defines the intended venue for the activity defined by a calendar component.\"\"\" pass","title":"Location"},{"location":"code/properties/#ical_library.ical_properties.Method","text":"Bases: Property The METHOD property defines the iCalendar object method associated with the calendar object. Source code in ical_library/ical_properties/pass_properties.py 28 29 30 31 class Method ( Property ): \"\"\"The METHOD property defines the iCalendar object method associated with the calendar object.\"\"\" pass","title":"Method"},{"location":"code/properties/#ical_library.ical_properties.Organizer","text":"Bases: _CalAddress The ORGANIZER property defines the organizer for a calendar component. Source code in ical_library/ical_properties/cal_address.py 46 47 48 49 class Organizer ( _CalAddress ): \"\"\"The ORGANIZER property defines the organizer for a calendar component.\"\"\" pass","title":"Organizer"},{"location":"code/properties/#ical_library.ical_properties.PercentComplete","text":"Bases: _IntProperty The PERCENT-COMPLETE property is used by an assignee or delegatee of a to-do to convey the percent completion of a to-do to the \"Organizer\". Source code in ical_library/ical_properties/ints.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class PercentComplete ( _IntProperty ): \"\"\" The PERCENT-COMPLETE property is used by an assignee or delegatee of a to-do to convey the percent completion of a to-do to the \"Organizer\". \"\"\" @property def percentage ( self ) -> int : return self . int_value @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *PERCENTCOMPLETE* but *PERCENT-COMPLETE*.\"\"\" return \"PERCENT-COMPLETE\"","title":"PercentComplete"},{"location":"code/properties/#ical_library.ical_properties.PercentComplete.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not PERCENTCOMPLETE but PERCENT-COMPLETE . Source code in ical_library/ical_properties/ints.py 43 44 45 46 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *PERCENTCOMPLETE* but *PERCENT-COMPLETE*.\"\"\" return \"PERCENT-COMPLETE\"","title":"get_ical_name_of_class"},{"location":"code/properties/#ical_library.ical_properties.Priority","text":"Bases: _IntProperty The PRIORITY property represents the relative priority for a calendar component. Source code in ical_library/ical_properties/ints.py 13 14 15 16 class Priority ( _IntProperty ): \"\"\"The PRIORITY property represents the relative priority for a calendar component.\"\"\" pass","title":"Priority"},{"location":"code/properties/#ical_library.ical_properties.ProdID","text":"Bases: Property The PRODID property specifies the identifier for the product that created the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 4 5 6 7 class ProdID ( Property ): \"\"\"The PRODID property specifies the identifier for the product that created the iCalendar object.\"\"\" pass","title":"ProdID"},{"location":"code/properties/#ical_library.ical_properties.RDate","text":"Bases: _ExOrRDate The RDATE property defines the list of DATE-TIME values for recurring events, to-dos, journal entries, or time zone definitions. Source code in ical_library/ical_properties/periods.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class RDate ( _ExOrRDate ): \"\"\" The RDATE property defines the list of DATE-TIME values for recurring events, to-dos, journal entries, or time zone definitions. \"\"\" @property def kind ( self ) -> Optional [ Literal [ \"DATE-TIME\" , \"DATE\" , \"PERIOD\" ]]: \"\"\"The kind of the values. It is either DATE-TIME, DATE or PERIOD. The default is DATE-TIME.\"\"\" return self . property_parameters . get ( \"VALUE\" , \"DATE-TIME\" ) @property def all_values ( self ) -> Union [ List [ DateTime ], List [ Date ], List [ Tuple [ DateTime , DateTime ]]]: \"\"\" A list of all recurring Dates, DateTimes or Periods. The periods are defined by tuples containing two datetimes representing the start and stop respectively. The returned types in the list will be according to the kind reported by `self.kind()`. \"\"\" if self . kind == \"DATE-TIME\" : return self . _parse_datetime_values () elif self . kind == \"DATE\" : return self . _parse_date_values () elif self . kind == \"PERIOD\" : return self . _parse_period_values () else : raise ValueError ( f \" { self . kind =} should be one in ['DATE-TIME', 'DATE', 'PERIOD'].\" ) def compute_max_end_date ( self , component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" max_value : Optional [ DateTime ] = None for value in self . all_values : if isinstance ( value , Date ): # This covers both Date and DateTime dt : DateTime = dt_utils . convert_time_object_to_datetime ( value ) dt : DateTime = dt + component_duration # type: ignore # Pendulum at fault here. dt = dt_utils . convert_time_object_to_aware_datetime ( dt ) if max_value is None or dt > max_value : max_value = dt elif isinstance ( value , tuple ) and len ( value ) == 2 : dt : DateTime = dt_utils . convert_time_object_to_aware_datetime ( value [ 1 ]) if max_value is None or dt > max_value : max_value = dt else : raise ValueError ( f \"Unexpected value encountered: { value } .\" ) return max_value or DateTime . max","title":"RDate"},{"location":"code/properties/#ical_library.ical_properties.RDate.all_values","text":"A list of all recurring Dates, DateTimes or Periods. The periods are defined by tuples containing two datetimes representing the start and stop respectively. The returned types in the list will be according to the kind reported by self.kind() .","title":"all_values"},{"location":"code/properties/#ical_library.ical_properties.RDate.kind","text":"The kind of the values. It is either DATE-TIME, DATE or PERIOD. The default is DATE-TIME.","title":"kind"},{"location":"code/properties/#ical_library.ical_properties.RDate.compute_max_end_date","text":"To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). Parameters: Name Type Description Default component_duration Duration The duration of the component which has the recurring properties. required Returns: Type Description DateTime An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date Source code in ical_library/ical_properties/periods.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def compute_max_end_date ( self , component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" max_value : Optional [ DateTime ] = None for value in self . all_values : if isinstance ( value , Date ): # This covers both Date and DateTime dt : DateTime = dt_utils . convert_time_object_to_datetime ( value ) dt : DateTime = dt + component_duration # type: ignore # Pendulum at fault here. dt = dt_utils . convert_time_object_to_aware_datetime ( dt ) if max_value is None or dt > max_value : max_value = dt elif isinstance ( value , tuple ) and len ( value ) == 2 : dt : DateTime = dt_utils . convert_time_object_to_aware_datetime ( value [ 1 ]) if max_value is None or dt > max_value : max_value = dt else : raise ValueError ( f \"Unexpected value encountered: { value } .\" ) return max_value or DateTime . max","title":"compute_max_end_date"},{"location":"code/properties/#ical_library.ical_properties.RRule","text":"Bases: Property The RRULE property defines a rule or repeating pattern for recurring events, to-dos, journal entries, or time zone definitions. For more in depth restrictions and possibilities we refer you to the RTFC 5545 section 3.3.10. Recurrence Rule . Source code in ical_library/ical_properties/rrule.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class RRule ( Property ): \"\"\" The RRULE property defines a rule or repeating pattern for recurring events, to-dos, journal entries, or time zone definitions. For more in depth restrictions and possibilities we refer you to the `RTFC 5545` section `3.3.10. Recurrence Rule`. \"\"\" @property @instance_lru_cache () def value_as_dict ( self ) -> Dict [ str , str ]: \"\"\" Parse all recurrence rule parts as a dictionary, so it can be used as an easy lookup. :return: A dict mapping of str to str containing all recurrence rule parts. \"\"\" all_values = [ tuple ( key_and_value . split ( \"=\" )) for key_and_value in self . _value . split ( \";\" )] return { key : value for key , value in all_values } @property def freq ( self ) -> str : \"\"\" The FREQUENCY rule identifies the type of recurrence rule. Possible values are: SECONDLY, MINUTELY, HOURLY, DAILY, WEEKLY, MONTHLY and YEARLY. This is the only required field. :return: The frequency as a string. \"\"\" return self . value_as_dict [ \"FREQ\" ] @property def freq_dateutil ( self ) -> int : \"\"\" Return the frequency in the format dateutil expects which is a map of the string to an integer. :return: An integer in the range of 0 to 6. \"\"\" return getattr ( base_for_time_periods , self . freq ) @property def until ( self ) -> Optional [ Union [ Date , DateTime ]]: \"\"\" The UNTIL rule defines a DATE or DATE-TIME value that bounds the recurrence rule in an inclusive manner. This is optional but may not occur together with COUNT. :return: None or a positive integer. \"\"\" if ( until_value := self . value_as_dict . get ( \"UNTIL\" , None )) is not None : return dt_utils . parse_date_or_datetime ( until_value ) return None @property def count ( self ) -> Optional [ int ]: \"\"\" The COUNT rule defines the number of occurrences at which to range-bound the recurrence. This is optional but may not occur together with UNTIL. :return: None or a positive integer. \"\"\" count_value = self . value_as_dict . get ( \"COUNT\" , None ) return int ( count_value ) if count_value else None @property def interval ( self ) -> int : \"\"\" The INTERVAL rule contains a positive integer representing at which intervals the recurrence rule repeats. :return: A positive integer. \"\"\" return int ( self . value_as_dict . get ( \"INTERVAL\" , 1 )) @staticmethod def convert_str_to_optional_integer_tuple ( value : Optional [ str ]) -> Optional [ Tuple [ int , ... ]]: \"\"\" Converts a string to a Tuple of integers. :return: None or a Tuple of integers if the value exists, otherwise None. \"\"\" if not value : return None return tuple ( int ( item ) for item in value . split ( \",\" )) @property def by_second ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYSECOND rule part specifies a COMMA-separated list of seconds within a minute. :return: None or a list of integers in the range of 0 to 60. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYSECOND\" )) @property def by_minute ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMINUTE rule part specifies a COMMA-separated list of minutes within an hour. :return: None or a list of integers in the range of 0 to 59. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMINUTE\" )) @property def by_hour ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYHOUR rule part specifies a COMMA-separated list of hours of the day. :return: None or a list of integers in the range of 0 to 23. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYHOUR\" )) def by_day ( self ) -> Optional [ List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]]]: \"\"\" The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU :return None or a list of tuples of two values. The first value represents possible specified nth occurrence or None. The second value the day of the week as a SU, MO, TU, WE, TH, FR or SA. \"\"\" value = self . value_as_dict . get ( \"BYDAY\" ) if not value : return None list_of_days : List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]] = [] for a_day in value . split ( \",\" ): a_day = a_day . strip () nth_occurence : Optional [ int ] = int ( a_day [: - 2 ]) if len ( a_day ) > 2 else None day_of_week : str = a_day [ - 2 :] if day_of_week not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError list_of_days . append (( nth_occurence , day_of_week )) # type: ignore return list_of_days @property def by_day_dateutil ( self ) -> Optional [ Tuple [ weekday , ... ]]: \"\"\" Return the by_day in the format dateutil expects which is a tuple of weekday instance. :return: None or a tuple of weekday instances which is a type native to dateutil. \"\"\" day_list : List [ weekday ] = [] by_day = self . by_day () if by_day is None : return None for optional_nth_occurrence , weekday_str in by_day : try : if optional_nth_occurrence is not None : day_list . append ( getattr ( base_for_time_periods , weekday_str )( optional_nth_occurrence )) else : day_list . append ( getattr ( base_for_time_periods , weekday_str )) except Exception as exc : raise ValueError ( f \" { optional_nth_occurrence =} , { weekday_str =} \" ) from exc return tuple ( day_list ) @property def by_month_day ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMONTHDAY rule part specifies a COMMA-separated list of days of the month. For example: -10 represents the tenth to the last day of the month. :return: None or a tuple of integers in the range of 1 to 31 or -31 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMONTHDAY\" )) @property def by_year_day ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYYEARDAY rule part specifies a COMMA-separated list of days of the year. For example: -1 represents the last day of the year (December 31st). :return: None or a tuple of integers in the range of 1 to 366 or -366 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYYEARDAY\" )) @property def by_week_no ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYWEEKNO rule part specifies a COMMA-separated list of ordinals specifying weeks of the year. For example: 3 represents the third week of the year. :return: None or an integer in the range of 1 to 53 or -53 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYWEEKNO\" )) @property def by_month ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMONTH rule part specifies a COMMA-separated list of months of the year. :return: None or a list of integers in the range of 1 to 12. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMONTH\" )) @property def by_set_pos ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYSETPOS rule part specifies a COMMA-separated list of values that corresponds to the nth occurrence within the set of recurrence instances specified by the rule. BYSETPOS operates on a set of recurrence instances in one interval of the recurrence rule. For example, in a WEEKLY rule, the interval would be one week A set of recurrence instances starts at the beginning of the interval defined by the FREQ rule part. :return: None or a list of integers in the range of 1 to 366 or -366 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYSETPOS\" )) @property def wkst ( self ) -> Optional [ str ]: \"\"\" The WKST rule part specifies the day on which the workweek starts. :return: A string that is the value of MO, TU, WE, TH, FR, SA, or SU or None. \"\"\" day = self . value_as_dict . get ( \"WKST\" ) if not day : return None if day not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError ( f \" { day =} is not in the list of weekdays.\" ) return day @property def wkst_dateutil ( self ) -> Optional [ int ]: \"\"\" Return the wkst in the format dateutil expects which is an integer. 0 for MO, 1 for TU, 2 for WE, ... :return: An integer in the range of 0 to 6 or None. \"\"\" day = self . wkst return getattr ( base_for_time_periods , day ) if self . wkst is not None else None @property def by_easter ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" According to dateutil, this is an extension of the RFC specification.. I can't find it. If anyone can, please file an issue or a PR to add it here as a reference. The BYEASTER rule part specifies the offset from the Easter Sunday. :return: None or an integer in the range of 1 to 366 or -366 to -1 or None. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYEASTER\" )) def compute_max_end_date ( self , starting_datetime : Union [ Date , DateTime ], component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" if self . until : return dt_utils . convert_time_object_to_aware_datetime ( self . until ) + component_duration # type: ignore elif self . count : if self . count < 1000 : max_datetime = DateTime . max if isinstance ( starting_datetime , DateTime ) else Date ( 9999 , 12 , 31 ) * _ , last = self . sequence_iterator ( starting_datetime = starting_datetime , max_datetime = max_datetime ) return dt_utils . convert_time_object_to_aware_datetime ( last ) + component_duration # type: ignore return DateTime . max def sequence_iterator ( self , starting_datetime : Union [ Date , DateTime ], max_datetime : Union [ Date , DateTime ] ) -> Iterator [ DateTime ]: \"\"\" Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param max_datetime: The maximum datetime. If we reach this datetime, we stop the iteration.. :return: Yield all datetimes(except itself) in the sequence. \"\"\" if type ( starting_datetime ) != type ( max_datetime ): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of the same type.\" ) if isinstance ( starting_datetime , DateTime ): if ( starting_datetime . tz or max_datetime . tz ) and ( not starting_datetime . tz or not max_datetime . tz ): raise TypeError ( f \"The tz info should be consistent: { starting_datetime =} , { max_datetime =} .\" ) if not isinstance ( starting_datetime , ( Date , DateTime )) or not isinstance ( max_datetime , ( Date , DateTime )): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of Date or DateTime.\" ) if starting_datetime > max_datetime : raise ValueError ( f \"This should not be the case: { starting_datetime =} >= { max_datetime =} .\" ) if not ( is_datetime_format := isinstance ( starting_datetime , DateTime ) and isinstance ( max_datetime , DateTime )): starting_datetime = DateTime ( starting_datetime . year , starting_datetime . month , starting_datetime . day ) max_datetime = DateTime ( max_datetime . year , max_datetime . month , max_datetime . day ) starting_datetime = starting_datetime max_datetime = max_datetime starting_tz = starting_datetime . tz until = self . until if until : if not isinstance ( until , DateTime ): until = DateTime ( until . year , until . month , until . day ) until = until . replace ( tzinfo = None ) if starting_tz is None else until . in_timezone ( starting_tz ) keyword_arguments = { \"until\" : until , \"count\" : self . count , \"interval\" : self . interval , \"bysecond\" : self . by_second , \"byminute\" : self . by_minute , \"byhour\" : self . by_hour , \"byweekday\" : self . by_day_dateutil , \"bymonthday\" : self . by_month_day , \"byyearday\" : self . by_year_day , \"byweekno\" : self . by_week_no , \"bymonth\" : self . by_month , \"bysetpos\" : self . by_set_pos , \"wkst\" : self . wkst_dateutil , \"byeaster\" : self . by_easter , } no_none_keywords = { key : value for key , value in keyword_arguments . items () if value is not None } dt_iterator = rrule ( dtstart = starting_datetime , freq = self . freq_dateutil , ** no_none_keywords ) for dt in dt_iterator : if dt > max_datetime : break p_instance = pendulum . instance ( dt , tz = None ) yield p_instance if is_datetime_format else p_instance . date ()","title":"RRule"},{"location":"code/properties/#ical_library.ical_properties.RRule.by_day_dateutil","text":"Return the by_day in the format dateutil expects which is a tuple of weekday instance. Returns: Type Description None or a tuple of weekday instances which is a type native to dateutil.","title":"by_day_dateutil"},{"location":"code/properties/#ical_library.ical_properties.RRule.by_easter","text":"According to dateutil, this is an extension of the RFC specification.. I can't find it. If anyone can, please file an issue or a PR to add it here as a reference. The BYEASTER rule part specifies the offset from the Easter Sunday. Returns: Type Description None or an integer in the range of 1 to 366 or -366 to -1 or None.","title":"by_easter"},{"location":"code/properties/#ical_library.ical_properties.RRule.by_hour","text":"The BYHOUR rule part specifies a COMMA-separated list of hours of the day. Returns: Type Description None or a list of integers in the range of 0 to 23.","title":"by_hour"},{"location":"code/properties/#ical_library.ical_properties.RRule.by_minute","text":"The BYMINUTE rule part specifies a COMMA-separated list of minutes within an hour. Returns: Type Description None or a list of integers in the range of 0 to 59.","title":"by_minute"},{"location":"code/properties/#ical_library.ical_properties.RRule.by_month","text":"The BYMONTH rule part specifies a COMMA-separated list of months of the year. Returns: Type Description None or a list of integers in the range of 1 to 12.","title":"by_month"},{"location":"code/properties/#ical_library.ical_properties.RRule.by_month_day","text":"The BYMONTHDAY rule part specifies a COMMA-separated list of days of the month. For example: -10 represents the tenth to the last day of the month. Returns: Type Description None or a tuple of integers in the range of 1 to 31 or -31 to -1.","title":"by_month_day"},{"location":"code/properties/#ical_library.ical_properties.RRule.by_second","text":"The BYSECOND rule part specifies a COMMA-separated list of seconds within a minute. Returns: Type Description None or a list of integers in the range of 0 to 60.","title":"by_second"},{"location":"code/properties/#ical_library.ical_properties.RRule.by_set_pos","text":"The BYSETPOS rule part specifies a COMMA-separated list of values that corresponds to the nth occurrence within the set of recurrence instances specified by the rule. BYSETPOS operates on a set of recurrence instances in one interval of the recurrence rule. For example, in a WEEKLY rule, the interval would be one week A set of recurrence instances starts at the beginning of the interval defined by the FREQ rule part. Returns: Type Description None or a list of integers in the range of 1 to 366 or -366 to -1.","title":"by_set_pos"},{"location":"code/properties/#ical_library.ical_properties.RRule.by_week_no","text":"The BYWEEKNO rule part specifies a COMMA-separated list of ordinals specifying weeks of the year. For example: 3 represents the third week of the year. Returns: Type Description None or an integer in the range of 1 to 53 or -53 to -1.","title":"by_week_no"},{"location":"code/properties/#ical_library.ical_properties.RRule.by_year_day","text":"The BYYEARDAY rule part specifies a COMMA-separated list of days of the year. For example: -1 represents the last day of the year (December 31st). Returns: Type Description None or a tuple of integers in the range of 1 to 366 or -366 to -1.","title":"by_year_day"},{"location":"code/properties/#ical_library.ical_properties.RRule.count","text":"The COUNT rule defines the number of occurrences at which to range-bound the recurrence. This is optional but may not occur together with UNTIL. Returns: Type Description None or a positive integer.","title":"count"},{"location":"code/properties/#ical_library.ical_properties.RRule.freq","text":"The FREQUENCY rule identifies the type of recurrence rule. Possible values are: SECONDLY, MINUTELY, HOURLY, DAILY, WEEKLY, MONTHLY and YEARLY. This is the only required field. Returns: Type Description The frequency as a string.","title":"freq"},{"location":"code/properties/#ical_library.ical_properties.RRule.freq_dateutil","text":"Return the frequency in the format dateutil expects which is a map of the string to an integer. Returns: Type Description An integer in the range of 0 to 6.","title":"freq_dateutil"},{"location":"code/properties/#ical_library.ical_properties.RRule.interval","text":"The INTERVAL rule contains a positive integer representing at which intervals the recurrence rule repeats. Returns: Type Description A positive integer.","title":"interval"},{"location":"code/properties/#ical_library.ical_properties.RRule.until","text":"The UNTIL rule defines a DATE or DATE-TIME value that bounds the recurrence rule in an inclusive manner. This is optional but may not occur together with COUNT. Returns: Type Description None or a positive integer.","title":"until"},{"location":"code/properties/#ical_library.ical_properties.RRule.value_as_dict","text":"Parse all recurrence rule parts as a dictionary, so it can be used as an easy lookup. Returns: Type Description A dict mapping of str to str containing all recurrence rule parts.","title":"value_as_dict"},{"location":"code/properties/#ical_library.ical_properties.RRule.wkst","text":"The WKST rule part specifies the day on which the workweek starts. Returns: Type Description A string that is the value of MO, TU, WE, TH, FR, SA, or SU or None.","title":"wkst"},{"location":"code/properties/#ical_library.ical_properties.RRule.wkst_dateutil","text":"Return the wkst in the format dateutil expects which is an integer. 0 for MO, 1 for TU, 2 for WE, ... Returns: Type Description An integer in the range of 0 to 6 or None.","title":"wkst_dateutil"},{"location":"code/properties/#ical_library.ical_properties.RRule.by_day","text":"The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU Source code in ical_library/ical_properties/rrule.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def by_day ( self ) -> Optional [ List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]]]: \"\"\" The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU :return None or a list of tuples of two values. The first value represents possible specified nth occurrence or None. The second value the day of the week as a SU, MO, TU, WE, TH, FR or SA. \"\"\" value = self . value_as_dict . get ( \"BYDAY\" ) if not value : return None list_of_days : List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]] = [] for a_day in value . split ( \",\" ): a_day = a_day . strip () nth_occurence : Optional [ int ] = int ( a_day [: - 2 ]) if len ( a_day ) > 2 else None day_of_week : str = a_day [ - 2 :] if day_of_week not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError list_of_days . append (( nth_occurence , day_of_week )) # type: ignore return list_of_days","title":"by_day"},{"location":"code/properties/#ical_library.ical_properties.RRule.compute_max_end_date","text":"To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). Parameters: Name Type Description Default starting_datetime Union [ Date , DateTime ] The starting datetime from which we start computing the next occurrences. required component_duration Duration The duration of the component which has the recurring properties. required Returns: Type Description DateTime An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date Source code in ical_library/ical_properties/rrule.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def compute_max_end_date ( self , starting_datetime : Union [ Date , DateTime ], component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" if self . until : return dt_utils . convert_time_object_to_aware_datetime ( self . until ) + component_duration # type: ignore elif self . count : if self . count < 1000 : max_datetime = DateTime . max if isinstance ( starting_datetime , DateTime ) else Date ( 9999 , 12 , 31 ) * _ , last = self . sequence_iterator ( starting_datetime = starting_datetime , max_datetime = max_datetime ) return dt_utils . convert_time_object_to_aware_datetime ( last ) + component_duration # type: ignore return DateTime . max","title":"compute_max_end_date"},{"location":"code/properties/#ical_library.ical_properties.RRule.convert_str_to_optional_integer_tuple","text":"Converts a string to a Tuple of integers. Returns: Type Description Optional [ Tuple [ int , ...]] None or a Tuple of integers if the value exists, otherwise None. Source code in ical_library/ical_properties/rrule.py 78 79 80 81 82 83 84 85 86 @staticmethod def convert_str_to_optional_integer_tuple ( value : Optional [ str ]) -> Optional [ Tuple [ int , ... ]]: \"\"\" Converts a string to a Tuple of integers. :return: None or a Tuple of integers if the value exists, otherwise None. \"\"\" if not value : return None return tuple ( int ( item ) for item in value . split ( \",\" ))","title":"convert_str_to_optional_integer_tuple"},{"location":"code/properties/#ical_library.ical_properties.RRule.sequence_iterator","text":"Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. Parameters: Name Type Description Default starting_datetime Union [ Date , DateTime ] The starting datetime from which we start computing the next occurrences. required max_datetime Union [ Date , DateTime ] The maximum datetime. If we reach this datetime, we stop the iteration.. required Returns: Type Description Iterator [ DateTime ] Yield all datetimes(except itself) in the sequence. Source code in ical_library/ical_properties/rrule.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def sequence_iterator ( self , starting_datetime : Union [ Date , DateTime ], max_datetime : Union [ Date , DateTime ] ) -> Iterator [ DateTime ]: \"\"\" Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param max_datetime: The maximum datetime. If we reach this datetime, we stop the iteration.. :return: Yield all datetimes(except itself) in the sequence. \"\"\" if type ( starting_datetime ) != type ( max_datetime ): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of the same type.\" ) if isinstance ( starting_datetime , DateTime ): if ( starting_datetime . tz or max_datetime . tz ) and ( not starting_datetime . tz or not max_datetime . tz ): raise TypeError ( f \"The tz info should be consistent: { starting_datetime =} , { max_datetime =} .\" ) if not isinstance ( starting_datetime , ( Date , DateTime )) or not isinstance ( max_datetime , ( Date , DateTime )): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of Date or DateTime.\" ) if starting_datetime > max_datetime : raise ValueError ( f \"This should not be the case: { starting_datetime =} >= { max_datetime =} .\" ) if not ( is_datetime_format := isinstance ( starting_datetime , DateTime ) and isinstance ( max_datetime , DateTime )): starting_datetime = DateTime ( starting_datetime . year , starting_datetime . month , starting_datetime . day ) max_datetime = DateTime ( max_datetime . year , max_datetime . month , max_datetime . day ) starting_datetime = starting_datetime max_datetime = max_datetime starting_tz = starting_datetime . tz until = self . until if until : if not isinstance ( until , DateTime ): until = DateTime ( until . year , until . month , until . day ) until = until . replace ( tzinfo = None ) if starting_tz is None else until . in_timezone ( starting_tz ) keyword_arguments = { \"until\" : until , \"count\" : self . count , \"interval\" : self . interval , \"bysecond\" : self . by_second , \"byminute\" : self . by_minute , \"byhour\" : self . by_hour , \"byweekday\" : self . by_day_dateutil , \"bymonthday\" : self . by_month_day , \"byyearday\" : self . by_year_day , \"byweekno\" : self . by_week_no , \"bymonth\" : self . by_month , \"bysetpos\" : self . by_set_pos , \"wkst\" : self . wkst_dateutil , \"byeaster\" : self . by_easter , } no_none_keywords = { key : value for key , value in keyword_arguments . items () if value is not None } dt_iterator = rrule ( dtstart = starting_datetime , freq = self . freq_dateutil , ** no_none_keywords ) for dt in dt_iterator : if dt > max_datetime : break p_instance = pendulum . instance ( dt , tz = None ) yield p_instance if is_datetime_format else p_instance . date ()","title":"sequence_iterator"},{"location":"code/properties/#ical_library.ical_properties.RecurrenceID","text":"Bases: _DTBoth The RECURRENCE-ID property is defined as followed. This property is used in conjunction with the \"UID\" and \"SEQUENCE\" properties to identify a specific instance of a recurring \"VEVENT\", \"VTODO\", or \"VJOURNAL\" calendar component. The property value is the original value of the \"DTSTART\" property of the recurrence instance. Value Type: The default value type is DATE-TIME. The value type can be set to a DATE value type. This property MUST have the same value type as the \"DTSTART\" property contained within the recurring component. Furthermore, this property MUST be specified as a date with local time if and only if the \"DTSTART\" property contained within the recurring component is specified as a date with local time. Source code in ical_library/ical_properties/dt.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class RecurrenceID ( _DTBoth ): \"\"\" The RECURRENCE-ID property is defined as followed. This property is used in conjunction with the \"UID\" and \"SEQUENCE\" properties to identify a specific instance of a recurring \"VEVENT\", \"VTODO\", or \"VJOURNAL\" calendar component. The property value is the original value of the \"DTSTART\" property of the recurrence instance. Value Type: The default value type is DATE-TIME. The value type can be set to a DATE value type. This property MUST have the same value type as the \"DTSTART\" property contained within the recurring component. Furthermore, this property MUST be specified as a date with local time if and only if the \"DTSTART\" property contained within the recurring component is specified as a date with local time. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"RECURRENCE-ID\"","title":"RecurrenceID"},{"location":"code/properties/#ical_library.ical_properties.RecurrenceID.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not LASTMODIFIED but LAST-MODIFIED . Source code in ical_library/ical_properties/dt.py 86 87 88 89 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"RECURRENCE-ID\"","title":"get_ical_name_of_class"},{"location":"code/properties/#ical_library.ical_properties.RelatedTo","text":"Bases: Property The RELATED-TO property is used to represent a relationship or reference between one calendar component and another. Source code in ical_library/ical_properties/pass_properties.py 106 107 108 109 110 111 112 113 114 class RelatedTo ( Property ): \"\"\" The RELATED-TO property is used to represent a relationship or reference between one calendar component and another. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *RELATEDTO* but *RELATED-TO*.\"\"\" return \"RELATED-TO\"","title":"RelatedTo"},{"location":"code/properties/#ical_library.ical_properties.RelatedTo.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not RELATEDTO but RELATED-TO . Source code in ical_library/ical_properties/pass_properties.py 111 112 113 114 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *RELATEDTO* but *RELATED-TO*.\"\"\" return \"RELATED-TO\"","title":"get_ical_name_of_class"},{"location":"code/properties/#ical_library.ical_properties.Repeat","text":"Bases: _IntProperty The REPEAT property defines the number of times the alarm should be repeated, after the initial trigger. Source code in ical_library/ical_properties/ints.py 27 28 29 30 class Repeat ( _IntProperty ): \"\"\"The REPEAT property defines the number of times the alarm should be repeated, after the initial trigger.\"\"\" pass","title":"Repeat"},{"location":"code/properties/#ical_library.ical_properties.RequestStatus","text":"Bases: Property The REQUEST-STATUS property defines the status code returned for a scheduling request. Source code in ical_library/ical_properties/pass_properties.py 97 98 99 100 101 102 103 class RequestStatus ( Property ): \"\"\"The REQUEST-STATUS property defines the status code returned for a scheduling request.\"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *REQUESTSTATUS* but *REQUEST-STATUS*.\"\"\" return \"REQUEST-STATUS\"","title":"RequestStatus"},{"location":"code/properties/#ical_library.ical_properties.RequestStatus.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not REQUESTSTATUS but REQUEST-STATUS . Source code in ical_library/ical_properties/pass_properties.py 100 101 102 103 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *REQUESTSTATUS* but *REQUEST-STATUS*.\"\"\" return \"REQUEST-STATUS\"","title":"get_ical_name_of_class"},{"location":"code/properties/#ical_library.ical_properties.Resources","text":"Bases: Property The RESOURCES property defines the equipment or resources anticipated for an activity specified by a calendar component. Source code in ical_library/ical_properties/pass_properties.py 117 118 119 120 121 122 123 class Resources ( Property ): \"\"\" The RESOURCES property defines the equipment or resources anticipated for an activity specified by a calendar component. \"\"\" pass","title":"Resources"},{"location":"code/properties/#ical_library.ical_properties.Sequence","text":"Bases: _IntProperty The SEQUENCE property defines the revision sequence number of the calendar component within a sequence of revisions. Source code in ical_library/ical_properties/ints.py 19 20 21 22 23 24 class Sequence ( _IntProperty ): \"\"\" The SEQUENCE property defines the revision sequence number of the calendar component within a sequence of revisions. \"\"\" pass","title":"Sequence"},{"location":"code/properties/#ical_library.ical_properties.Status","text":"Bases: Property The STATUS property defines the overall status or confirmation for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 55 56 57 58 class Status ( Property ): \"\"\"The STATUS property defines the overall status or confirmation for the calendar component.\"\"\" pass","title":"Status"},{"location":"code/properties/#ical_library.ical_properties.Summary","text":"Bases: Property The SUMMARY property defines a short summary or subject for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 168 169 170 171 172 173 class Summary ( Property ): \"\"\" The SUMMARY property defines a short summary or subject for the calendar component. \"\"\" pass","title":"Summary"},{"location":"code/properties/#ical_library.ical_properties.TZID","text":"Bases: Property The TZID property specifies the text value that uniquely identifies the \"VTIMEZONE\" calendar component in the scope of an iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 150 151 152 153 154 155 156 class TZID ( Property ): \"\"\" The TZID property specifies the text value that uniquely identifies the \"VTIMEZONE\" calendar component in the scope of an iCalendar object. \"\"\" pass","title":"TZID"},{"location":"code/properties/#ical_library.ical_properties.TZName","text":"Bases: Property The TZNAME property specifies the customary designation for a time zone description. Source code in ical_library/ical_properties/pass_properties.py 144 145 146 147 class TZName ( Property ): \"\"\"The TZNAME property specifies the customary designation for a time zone description.\"\"\" pass","title":"TZName"},{"location":"code/properties/#ical_library.ical_properties.TZOffsetFrom","text":"Bases: _TZOffset The TZOFFSETFROM property specifies the offset that is in use prior to this time zone observance. Source code in ical_library/ical_properties/tz_offset.py 33 34 35 36 class TZOffsetFrom ( _TZOffset ): \"\"\"The TZOFFSETFROM property specifies the offset that is in use prior to this time zone observance.\"\"\" pass","title":"TZOffsetFrom"},{"location":"code/properties/#ical_library.ical_properties.TZOffsetTo","text":"Bases: _TZOffset The TZOFFSETTO property specifies the offset that is in use prior to this time zone observance. Source code in ical_library/ical_properties/tz_offset.py 27 28 29 30 class TZOffsetTo ( _TZOffset ): \"\"\"The TZOFFSETTO property specifies the offset that is in use prior to this time zone observance.\"\"\" pass","title":"TZOffsetTo"},{"location":"code/properties/#ical_library.ical_properties.TZURL","text":"Bases: Property The TZURL property provides a means for a \"VTIMEZONE\" component to point to a network location that can be used to retrieve an up- to-date version of itself. Source code in ical_library/ical_properties/pass_properties.py 159 160 161 162 163 164 165 class TZURL ( Property ): \"\"\" The TZURL property provides a means for a \"VTIMEZONE\" component to point to a network location that can be used to retrieve an up- to-date version of itself. \"\"\" pass","title":"TZURL"},{"location":"code/properties/#ical_library.ical_properties.TimeTransparency","text":"Bases: Property The TRANSP property defines whether an event is transparent to busy time searches. Source code in ical_library/ical_properties/pass_properties.py 61 62 63 64 65 66 67 class TimeTransparency ( Property ): \"\"\"The TRANSP property defines whether an event is transparent to busy time searches.\"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *TIMETRANSPARANCY* but *TRANSP*.\"\"\" return \"TRANSP\"","title":"TimeTransparency"},{"location":"code/properties/#ical_library.ical_properties.TimeTransparency.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not TIMETRANSPARANCY but TRANSP . Source code in ical_library/ical_properties/pass_properties.py 64 65 66 67 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *TIMETRANSPARANCY* but *TRANSP*.\"\"\" return \"TRANSP\"","title":"get_ical_name_of_class"},{"location":"code/properties/#ical_library.ical_properties.Trigger","text":"Bases: Property The TRIGGER property specifies when an alarm will trigger. Source code in ical_library/ical_properties/trigger.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Trigger ( Property ): \"\"\"The TRIGGER property specifies when an alarm will trigger.\"\"\" @property def kind ( self ) -> Literal [ \"DATE-TIME\" , \"DURATION\" ]: \"\"\"Return the type of the property value.\"\"\" kind_of_value = self . get_property_parameter ( \"VALUE\" ) return \"DATE-TIME\" if kind_of_value and kind_of_value == \"DATE-TIME\" else \"DURATION\" # noqa def parse_value ( self ) -> Union [ Duration , DateTime ]: \"\"\"Parse the value of this property based on the VALUE property parameter.\"\"\" if self . kind == \"DURATION\" : parsed_value : Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value else : parsed_value : DateTime = pendulum . parse ( self . value ) if not isinstance ( parsed_value , DateTime ): raise TypeError ( f \"Invalid value passed for DateTime: { self . value =} \" ) return parsed_value def trigger_relation ( self ) -> Literal [ \"START\" , \"END\" ]: \"\"\"Get the trigger relation, whether the duration should be relative to the start or the end of a component.\"\"\" return \"START\" if self . get_property_parameter_default ( \"RELATED\" , \"START\" ) == \"START\" else \"END\" # noqa","title":"Trigger"},{"location":"code/properties/#ical_library.ical_properties.Trigger.kind","text":"Return the type of the property value.","title":"kind"},{"location":"code/properties/#ical_library.ical_properties.Trigger.parse_value","text":"Parse the value of this property based on the VALUE property parameter. Source code in ical_library/ical_properties/trigger.py 18 19 20 21 22 23 24 25 26 27 28 29 def parse_value ( self ) -> Union [ Duration , DateTime ]: \"\"\"Parse the value of this property based on the VALUE property parameter.\"\"\" if self . kind == \"DURATION\" : parsed_value : Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value else : parsed_value : DateTime = pendulum . parse ( self . value ) if not isinstance ( parsed_value , DateTime ): raise TypeError ( f \"Invalid value passed for DateTime: { self . value =} \" ) return parsed_value","title":"parse_value"},{"location":"code/properties/#ical_library.ical_properties.Trigger.trigger_relation","text":"Get the trigger relation, whether the duration should be relative to the start or the end of a component. Source code in ical_library/ical_properties/trigger.py 31 32 33 def trigger_relation ( self ) -> Literal [ \"START\" , \"END\" ]: \"\"\"Get the trigger relation, whether the duration should be relative to the start or the end of a component.\"\"\" return \"START\" if self . get_property_parameter_default ( \"RELATED\" , \"START\" ) == \"START\" else \"END\" # noqa","title":"trigger_relation"},{"location":"code/properties/#ical_library.ical_properties.UID","text":"Bases: Property The UID property defines the persistent, globally unique identifier for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 132 133 134 135 class UID ( Property ): \"\"\"The UID property defines the persistent, globally unique identifier for the calendar component.\"\"\" pass","title":"UID"},{"location":"code/properties/#ical_library.ical_properties.URL","text":"Bases: Property The URL property defines a Uniform Resource Locator (URL) associated with the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 70 71 72 73 class URL ( Property ): \"\"\"The URL property defines a Uniform Resource Locator (URL) associated with the iCalendar object.\"\"\" pass","title":"URL"},{"location":"code/properties/#ical_library.ical_properties.Version","text":"Bases: Property The VERSION property specifies the identifier corresponding to the highest version number or the minimum and maximum range of the iCalendar specification that is required in order to interpret the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 10 11 12 13 14 15 16 class Version ( Property ): \"\"\" The VERSION property specifies the identifier corresponding to the highest version number or the minimum and maximum range of the iCalendar specification that is required in order to interpret the iCalendar object. \"\"\" pass","title":"Version"},{"location":"code/timeline/","text":"Documentation for the Timeline From the VCalendar it is very easy to create a Timeline object. This will show you all the components you have in a specific time frame. Timeline This class is a wrapper to make it easy to see what the order of each component based on the start date. Inside this class there are multiple methods to iterate over all the components present. However, one should note that often the recurrence properties for components specify only a lower bound and will therefore proceed to infinity. To prevent us having an infinite list of items to iterate on, we define upper and lower bounds. You should set these upper bounds to the absolute minimum start date and absolute maximum end date that you would ever need. So if you need to do 10 different queries, this start and end date should range all of these, so it doesn't need to compute the list of components in the range over and over again. The functions themselves(e.g. :function: self.includes and :function: self.intersects ) help you to limit the exact range you want to return components for. Parameters: Name Type Description Default v_calendar VCalendar The VCalendar object we are iterating over. required start_date Optional [ DateTime ] The minimum ending date of each event that is returned inside this timeline. None end_date Optional [ DateTime ] The maximum starting date of each event that is return inside this timeline. None Source code in ical_library/timeline.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class Timeline : \"\"\" This class is a wrapper to make it easy to see what the order of each component based on the start date. Inside this class there are multiple methods to iterate over all the components present. However, one should note that often the recurrence properties for components specify only a lower bound and will therefore proceed to infinity. To prevent us having an infinite list of items to iterate on, we define upper and lower bounds. You should set these upper bounds to the absolute minimum start date and absolute maximum end date that you would ever need. So if you need to do 10 different queries, this start and end date should range all of these, so it doesn't need to compute the list of components in the range over and over again. The functions themselves(e.g. :function:`self.includes` and :function:`self.intersects`) help you to limit the exact range you want to return components for. :param v_calendar: The VCalendar object we are iterating over. :param start_date: The minimum ending date of each event that is returned inside this timeline. :param end_date: The maximum starting date of each event that is return inside this timeline. \"\"\" def __init__ ( self , v_calendar : VCalendar , start_date : Optional [ DateTime ] = None , end_date : Optional [ DateTime ] = None ): self . v_calendar : VCalendar = v_calendar self . _start_date : DateTime = start_date or DateTime ( 1970 , 1 , 1 ) self . _end_date : DateTime = end_date or DateTime ( 2100 , 1 , 1 ) def __repr__ ( self ) -> str : return f \"Timeline( { self . _start_date } , { self . _end_date } )\" @property def start_date ( self ) -> DateTime : \"\"\"Return the start date of the timeline. No event should end before this value.\"\"\" return self . _start_date @start_date . setter def start_date ( self , value ) -> None : \"\"\"Set the start date of the timeline.\"\"\" self . _start_date = value self . get_timespan . cache_clear () @property def end_date ( self ) -> DateTime : \"\"\"Return the end date of the timeline. No event should start before this value.\"\"\" return self . _end_date @end_date . setter def end_date ( self , value ) -> None : \"\"\"Set the end date of the timeline.\"\"\" self . _end_date = value self . get_timespan . cache_clear () @instance_lru_cache () def get_timespan ( self ) -> Timespan : \"\"\"Return the start and end date as a Timespan.\"\"\" return Timespan ( self . start_date , self . end_date ) @staticmethod def __get_items_to_exclude_from_recurrence ( all_components : List [ Component ], ) -> Dict [ str , Union [ List [ Date ], List [ DateTime ]]]: \"\"\" Deduplicate recurring components. Sometimes it happens that recurring events are changed and this will cause them to both be present as a standard component and in the recurrence. :param all_components: The list of all component children of the VCalendar instance. :return: A deduplicated list of components. \"\"\" start_date_to_timespan_dict : Dict [ str , Union [ List [ Date ], List [ DateTime ]]] = defaultdict ( list ) for component in all_components : if isinstance ( component , AbstractComponentWithRecurringProperties ) and component . recurrence_id is not None : start_date_to_timespan_dict [ component . uid . value ] . append ( component . recurrence_id . datetime_or_date_value ) return start_date_to_timespan_dict def __explode_recurring_components ( self ) -> List [ TimespanWithParent ]: \"\"\" Get a de-duplicated list of all components with a start date, including the recurring components. This means that we add all child component of the :class:`VCalendar` (except for the :class:`VTimeZone` instances) to a list and then add all extra occurrences (as recurring components) according to the recurrence properties: :class:`RRule`, :class:`RDate` and :class:`EXDate`. :return: A de-duplicated list of all components, including the recurring occurrences of the components. \"\"\" list_of_timestamps_with_parents : List [ TimespanWithParent ] = [] all_children = self . v_calendar . children uid_to_datetime_to_exclude = self . __get_items_to_exclude_from_recurrence ( all_children ) for c in all_children : # Do some initial filtering. if isinstance ( c , AbstractComponentWithRecurringProperties ): if c . max_recurring_timespan . intersects ( self . get_timespan ()): values_to_exclude = uid_to_datetime_to_exclude [ c . uid . value ] # .get defaults to None. list_of_timestamps_with_parents . extend ( c . expand_component_in_range ( self . get_timespan (), values_to_exclude ) ) elif isinstance ( c , VFreeBusy ): if c . timespan . intersects ( self . get_timespan ()): list_of_timestamps_with_parents . append ( c . timespan ) else : # There is no way to extend iana-props or x-props for now. If you feel like implementing this, please # let me know and open a PR :). pass return list_of_timestamps_with_parents def iterate ( self ) -> Iterator [ Tuple [ TimespanWithParent , Component ]]: \"\"\" Iterate over the `self.__explode_recurring_components()` in chronological order. Implementation detail: Using a heap is faster than sorting if the number of events (n) is much bigger than the number of events we extract from the iterator (k). Complexity: O(n + k log n). \"\"\" heap : List [ TimespanWithParent ] = self . __explode_recurring_components () heapq . heapify ( heap ) while heap : popped : TimespanWithParent = heapq . heappop ( heap ) yield popped , popped . parent def includes ( self , start : DateTime , stop : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over every component that is in the specified timespan.\"\"\" query_timespan = Timespan ( start , stop ) for timespan , event in self . iterate (): if timespan . is_included_in ( query_timespan ): yield event def overlapping ( self , start : DateTime , stop : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over every component that has an intersection with the timespan.\"\"\" query_timespan = Timespan ( start , stop ) for timespan , event in self . iterate (): if timespan . intersects ( query_timespan ): yield event def start_after ( self , instant : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) on every component larger than instant in chronological order.\"\"\" for timespan , event in self . iterate (): if timespan . begin > instant : yield event def at ( self , instant : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over all component that are occurring during `instant`.\"\"\" for timespan , event in self . iterate (): if timespan . includes ( instant ): yield event end_date : DateTime property writable Return the end date of the timeline. No event should start before this value. start_date : DateTime property writable Return the start date of the timeline. No event should end before this value. __explode_recurring_components () Get a de-duplicated list of all components with a start date, including the recurring components. This means that we add all child component of the :class: VCalendar (except for the :class: VTimeZone instances) to a list and then add all extra occurrences (as recurring components) according to the recurrence properties: :class: RRule , :class: RDate and :class: EXDate . Returns: Type Description List [ TimespanWithParent ] A de-duplicated list of all components, including the recurring occurrences of the components. Source code in ical_library/timeline.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __explode_recurring_components ( self ) -> List [ TimespanWithParent ]: \"\"\" Get a de-duplicated list of all components with a start date, including the recurring components. This means that we add all child component of the :class:`VCalendar` (except for the :class:`VTimeZone` instances) to a list and then add all extra occurrences (as recurring components) according to the recurrence properties: :class:`RRule`, :class:`RDate` and :class:`EXDate`. :return: A de-duplicated list of all components, including the recurring occurrences of the components. \"\"\" list_of_timestamps_with_parents : List [ TimespanWithParent ] = [] all_children = self . v_calendar . children uid_to_datetime_to_exclude = self . __get_items_to_exclude_from_recurrence ( all_children ) for c in all_children : # Do some initial filtering. if isinstance ( c , AbstractComponentWithRecurringProperties ): if c . max_recurring_timespan . intersects ( self . get_timespan ()): values_to_exclude = uid_to_datetime_to_exclude [ c . uid . value ] # .get defaults to None. list_of_timestamps_with_parents . extend ( c . expand_component_in_range ( self . get_timespan (), values_to_exclude ) ) elif isinstance ( c , VFreeBusy ): if c . timespan . intersects ( self . get_timespan ()): list_of_timestamps_with_parents . append ( c . timespan ) else : # There is no way to extend iana-props or x-props for now. If you feel like implementing this, please # let me know and open a PR :). pass return list_of_timestamps_with_parents __get_items_to_exclude_from_recurrence ( all_components ) staticmethod Deduplicate recurring components. Sometimes it happens that recurring events are changed and this will cause them to both be present as a standard component and in the recurrence. Parameters: Name Type Description Default all_components List [ Component ] The list of all component children of the VCalendar instance. required Returns: Type Description Dict [ str , Union [ List [ Date ], List [ DateTime ]]] A deduplicated list of components. Source code in ical_library/timeline.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @staticmethod def __get_items_to_exclude_from_recurrence ( all_components : List [ Component ], ) -> Dict [ str , Union [ List [ Date ], List [ DateTime ]]]: \"\"\" Deduplicate recurring components. Sometimes it happens that recurring events are changed and this will cause them to both be present as a standard component and in the recurrence. :param all_components: The list of all component children of the VCalendar instance. :return: A deduplicated list of components. \"\"\" start_date_to_timespan_dict : Dict [ str , Union [ List [ Date ], List [ DateTime ]]] = defaultdict ( list ) for component in all_components : if isinstance ( component , AbstractComponentWithRecurringProperties ) and component . recurrence_id is not None : start_date_to_timespan_dict [ component . uid . value ] . append ( component . recurrence_id . datetime_or_date_value ) return start_date_to_timespan_dict at ( instant ) Iterate (in chronological order) over all component that are occurring during instant . Source code in ical_library/timeline.py 146 147 148 149 150 def at ( self , instant : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over all component that are occurring during `instant`.\"\"\" for timespan , event in self . iterate (): if timespan . includes ( instant ): yield event get_timespan () Return the start and end date as a Timespan. Source code in ical_library/timeline.py 64 65 66 67 @instance_lru_cache () def get_timespan ( self ) -> Timespan : \"\"\"Return the start and end date as a Timespan.\"\"\" return Timespan ( self . start_date , self . end_date ) includes ( start , stop ) Iterate (in chronological order) over every component that is in the specified timespan. Source code in ical_library/timeline.py 126 127 128 129 130 131 def includes ( self , start : DateTime , stop : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over every component that is in the specified timespan.\"\"\" query_timespan = Timespan ( start , stop ) for timespan , event in self . iterate (): if timespan . is_included_in ( query_timespan ): yield event iterate () Iterate over the self.__explode_recurring_components() in chronological order. Implementation detail: Using a heap is faster than sorting if the number of events (n) is much bigger than the number of events we extract from the iterator (k). Complexity: O(n + k log n). Source code in ical_library/timeline.py 113 114 115 116 117 118 119 120 121 122 123 124 def iterate ( self ) -> Iterator [ Tuple [ TimespanWithParent , Component ]]: \"\"\" Iterate over the `self.__explode_recurring_components()` in chronological order. Implementation detail: Using a heap is faster than sorting if the number of events (n) is much bigger than the number of events we extract from the iterator (k). Complexity: O(n + k log n). \"\"\" heap : List [ TimespanWithParent ] = self . __explode_recurring_components () heapq . heapify ( heap ) while heap : popped : TimespanWithParent = heapq . heappop ( heap ) yield popped , popped . parent overlapping ( start , stop ) Iterate (in chronological order) over every component that has an intersection with the timespan. Source code in ical_library/timeline.py 133 134 135 136 137 138 def overlapping ( self , start : DateTime , stop : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over every component that has an intersection with the timespan.\"\"\" query_timespan = Timespan ( start , stop ) for timespan , event in self . iterate (): if timespan . intersects ( query_timespan ): yield event start_after ( instant ) Iterate (in chronological order) on every component larger than instant in chronological order. Source code in ical_library/timeline.py 140 141 142 143 144 def start_after ( self , instant : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) on every component larger than instant in chronological order.\"\"\" for timespan , event in self . iterate (): if timespan . begin > instant : yield event","title":"Timeline"},{"location":"code/timeline/#documentation-for-the-timeline","text":"From the VCalendar it is very easy to create a Timeline object. This will show you all the components you have in a specific time frame.","title":"Documentation for the Timeline"},{"location":"code/timeline/#ical_library.timeline.Timeline","text":"This class is a wrapper to make it easy to see what the order of each component based on the start date. Inside this class there are multiple methods to iterate over all the components present. However, one should note that often the recurrence properties for components specify only a lower bound and will therefore proceed to infinity. To prevent us having an infinite list of items to iterate on, we define upper and lower bounds. You should set these upper bounds to the absolute minimum start date and absolute maximum end date that you would ever need. So if you need to do 10 different queries, this start and end date should range all of these, so it doesn't need to compute the list of components in the range over and over again. The functions themselves(e.g. :function: self.includes and :function: self.intersects ) help you to limit the exact range you want to return components for. Parameters: Name Type Description Default v_calendar VCalendar The VCalendar object we are iterating over. required start_date Optional [ DateTime ] The minimum ending date of each event that is returned inside this timeline. None end_date Optional [ DateTime ] The maximum starting date of each event that is return inside this timeline. None Source code in ical_library/timeline.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class Timeline : \"\"\" This class is a wrapper to make it easy to see what the order of each component based on the start date. Inside this class there are multiple methods to iterate over all the components present. However, one should note that often the recurrence properties for components specify only a lower bound and will therefore proceed to infinity. To prevent us having an infinite list of items to iterate on, we define upper and lower bounds. You should set these upper bounds to the absolute minimum start date and absolute maximum end date that you would ever need. So if you need to do 10 different queries, this start and end date should range all of these, so it doesn't need to compute the list of components in the range over and over again. The functions themselves(e.g. :function:`self.includes` and :function:`self.intersects`) help you to limit the exact range you want to return components for. :param v_calendar: The VCalendar object we are iterating over. :param start_date: The minimum ending date of each event that is returned inside this timeline. :param end_date: The maximum starting date of each event that is return inside this timeline. \"\"\" def __init__ ( self , v_calendar : VCalendar , start_date : Optional [ DateTime ] = None , end_date : Optional [ DateTime ] = None ): self . v_calendar : VCalendar = v_calendar self . _start_date : DateTime = start_date or DateTime ( 1970 , 1 , 1 ) self . _end_date : DateTime = end_date or DateTime ( 2100 , 1 , 1 ) def __repr__ ( self ) -> str : return f \"Timeline( { self . _start_date } , { self . _end_date } )\" @property def start_date ( self ) -> DateTime : \"\"\"Return the start date of the timeline. No event should end before this value.\"\"\" return self . _start_date @start_date . setter def start_date ( self , value ) -> None : \"\"\"Set the start date of the timeline.\"\"\" self . _start_date = value self . get_timespan . cache_clear () @property def end_date ( self ) -> DateTime : \"\"\"Return the end date of the timeline. No event should start before this value.\"\"\" return self . _end_date @end_date . setter def end_date ( self , value ) -> None : \"\"\"Set the end date of the timeline.\"\"\" self . _end_date = value self . get_timespan . cache_clear () @instance_lru_cache () def get_timespan ( self ) -> Timespan : \"\"\"Return the start and end date as a Timespan.\"\"\" return Timespan ( self . start_date , self . end_date ) @staticmethod def __get_items_to_exclude_from_recurrence ( all_components : List [ Component ], ) -> Dict [ str , Union [ List [ Date ], List [ DateTime ]]]: \"\"\" Deduplicate recurring components. Sometimes it happens that recurring events are changed and this will cause them to both be present as a standard component and in the recurrence. :param all_components: The list of all component children of the VCalendar instance. :return: A deduplicated list of components. \"\"\" start_date_to_timespan_dict : Dict [ str , Union [ List [ Date ], List [ DateTime ]]] = defaultdict ( list ) for component in all_components : if isinstance ( component , AbstractComponentWithRecurringProperties ) and component . recurrence_id is not None : start_date_to_timespan_dict [ component . uid . value ] . append ( component . recurrence_id . datetime_or_date_value ) return start_date_to_timespan_dict def __explode_recurring_components ( self ) -> List [ TimespanWithParent ]: \"\"\" Get a de-duplicated list of all components with a start date, including the recurring components. This means that we add all child component of the :class:`VCalendar` (except for the :class:`VTimeZone` instances) to a list and then add all extra occurrences (as recurring components) according to the recurrence properties: :class:`RRule`, :class:`RDate` and :class:`EXDate`. :return: A de-duplicated list of all components, including the recurring occurrences of the components. \"\"\" list_of_timestamps_with_parents : List [ TimespanWithParent ] = [] all_children = self . v_calendar . children uid_to_datetime_to_exclude = self . __get_items_to_exclude_from_recurrence ( all_children ) for c in all_children : # Do some initial filtering. if isinstance ( c , AbstractComponentWithRecurringProperties ): if c . max_recurring_timespan . intersects ( self . get_timespan ()): values_to_exclude = uid_to_datetime_to_exclude [ c . uid . value ] # .get defaults to None. list_of_timestamps_with_parents . extend ( c . expand_component_in_range ( self . get_timespan (), values_to_exclude ) ) elif isinstance ( c , VFreeBusy ): if c . timespan . intersects ( self . get_timespan ()): list_of_timestamps_with_parents . append ( c . timespan ) else : # There is no way to extend iana-props or x-props for now. If you feel like implementing this, please # let me know and open a PR :). pass return list_of_timestamps_with_parents def iterate ( self ) -> Iterator [ Tuple [ TimespanWithParent , Component ]]: \"\"\" Iterate over the `self.__explode_recurring_components()` in chronological order. Implementation detail: Using a heap is faster than sorting if the number of events (n) is much bigger than the number of events we extract from the iterator (k). Complexity: O(n + k log n). \"\"\" heap : List [ TimespanWithParent ] = self . __explode_recurring_components () heapq . heapify ( heap ) while heap : popped : TimespanWithParent = heapq . heappop ( heap ) yield popped , popped . parent def includes ( self , start : DateTime , stop : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over every component that is in the specified timespan.\"\"\" query_timespan = Timespan ( start , stop ) for timespan , event in self . iterate (): if timespan . is_included_in ( query_timespan ): yield event def overlapping ( self , start : DateTime , stop : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over every component that has an intersection with the timespan.\"\"\" query_timespan = Timespan ( start , stop ) for timespan , event in self . iterate (): if timespan . intersects ( query_timespan ): yield event def start_after ( self , instant : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) on every component larger than instant in chronological order.\"\"\" for timespan , event in self . iterate (): if timespan . begin > instant : yield event def at ( self , instant : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over all component that are occurring during `instant`.\"\"\" for timespan , event in self . iterate (): if timespan . includes ( instant ): yield event","title":"Timeline"},{"location":"code/timeline/#ical_library.timeline.Timeline.end_date","text":"Return the end date of the timeline. No event should start before this value.","title":"end_date"},{"location":"code/timeline/#ical_library.timeline.Timeline.start_date","text":"Return the start date of the timeline. No event should end before this value.","title":"start_date"},{"location":"code/timeline/#ical_library.timeline.Timeline.__explode_recurring_components","text":"Get a de-duplicated list of all components with a start date, including the recurring components. This means that we add all child component of the :class: VCalendar (except for the :class: VTimeZone instances) to a list and then add all extra occurrences (as recurring components) according to the recurrence properties: :class: RRule , :class: RDate and :class: EXDate . Returns: Type Description List [ TimespanWithParent ] A de-duplicated list of all components, including the recurring occurrences of the components. Source code in ical_library/timeline.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __explode_recurring_components ( self ) -> List [ TimespanWithParent ]: \"\"\" Get a de-duplicated list of all components with a start date, including the recurring components. This means that we add all child component of the :class:`VCalendar` (except for the :class:`VTimeZone` instances) to a list and then add all extra occurrences (as recurring components) according to the recurrence properties: :class:`RRule`, :class:`RDate` and :class:`EXDate`. :return: A de-duplicated list of all components, including the recurring occurrences of the components. \"\"\" list_of_timestamps_with_parents : List [ TimespanWithParent ] = [] all_children = self . v_calendar . children uid_to_datetime_to_exclude = self . __get_items_to_exclude_from_recurrence ( all_children ) for c in all_children : # Do some initial filtering. if isinstance ( c , AbstractComponentWithRecurringProperties ): if c . max_recurring_timespan . intersects ( self . get_timespan ()): values_to_exclude = uid_to_datetime_to_exclude [ c . uid . value ] # .get defaults to None. list_of_timestamps_with_parents . extend ( c . expand_component_in_range ( self . get_timespan (), values_to_exclude ) ) elif isinstance ( c , VFreeBusy ): if c . timespan . intersects ( self . get_timespan ()): list_of_timestamps_with_parents . append ( c . timespan ) else : # There is no way to extend iana-props or x-props for now. If you feel like implementing this, please # let me know and open a PR :). pass return list_of_timestamps_with_parents","title":"__explode_recurring_components"},{"location":"code/timeline/#ical_library.timeline.Timeline.__get_items_to_exclude_from_recurrence","text":"Deduplicate recurring components. Sometimes it happens that recurring events are changed and this will cause them to both be present as a standard component and in the recurrence. Parameters: Name Type Description Default all_components List [ Component ] The list of all component children of the VCalendar instance. required Returns: Type Description Dict [ str , Union [ List [ Date ], List [ DateTime ]]] A deduplicated list of components. Source code in ical_library/timeline.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 @staticmethod def __get_items_to_exclude_from_recurrence ( all_components : List [ Component ], ) -> Dict [ str , Union [ List [ Date ], List [ DateTime ]]]: \"\"\" Deduplicate recurring components. Sometimes it happens that recurring events are changed and this will cause them to both be present as a standard component and in the recurrence. :param all_components: The list of all component children of the VCalendar instance. :return: A deduplicated list of components. \"\"\" start_date_to_timespan_dict : Dict [ str , Union [ List [ Date ], List [ DateTime ]]] = defaultdict ( list ) for component in all_components : if isinstance ( component , AbstractComponentWithRecurringProperties ) and component . recurrence_id is not None : start_date_to_timespan_dict [ component . uid . value ] . append ( component . recurrence_id . datetime_or_date_value ) return start_date_to_timespan_dict","title":"__get_items_to_exclude_from_recurrence"},{"location":"code/timeline/#ical_library.timeline.Timeline.at","text":"Iterate (in chronological order) over all component that are occurring during instant . Source code in ical_library/timeline.py 146 147 148 149 150 def at ( self , instant : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over all component that are occurring during `instant`.\"\"\" for timespan , event in self . iterate (): if timespan . includes ( instant ): yield event","title":"at"},{"location":"code/timeline/#ical_library.timeline.Timeline.get_timespan","text":"Return the start and end date as a Timespan. Source code in ical_library/timeline.py 64 65 66 67 @instance_lru_cache () def get_timespan ( self ) -> Timespan : \"\"\"Return the start and end date as a Timespan.\"\"\" return Timespan ( self . start_date , self . end_date )","title":"get_timespan"},{"location":"code/timeline/#ical_library.timeline.Timeline.includes","text":"Iterate (in chronological order) over every component that is in the specified timespan. Source code in ical_library/timeline.py 126 127 128 129 130 131 def includes ( self , start : DateTime , stop : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over every component that is in the specified timespan.\"\"\" query_timespan = Timespan ( start , stop ) for timespan , event in self . iterate (): if timespan . is_included_in ( query_timespan ): yield event","title":"includes"},{"location":"code/timeline/#ical_library.timeline.Timeline.iterate","text":"Iterate over the self.__explode_recurring_components() in chronological order. Implementation detail: Using a heap is faster than sorting if the number of events (n) is much bigger than the number of events we extract from the iterator (k). Complexity: O(n + k log n). Source code in ical_library/timeline.py 113 114 115 116 117 118 119 120 121 122 123 124 def iterate ( self ) -> Iterator [ Tuple [ TimespanWithParent , Component ]]: \"\"\" Iterate over the `self.__explode_recurring_components()` in chronological order. Implementation detail: Using a heap is faster than sorting if the number of events (n) is much bigger than the number of events we extract from the iterator (k). Complexity: O(n + k log n). \"\"\" heap : List [ TimespanWithParent ] = self . __explode_recurring_components () heapq . heapify ( heap ) while heap : popped : TimespanWithParent = heapq . heappop ( heap ) yield popped , popped . parent","title":"iterate"},{"location":"code/timeline/#ical_library.timeline.Timeline.overlapping","text":"Iterate (in chronological order) over every component that has an intersection with the timespan. Source code in ical_library/timeline.py 133 134 135 136 137 138 def overlapping ( self , start : DateTime , stop : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) over every component that has an intersection with the timespan.\"\"\" query_timespan = Timespan ( start , stop ) for timespan , event in self . iterate (): if timespan . intersects ( query_timespan ): yield event","title":"overlapping"},{"location":"code/timeline/#ical_library.timeline.Timeline.start_after","text":"Iterate (in chronological order) on every component larger than instant in chronological order. Source code in ical_library/timeline.py 140 141 142 143 144 def start_after ( self , instant : DateTime ) -> Iterator [ Component ]: \"\"\"Iterate (in chronological order) on every component larger than instant in chronological order.\"\"\" for timespan , event in self . iterate (): if timespan . begin > instant : yield event","title":"start_after"},{"location":"code/components/base_class/","text":"The base classes All iCalendar Component classes and iCalendar Property classes inherit from ICalBaseClass . Then ICalBaseClass is extended by both Component and Property . ICalBaseClass This is the base class of all custom classes representing an iCal component or iCal property in our library. ical_library.base_classes.Component and :class: Property are the only ones inheriting this class directly, the rest of the classes are inheriting from :class: Component and :class: Property based on whether they represent an iCal component or iCal property. Parameters: Name Type Description Default name str the actual name of this property or component. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT, CUSTOMPROPERTY. required parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. required Source code in ical_library/base_classes/base_class.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class ICalBaseClass : \"\"\" This is the base class of all custom classes representing an iCal component or iCal property in our library. [ical_library.base_classes.Component][] and :class:`Property` are the only ones inheriting this class directly, the rest of the classes are inheriting from :class:`Component` and :class:`Property` based on whether they represent an iCal component or iCal property. :param name: the actual name of this property or component. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT, CUSTOMPROPERTY. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , name : str , parent : Optional [ \"Component\" ]): self . _name = name if self . _name is None : raise ValueError ( \"Name of a Component or Property should not be None. Please specify it.\" ) self . _parent : Optional [ \"Component\" ] = parent @property def parent ( self ) -> Optional [ \"Component\" ]: \"\"\" Return the parent :class:`Component` that contains this :class:`Component`. :return: Return the parent :class:`Component` instance or None in the case there is no parent (for VCalender's). \"\"\" return self . _parent @parent . setter def parent ( self , value : \"Component\" ): \"\"\" Setter for the parent :class:`Component`. This allows us to set the parent at a later moment. :param value: The parent :class:`Component`. \"\"\" self . _parent = value @property def name ( self ) -> str : \"\"\" Return the actual name of this property or component. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT, CUSTOMPROPERTY. We inherit this class, for the general Property and Component but also for the specific VEvent component and the RRule property. Now what do we do with the `x-comp` or `iana-comp` components and `x-prop` and `iana-prop` properties? They also have an iCalendar name, e.g. VCUSTOMCOMPONENT. However, we can't specify them beforehand as we simply can't cover all cases. Therefore, we use `get_ical_name_of_class` to find and map all of our pre-defined Components and Properties but we still specify the name for all custom components. So the rule of thumb: Use `.name` on instantiated classes while we use `.get_ical_name_of_class()` for non-instantiated classes. \"\"\" return self . _name @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\" Return the name of a pre-defined property or pre-defined component. E.g. VEVENT, RRULE, COMPONENT, PROPERTY. For a :class:`Property` this would be the value at the start of the line. Example: a property with the name of `ABC;def=ghi:jkl` would be `ABC`. For a :class:`Component` this would be the value at the start of the component after BEGIN. Example: a VEvent starts with `BEGIN:VEVENT`, hence this function would return `VEVENT`. \"\"\" return cls . __name__ . upper () name : str property Return the actual name of this property or component. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT, CUSTOMPROPERTY. We inherit this class, for the general Property and Component but also for the specific VEvent component and the RRule property. Now what do we do with the x-comp or iana-comp components and x-prop and iana-prop properties? They also have an iCalendar name, e.g. VCUSTOMCOMPONENT. However, we can't specify them beforehand as we simply can't cover all cases. Therefore, we use get_ical_name_of_class to find and map all of our pre-defined Components and Properties but we still specify the name for all custom components. So the rule of thumb: Use .name on instantiated classes while we use .get_ical_name_of_class() for non-instantiated classes. parent : Optional [ Component ] property writable Return the parent :class: Component that contains this :class: Component . Returns: Type Description Return the parent :class: Component instance or None in the case there is no parent (for VCalender's). get_ical_name_of_class () classmethod Return the name of a pre-defined property or pre-defined component. E.g. VEVENT, RRULE, COMPONENT, PROPERTY. For a :class: Property this would be the value at the start of the line. Example: a property with the name of ABC;def=ghi:jkl would be ABC . For a :class: Component this would be the value at the start of the component after BEGIN. Example: a VEvent starts with BEGIN:VEVENT , hence this function would return VEVENT . Source code in ical_library/base_classes/base_class.py 56 57 58 59 60 61 62 63 64 65 66 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\" Return the name of a pre-defined property or pre-defined component. E.g. VEVENT, RRULE, COMPONENT, PROPERTY. For a :class:`Property` this would be the value at the start of the line. Example: a property with the name of `ABC;def=ghi:jkl` would be `ABC`. For a :class:`Component` this would be the value at the start of the component after BEGIN. Example: a VEvent starts with `BEGIN:VEVENT`, hence this function would return `VEVENT`. \"\"\" return cls . __name__ . upper () Component Bases: ICalBaseClass This is the base class for any component (according to the RFC 5545 specification) in iCal-library. Inside all components (so also all classes inheriting this class, e.g. VEvent) there are four kind of variables: variables that start with _ . These are metadata of the class and not parsed as a property or component from the iCalendar data file. variables that have a type of List[x] and a default value of List. These are child components/properties of the instance. These components/properties may or may not be required to be present in the iCal file. variables that have a type of Optional[List[x]] . These are components/properties of the instance. They can be either optional or required and may occur multiple times in the iCal file. variables that have a type of Optional[x] (and not Optional[List[x]] ). These are properties of the instance. They can be either optional or required, but may only occur once in the iCal file. Any Component that is predefined according to the RFC 5545 should inherit this class, e.g. VCalendar, VEVENT. Only x-components or iana-components should instantiate the Component class directly. Parameters: Name Type Description Default name str The actual name of this component instance. E.g. VEVENT , RRULE , VCUSTOMCOMPONENT . required parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/base_classes/component.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 class Component ( ICalBaseClass ): \"\"\" This is the base class for any component (according to the RFC 5545 specification) in iCal-library. Inside all components (so also all classes inheriting this class, e.g. VEvent) there are four kind of variables: - variables that start with `_`. These are metadata of the class and not parsed as a property or component from the iCalendar data file. - variables that have a type of `List[x]` and a default value of List. These are child components/properties of the instance. These components/properties may or may not be required to be present in the iCal file. - variables that have a type of `Optional[List[x]]`. These are components/properties of the instance. They can be either optional or required and may occur multiple times in the iCal file. - variables that have a type of `Optional[x]` (and not `Optional[List[x]]`). These are properties of the instance. They can be either optional or required, but may only occur once in the iCal file. Any Component that is predefined according to the RFC 5545 should inherit this class, e.g. VCalendar, VEVENT. Only x-components or iana-components should instantiate the Component class directly. :param name: The actual name of this component instance. E.g. `VEVENT`, `RRULE`, `VCUSTOMCOMPONENT`. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , name : str , parent : Optional [ \"Component\" ] = None ): name = name if self . __class__ == Component else self . __class__ . get_ical_name_of_class () super () . __init__ ( name = name , parent = parent or ComponentContext . get_current_component ()) if parent is None and self . parent is not None : self . parent . __add_child_without_setting_the_parent ( self ) if self . parent is None and self . name != \"VCALENDAR\" : raise ValueError ( \"We should always set a Parent on __init__ of Components.\" ) self . _parse_line_start : Optional [ int ] = 0 self . _parse_line_end : Optional [ int ] = 0 self . _extra_child_components : Dict [ str , List [ \"Component\" ]] = defaultdict ( list ) self . _extra_properties : Dict [ str , List [ Property ]] = defaultdict ( list ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" properties_as_string = \", \" . join ([ f \" { name } = { value } \" for name , value in self . properties . items ()]) return f \" { self . __class__ . __name__ } ( { properties_as_string } )\" def __eq__ ( self : \"Component\" , other : \"Component\" ) -> bool : \"\"\"Return whether the current instance and the other instance are the same.\"\"\" if type ( self ) != type ( other ): return False return self . properties == other . properties and self . children == other . children def __enter__ ( self ): \"\"\"Enter the context manager. Check ComponentContext for more info.\"\"\" ComponentContext . push_context_managed_component ( self ) return self def __exit__ ( self , _type , _value , _tb ): \"\"\"Exit the context manager. Check ComponentContext for more info.\"\"\" ComponentContext . pop_context_managed_component () def _set_self_as_parent_for_ical_component ( self , prop_or_comp : ICalBaseClass ) -> None : \"\"\"Verifies the parent is not already set to a different component, if not sets the parent.\"\"\" if prop_or_comp . parent is None : prop_or_comp . parent = self elif prop_or_comp . parent != self : raise ValueError ( \"Trying to overwrite a parent. Please do not re-use property instance across different components.\" ) def as_parent ( self , value : T ) -> T : \"\"\"We set self as Parent for Properties and Components but also Properties and Components in lists.\"\"\" if isinstance ( value , ICalBaseClass ): self . _set_self_as_parent_for_ical_component ( value ) elif isinstance ( value , list ): # checking for list over Iterable is ~8,5x faster. for item in value : if isinstance ( item , ICalBaseClass ): self . _set_self_as_parent_for_ical_component ( item ) return value @property def extra_child_components ( self ) -> Dict [ str , List [ \"Component\" ]]: \"\"\"Return all children components that are considered as `x-comp` or `iana-comp` components.\"\"\" return self . _extra_child_components @property def extra_properties ( self ) -> Dict [ str , List [ Property ]]: \"\"\"Return all properties that are considered as `x-prop` or `iana-prop` properties.\"\"\" return self . _extra_properties @property def tree_root ( self ) -> \"VCalendar\" : \"\"\"Return the tree root which should always be a VCalendar object.\"\"\" from ical_library.ical_components import VCalendar instance = self while instance . parent is not None : instance = instance . parent if not isinstance ( instance , VCalendar ): raise CalendarParentRelationError ( f \"TreeRoot { instance =} is of type { type ( instance ) =} instead of VCalendar.\" ) return instance @property def children ( self ) -> List [ \"Component\" ]: \"\"\"Return all children components.\"\"\" extras = ( child for list_of_children in self . _extra_child_components . values () for child in list_of_children ) children = [ item_in_list for ical_name , ( var_name , var_type , is_list ) in self . _get_child_component_mapping () . items () for item_in_list in getattr ( self , var_name ) ] children . extend ( extras ) return children def __add_child_without_setting_the_parent ( self , child : \"Component\" ) -> None : \"\"\" Just add a child component and do not also set the parent. If the child is an undefined `x-comp` or `iana-comp` component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function:`self._get_child_component_mapping()`. \"\"\" child_component_mapping = self . _get_child_component_mapping () if child . name in child_component_mapping : var_name , var_type , is_list = child_component_mapping [ child . name ] getattr ( self , var_name ) . append ( child ) return self . _extra_child_components [ child . name ] . append ( child ) def add_child ( self , child : \"Component\" ) -> None : \"\"\" Add a children component and set its parent. If the child is an undefined `x-comp` or `iana-comp` component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function:`self._get_child_component_mapping()`. \"\"\" self . as_parent ( child ) self . __add_child_without_setting_the_parent ( child ) @property def original_ical_text ( self ) -> str : \"\"\"Return the original iCAL text for your property from the RAW string list as if it is a property.\"\"\" return self . tree_root . get_original_ical_text ( self . _parse_line_start , self . _parse_line_end ) @classmethod @lru_cache () def get_property_ical_names ( cls ) -> Set [ str ]: \"\"\" Get all the variables for this component class that reference a :class:`Property` in the typing information. \"\"\" return { var_name for var_name , var_type , is_list in cls . _get_property_mapping () . values ()} @staticmethod def _extract_ical_class_from_args ( var_name : str , a_type : Union [ Type [ List ], type ( Union )]) -> Type : \"\"\" Given *a_type*, which is either a List or an Optional, return the subtype that is not None. Note: When we execute get_args(some_type), we consider the result to be the subtypes. :param var_name: The variable name of the type we are dissecting. :param a_type: The type we want to get the subtype of. :return: The subtype that is not equal to the NoneType. :raise: TypeError when there is no subtype that does not contain a type that is not equal to NoneType. \"\"\" sub_types : List [ Type ] = [ st for st in get_args ( a_type ) if not issubclass ( get_origin ( st ) or st , type ( None ))] if len ( sub_types ) != 1 : raise TypeError ( f \"Incorrect number of sub_types to follow here for { var_name =} , { a_type =} , { sub_types =} .\" ) return sub_types [ 0 ] @staticmethod def _extract_type_information ( var_name : str , a_type : Type , is_in_list : bool ) -> Optional [ Tuple [ str , Tuple [ str , Optional [ Type [ ICalBaseClass ]], bool ]]]: \"\"\" Extract typing information for an instance variable of the component. The type of the variable should either be (wrapping) a :class:`Property` or a :class:`Component`. :param var_name: The variable name of the type we are dissecting. :param a_type: The type we want to extract a child class of :class:`ICalBaseClass` from. :param is_in_list: Whether the child class of :class:`ICalBaseClass` is contained in a List type. :return: None if there is no child class of :class:`ICalBaseClass` we can detect. Otherwise, we return a tuple containing the iCal name (e.g. VEVENT) and another tuple that contains the variable name, the child class of :class:`ICalBaseClass` and a boolean whether that child class was wrapped in a List. :raise: TypeError if there is no child class of :class:`ICalBaseClass` to detect. \"\"\" if get_origin ( a_type ) is None : if issubclass ( a_type , ICalBaseClass ): return a_type . get_ical_name_of_class (), ( var_name , a_type , is_in_list ) return None elif get_origin ( a_type ) == Union : # This also covers the Optional case. sub_class = Component . _extract_ical_class_from_args ( var_name , a_type ) return Component . _extract_type_information ( var_name , sub_class , is_in_list ) elif issubclass ( get_origin ( a_type ), List ): sub_class = Component . _extract_ical_class_from_args ( var_name , a_type ) return Component . _extract_type_information ( var_name , sub_class , True ) elif get_origin ( a_type ) == ClassVar : return None else : raise TypeError ( f \"Unknown type ' { a_type } ' came by in Component.extract_custom_type.\" ) @classmethod def _get_init_method_for_var_mapping ( cls ) -> Callable : \"\"\" We generate _get_var_mapping based on `cls.__init__`. This var mapping is later used to list all properties, all components but also all the types of the items. This is a function so that it can be overwritten for the recurring components. \"\"\" return cls . __init__ @classmethod @lru_cache () def _get_var_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ ICalBaseClass ], bool ]]: \"\"\" Get a mapping of all variables of this class that do not start with `_`. :return: A class mapping that maps the iCal name (e.g. VEVENT) to another tuple that contains the variable name, the child class of :class:`ICalBaseClass` and a boolean whether that child class was wrapped in a List. \"\"\" var_mapping : Dict [ str , Tuple [ str , Type [ ICalBaseClass ], bool ]] = {} a_field : inspect . Parameter for a_field in inspect . signature ( cls . _get_init_method_for_var_mapping ()) . parameters . values (): if a_field . name . startswith ( \"_\" ) or a_field . name in [ \"self\" , \"parent\" , \"name\" ]: continue result = Component . _extract_type_information ( a_field . name , a_field . annotation , False ) if result is None : continue ical_name , var_type_info = result if issubclass ( var_type_info [ 1 ], ICalBaseClass ): var_mapping [ ical_name ] = var_type_info return var_mapping @classmethod @lru_cache () def _get_property_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ Property ], bool ]]: \"\"\" Return the same mapping as :function:`cls._get_var_mapping()` but only return variables related to :class:`Property` classes. Example: `{\"RRULE\": tuple(\"rrule\", Type[RRule], False), ...}` \"\"\" return { ical_name : var_tuple for ical_name , var_tuple in cls . _get_var_mapping () . items () if issubclass ( var_tuple [ 1 ], Property ) } @classmethod @lru_cache () def _get_child_component_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ \"Component\" ], bool ]]: \"\"\" Return the same mapping as :function:`cls._get_var_mapping()` but only return variables related to :class:`Component` classes. \"\"\" return { ical_name : var_tuple for ical_name , var_tuple in cls . _get_var_mapping () . items () if issubclass ( var_tuple [ 1 ], Component ) } @property def properties ( self ) -> Dict [ str , Union [ Property , List [ Property ]]]: \"\"\"Return all iCalendar properties of this component instance.\"\"\" standard_properties = { var_name : getattr ( self , var_name ) for var_name , var_type , is_list in self . _get_property_mapping () . values () if getattr ( self , var_name ) is not None } return { ** standard_properties , ** self . _extra_properties } def print_tree_structure ( self , indent : int = 0 ) -> None : \"\"\"Print the tree structure of all components starting with this instance.\"\"\" print ( f \" { ' ' * indent } - { self } \" ) for child in self . children : child . print_tree_structure ( indent = indent + 1 ) def set_property ( self , property_instance : Property , property_map_info : Optional [ Tuple [ str , Type [ Property ], bool ]] = None , property_map_was_checked : bool = False , ) -> None : \"\"\" Setting a property for a Component instance. If the `property_map_info` is equal to None, we either have not yet looked up all the properties or it is an x-prop/iana-prop. This can be decided based on property_map_was_checked. This avoids extra (expensive) lookups in our self._get_property_mapping. :param property_instance: The Property we wish to set. :param property_map_info: A tuple containing the variable name for this Component instance, the type of the Property and whether the variable can occur multiple times for the same property. If it equals None, this either means it is an x-prop/iana-prop or that the property_map was not checked yet. :param property_map_was_checked: Whether the `property_map_info` was passed or not. If True, and `property_map_info` is `None`, we know that it is an iana property. If False, we still need to consult `_get_property_mapping`. \"\"\" if property_map_info is None and property_map_was_checked is False : property_map_info = self . _get_property_mapping () . get ( property_instance . name ) var_name , var_type , is_list = property_map_info or [ None , None , None ] if var_name is not None and is_list is not None : if is_list is True : if getattr ( self , var_name ) is None : setattr ( self , var_name , [ property_instance ]) else : current_value : List [ Property ] = getattr ( self , var_name ) current_value . append ( property_instance ) else : setattr ( self , var_name , property_instance ) else : self . _extra_properties [ property_instance . name . lower () . replace ( \"-\" , \"_\" )] . append ( property_instance ) def parse_property ( self , line : str ) -> Property : \"\"\" Parse a raw line containing a :class:`Property` definition, instantiate the corresponding Property and set the variable. Based on the first part of the line (before the ; and :), we know using *self._get_property_mapping()* which property type we should instantiate. Then, depending on whether the typing info of the property denoted it in a List or not, it adds it to a list/instantiates the list, compared to simply setting it as the variable of the :class:`Component` instance. Credits for the excellent regex parsing string go to @Jan Goyvaerts: https://stackoverflow.com/a/2482067/2277445 :param line: The entire line that contains the property string (meaning multi-lines properties are already converted to a single line here). :return: The created Property instance based on the *line* that we set for the component. \"\"\" property_mapping = self . _get_property_mapping () result = re . search ( \"^([^ \\r\\n ;:]+)(;[^ \\r\\n :]+)?:(.*)$\" , line ) if result is None : raise ValueError ( f \" { result =} should never be None! { line =} is invalid.\" ) name , property_parameters , value = result . group ( 1 ), result . group ( 2 ), result . group ( 3 ) property_parameters = property_parameters . lstrip ( \";\" ) if property_parameters else None if name in property_mapping . keys (): property_map_info = property_mapping [ name ] var_name , var_type , is_list = property_map_info property_instance = var_type ( name = name , property_parameters = property_parameters , value = value , parent = self ) self . set_property ( property_instance , property_map_info , property_map_was_checked = True ) else : property_instance = Property ( name = name , property_parameters = property_parameters , value = value , parent = self ) self . set_property ( property_instance , None , property_map_was_checked = True ) return property_instance def _instantiate_component ( self , ical_component_identifier : str ) -> \"Component\" : component_mapping = self . _get_child_component_mapping () if ical_component_identifier in component_mapping : var_name , var_type , is_list = component_mapping [ ical_component_identifier ] return var_type ( parent = self ) # type: ignore else : return Component ( name = ical_component_identifier , parent = self ) def parse_component ( self , lines : List [ str ], line_number : int ) -> int : \"\"\" Parse the raw lines representing this component (which was just instantiated). Based on the first line that starts with `BEGIN:`, we know using *self._get_child_component_mapping()* which specific component type we should instantiate. We then add it to the current component instance as a child. Then we parse line by line, if we find another `BEGIN:`, we create another component instance and proceed to calling :function:`self.parse_component` for parsing all the lines related to that component. If we find a property line (any line that doesn't start with `BEGIN:`), we call :function:`self.parse_property` which then automatically adds it to the current instance. :param lines: A list of all the lines in the iCalendar file. :param line_number: The line number at which this component starts. :return: The line number at which this component ends. \"\"\" self . _parse_line_start = line_number - 1 while not ( current_line := lines [ line_number ]) . startswith ( \"END:\" ): line_number += 1 if current_line . startswith ( \"BEGIN:\" ): component_name = current_line [ len ( \"BEGIN:\" ) :] instance = self . _instantiate_component ( component_name ) self . add_child ( instance ) line_number = instance . parse_component ( lines = lines , line_number = line_number ) continue full_line_without_line_breaks = current_line while ( next_line := lines [ line_number ]) . startswith ( \" \" ): line_number += 1 # [1:] so we skip the space indicating a line break. full_line_without_line_breaks += next_line [ 1 :] self . parse_property ( full_line_without_line_breaks ) if current_line != f \"END: { self . name } \" : raise ValueError ( f \"Expected { current_line =} to be equal to END: { self . name } . It seems { self } was never closed.\" ) self . _parse_line_end = line_number + 1 return line_number + 1 children : List [ Component ] property Return all children components. extra_child_components : Dict [ str , List [ Component ]] property Return all children components that are considered as x-comp or iana-comp components. extra_properties : Dict [ str , List [ Property ]] property Return all properties that are considered as x-prop or iana-prop properties. original_ical_text : str property Return the original iCAL text for your property from the RAW string list as if it is a property. properties : Dict [ str , Union [ Property , List [ Property ]]] property Return all iCalendar properties of this component instance. tree_root : VCalendar property Return the tree root which should always be a VCalendar object. __add_child_without_setting_the_parent ( child ) Just add a child component and do not also set the parent. If the child is an undefined x-comp or iana-comp component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function: self._get_child_component_mapping() . Source code in ical_library/base_classes/component.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def __add_child_without_setting_the_parent ( self , child : \"Component\" ) -> None : \"\"\" Just add a child component and do not also set the parent. If the child is an undefined `x-comp` or `iana-comp` component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function:`self._get_child_component_mapping()`. \"\"\" child_component_mapping = self . _get_child_component_mapping () if child . name in child_component_mapping : var_name , var_type , is_list = child_component_mapping [ child . name ] getattr ( self , var_name ) . append ( child ) return self . _extra_child_components [ child . name ] . append ( child ) __enter__ () Enter the context manager. Check ComponentContext for more info. Source code in ical_library/base_classes/component.py 78 79 80 81 def __enter__ ( self ): \"\"\"Enter the context manager. Check ComponentContext for more info.\"\"\" ComponentContext . push_context_managed_component ( self ) return self __exit__ ( _type , _value , _tb ) Exit the context manager. Check ComponentContext for more info. Source code in ical_library/base_classes/component.py 83 84 85 def __exit__ ( self , _type , _value , _tb ): \"\"\"Exit the context manager. Check ComponentContext for more info.\"\"\" ComponentContext . pop_context_managed_component () _extract_ical_class_from_args ( var_name , a_type ) staticmethod Given a_type , which is either a List or an Optional, return the subtype that is not None. Note: When we execute get_args(some_type), we consider the result to be the subtypes. Parameters: Name Type Description Default var_name str The variable name of the type we are dissecting. required a_type Union [ Type [ List ], type ( Union )] The type we want to get the subtype of. required Returns: Type Description Type The subtype that is not equal to the NoneType. Source code in ical_library/base_classes/component.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @staticmethod def _extract_ical_class_from_args ( var_name : str , a_type : Union [ Type [ List ], type ( Union )]) -> Type : \"\"\" Given *a_type*, which is either a List or an Optional, return the subtype that is not None. Note: When we execute get_args(some_type), we consider the result to be the subtypes. :param var_name: The variable name of the type we are dissecting. :param a_type: The type we want to get the subtype of. :return: The subtype that is not equal to the NoneType. :raise: TypeError when there is no subtype that does not contain a type that is not equal to NoneType. \"\"\" sub_types : List [ Type ] = [ st for st in get_args ( a_type ) if not issubclass ( get_origin ( st ) or st , type ( None ))] if len ( sub_types ) != 1 : raise TypeError ( f \"Incorrect number of sub_types to follow here for { var_name =} , { a_type =} , { sub_types =} .\" ) return sub_types [ 0 ] _extract_type_information ( var_name , a_type , is_in_list ) staticmethod Extract typing information for an instance variable of the component. The type of the variable should either be (wrapping) a :class: Property or a :class: Component . Parameters: Name Type Description Default var_name str The variable name of the type we are dissecting. required a_type Type The type we want to extract a child class of :class: ICalBaseClass from. required is_in_list bool Whether the child class of :class: ICalBaseClass is contained in a List type. required Returns: Type Description Optional [ Tuple [ str , Tuple [ str , Optional [ Type [ ICalBaseClass ]], bool ]]] None if there is no child class of :class: ICalBaseClass we can detect. Otherwise, we return a tuple containing the iCal name (e.g. VEVENT) and another tuple that contains the variable name, the child class of :class: ICalBaseClass and a boolean whether that child class was wrapped in a List. Source code in ical_library/base_classes/component.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 @staticmethod def _extract_type_information ( var_name : str , a_type : Type , is_in_list : bool ) -> Optional [ Tuple [ str , Tuple [ str , Optional [ Type [ ICalBaseClass ]], bool ]]]: \"\"\" Extract typing information for an instance variable of the component. The type of the variable should either be (wrapping) a :class:`Property` or a :class:`Component`. :param var_name: The variable name of the type we are dissecting. :param a_type: The type we want to extract a child class of :class:`ICalBaseClass` from. :param is_in_list: Whether the child class of :class:`ICalBaseClass` is contained in a List type. :return: None if there is no child class of :class:`ICalBaseClass` we can detect. Otherwise, we return a tuple containing the iCal name (e.g. VEVENT) and another tuple that contains the variable name, the child class of :class:`ICalBaseClass` and a boolean whether that child class was wrapped in a List. :raise: TypeError if there is no child class of :class:`ICalBaseClass` to detect. \"\"\" if get_origin ( a_type ) is None : if issubclass ( a_type , ICalBaseClass ): return a_type . get_ical_name_of_class (), ( var_name , a_type , is_in_list ) return None elif get_origin ( a_type ) == Union : # This also covers the Optional case. sub_class = Component . _extract_ical_class_from_args ( var_name , a_type ) return Component . _extract_type_information ( var_name , sub_class , is_in_list ) elif issubclass ( get_origin ( a_type ), List ): sub_class = Component . _extract_ical_class_from_args ( var_name , a_type ) return Component . _extract_type_information ( var_name , sub_class , True ) elif get_origin ( a_type ) == ClassVar : return None else : raise TypeError ( f \"Unknown type ' { a_type } ' came by in Component.extract_custom_type.\" ) _get_child_component_mapping () cached classmethod Return the same mapping as :function: cls._get_var_mapping() but only return variables related to :class: Component classes. Source code in ical_library/base_classes/component.py 272 273 274 275 276 277 278 279 280 281 282 283 @classmethod @lru_cache () def _get_child_component_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ \"Component\" ], bool ]]: \"\"\" Return the same mapping as :function:`cls._get_var_mapping()` but only return variables related to :class:`Component` classes. \"\"\" return { ical_name : var_tuple for ical_name , var_tuple in cls . _get_var_mapping () . items () if issubclass ( var_tuple [ 1 ], Component ) } _get_init_method_for_var_mapping () classmethod We generate _get_var_mapping based on cls.__init__ . This var mapping is later used to list all properties, all components but also all the types of the items. This is a function so that it can be overwritten for the recurring components. Source code in ical_library/base_classes/component.py 228 229 230 231 232 233 234 235 @classmethod def _get_init_method_for_var_mapping ( cls ) -> Callable : \"\"\" We generate _get_var_mapping based on `cls.__init__`. This var mapping is later used to list all properties, all components but also all the types of the items. This is a function so that it can be overwritten for the recurring components. \"\"\" return cls . __init__ _get_property_mapping () cached classmethod Return the same mapping as :function: cls._get_var_mapping() but only return variables related to :class: Property classes. Example: {\"RRULE\": tuple(\"rrule\", Type[RRule], False), ...} Source code in ical_library/base_classes/component.py 259 260 261 262 263 264 265 266 267 268 269 270 @classmethod @lru_cache () def _get_property_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ Property ], bool ]]: \"\"\" Return the same mapping as :function:`cls._get_var_mapping()` but only return variables related to :class:`Property` classes. Example: `{\"RRULE\": tuple(\"rrule\", Type[RRule], False), ...}` \"\"\" return { ical_name : var_tuple for ical_name , var_tuple in cls . _get_var_mapping () . items () if issubclass ( var_tuple [ 1 ], Property ) } _get_var_mapping () cached classmethod Get a mapping of all variables of this class that do not start with _ . Returns: Type Description Mapping [ str , Tuple [ str , Type [ ICalBaseClass ], bool ]] A class mapping that maps the iCal name (e.g. VEVENT) to another tuple that contains the variable name, the child class of :class: ICalBaseClass and a boolean whether that child class was wrapped in a List. Source code in ical_library/base_classes/component.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 @classmethod @lru_cache () def _get_var_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ ICalBaseClass ], bool ]]: \"\"\" Get a mapping of all variables of this class that do not start with `_`. :return: A class mapping that maps the iCal name (e.g. VEVENT) to another tuple that contains the variable name, the child class of :class:`ICalBaseClass` and a boolean whether that child class was wrapped in a List. \"\"\" var_mapping : Dict [ str , Tuple [ str , Type [ ICalBaseClass ], bool ]] = {} a_field : inspect . Parameter for a_field in inspect . signature ( cls . _get_init_method_for_var_mapping ()) . parameters . values (): if a_field . name . startswith ( \"_\" ) or a_field . name in [ \"self\" , \"parent\" , \"name\" ]: continue result = Component . _extract_type_information ( a_field . name , a_field . annotation , False ) if result is None : continue ical_name , var_type_info = result if issubclass ( var_type_info [ 1 ], ICalBaseClass ): var_mapping [ ical_name ] = var_type_info return var_mapping _set_self_as_parent_for_ical_component ( prop_or_comp ) Verifies the parent is not already set to a different component, if not sets the parent. Source code in ical_library/base_classes/component.py 87 88 89 90 91 92 93 94 def _set_self_as_parent_for_ical_component ( self , prop_or_comp : ICalBaseClass ) -> None : \"\"\"Verifies the parent is not already set to a different component, if not sets the parent.\"\"\" if prop_or_comp . parent is None : prop_or_comp . parent = self elif prop_or_comp . parent != self : raise ValueError ( \"Trying to overwrite a parent. Please do not re-use property instance across different components.\" ) add_child ( child ) Add a children component and set its parent. If the child is an undefined x-comp or iana-comp component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function: self._get_child_component_mapping() . Source code in ical_library/base_classes/component.py 157 158 159 160 161 162 163 164 165 166 def add_child ( self , child : \"Component\" ) -> None : \"\"\" Add a children component and set its parent. If the child is an undefined `x-comp` or `iana-comp` component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function:`self._get_child_component_mapping()`. \"\"\" self . as_parent ( child ) self . __add_child_without_setting_the_parent ( child ) as_parent ( value ) We set self as Parent for Properties and Components but also Properties and Components in lists. Source code in ical_library/base_classes/component.py 96 97 98 99 100 101 102 103 104 def as_parent ( self , value : T ) -> T : \"\"\"We set self as Parent for Properties and Components but also Properties and Components in lists.\"\"\" if isinstance ( value , ICalBaseClass ): self . _set_self_as_parent_for_ical_component ( value ) elif isinstance ( value , list ): # checking for list over Iterable is ~8,5x faster. for item in value : if isinstance ( item , ICalBaseClass ): self . _set_self_as_parent_for_ical_component ( item ) return value get_property_ical_names () cached classmethod Get all the variables for this component class that reference a :class: Property in the typing information. Source code in ical_library/base_classes/component.py 173 174 175 176 177 178 179 @classmethod @lru_cache () def get_property_ical_names ( cls ) -> Set [ str ]: \"\"\" Get all the variables for this component class that reference a :class:`Property` in the typing information. \"\"\" return { var_name for var_name , var_type , is_list in cls . _get_property_mapping () . values ()} parse_component ( lines , line_number ) Parse the raw lines representing this component (which was just instantiated). Based on the first line that starts with BEGIN: , we know using self._get_child_component_mapping() which specific component type we should instantiate. We then add it to the current component instance as a child. Then we parse line by line, if we find another BEGIN: , we create another component instance and proceed to calling :function: self.parse_component for parsing all the lines related to that component. If we find a property line (any line that doesn't start with BEGIN: ), we call :function: self.parse_property which then automatically adds it to the current instance. Parameters: Name Type Description Default lines List [ str ] A list of all the lines in the iCalendar file. required line_number int The line number at which this component starts. required Returns: Type Description int The line number at which this component ends. Source code in ical_library/base_classes/component.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 def parse_component ( self , lines : List [ str ], line_number : int ) -> int : \"\"\" Parse the raw lines representing this component (which was just instantiated). Based on the first line that starts with `BEGIN:`, we know using *self._get_child_component_mapping()* which specific component type we should instantiate. We then add it to the current component instance as a child. Then we parse line by line, if we find another `BEGIN:`, we create another component instance and proceed to calling :function:`self.parse_component` for parsing all the lines related to that component. If we find a property line (any line that doesn't start with `BEGIN:`), we call :function:`self.parse_property` which then automatically adds it to the current instance. :param lines: A list of all the lines in the iCalendar file. :param line_number: The line number at which this component starts. :return: The line number at which this component ends. \"\"\" self . _parse_line_start = line_number - 1 while not ( current_line := lines [ line_number ]) . startswith ( \"END:\" ): line_number += 1 if current_line . startswith ( \"BEGIN:\" ): component_name = current_line [ len ( \"BEGIN:\" ) :] instance = self . _instantiate_component ( component_name ) self . add_child ( instance ) line_number = instance . parse_component ( lines = lines , line_number = line_number ) continue full_line_without_line_breaks = current_line while ( next_line := lines [ line_number ]) . startswith ( \" \" ): line_number += 1 # [1:] so we skip the space indicating a line break. full_line_without_line_breaks += next_line [ 1 :] self . parse_property ( full_line_without_line_breaks ) if current_line != f \"END: { self . name } \" : raise ValueError ( f \"Expected { current_line =} to be equal to END: { self . name } . It seems { self } was never closed.\" ) self . _parse_line_end = line_number + 1 return line_number + 1 parse_property ( line ) Parse a raw line containing a :class: Property definition, instantiate the corresponding Property and set the variable. Based on the first part of the line (before the ; and :), we know using self._get_property_mapping() which property type we should instantiate. Then, depending on whether the typing info of the property denoted it in a List or not, it adds it to a list/instantiates the list, compared to simply setting it as the variable of the :class: Component instance. Credits for the excellent regex parsing string go to @Jan Goyvaerts: https://stackoverflow.com/a/2482067/2277445 Parameters: Name Type Description Default line str The entire line that contains the property string (meaning multi-lines properties are already converted to a single line here). required Returns: Type Description Property The created Property instance based on the line that we set for the component. Source code in ical_library/base_classes/component.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def parse_property ( self , line : str ) -> Property : \"\"\" Parse a raw line containing a :class:`Property` definition, instantiate the corresponding Property and set the variable. Based on the first part of the line (before the ; and :), we know using *self._get_property_mapping()* which property type we should instantiate. Then, depending on whether the typing info of the property denoted it in a List or not, it adds it to a list/instantiates the list, compared to simply setting it as the variable of the :class:`Component` instance. Credits for the excellent regex parsing string go to @Jan Goyvaerts: https://stackoverflow.com/a/2482067/2277445 :param line: The entire line that contains the property string (meaning multi-lines properties are already converted to a single line here). :return: The created Property instance based on the *line* that we set for the component. \"\"\" property_mapping = self . _get_property_mapping () result = re . search ( \"^([^ \\r\\n ;:]+)(;[^ \\r\\n :]+)?:(.*)$\" , line ) if result is None : raise ValueError ( f \" { result =} should never be None! { line =} is invalid.\" ) name , property_parameters , value = result . group ( 1 ), result . group ( 2 ), result . group ( 3 ) property_parameters = property_parameters . lstrip ( \";\" ) if property_parameters else None if name in property_mapping . keys (): property_map_info = property_mapping [ name ] var_name , var_type , is_list = property_map_info property_instance = var_type ( name = name , property_parameters = property_parameters , value = value , parent = self ) self . set_property ( property_instance , property_map_info , property_map_was_checked = True ) else : property_instance = Property ( name = name , property_parameters = property_parameters , value = value , parent = self ) self . set_property ( property_instance , None , property_map_was_checked = True ) return property_instance print_tree_structure ( indent = 0 ) Print the tree structure of all components starting with this instance. Source code in ical_library/base_classes/component.py 295 296 297 298 299 def print_tree_structure ( self , indent : int = 0 ) -> None : \"\"\"Print the tree structure of all components starting with this instance.\"\"\" print ( f \" { ' ' * indent } - { self } \" ) for child in self . children : child . print_tree_structure ( indent = indent + 1 ) set_property ( property_instance , property_map_info = None , property_map_was_checked = False ) Setting a property for a Component instance. If the property_map_info is equal to None, we either have not yet looked up all the properties or it is an x-prop/iana-prop. This can be decided based on property_map_was_checked. This avoids extra (expensive) lookups in our self._get_property_mapping. Parameters: Name Type Description Default property_instance Property The Property we wish to set. required property_map_info Optional [ Tuple [ str , Type [ Property ], bool ]] A tuple containing the variable name for this Component instance, the type of the Property and whether the variable can occur multiple times for the same property. If it equals None, this either means it is an x-prop/iana-prop or that the property_map was not checked yet. None property_map_was_checked bool Whether the property_map_info was passed or not. If True, and property_map_info is None , we know that it is an iana property. If False, we still need to consult _get_property_mapping . False Source code in ical_library/base_classes/component.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 def set_property ( self , property_instance : Property , property_map_info : Optional [ Tuple [ str , Type [ Property ], bool ]] = None , property_map_was_checked : bool = False , ) -> None : \"\"\" Setting a property for a Component instance. If the `property_map_info` is equal to None, we either have not yet looked up all the properties or it is an x-prop/iana-prop. This can be decided based on property_map_was_checked. This avoids extra (expensive) lookups in our self._get_property_mapping. :param property_instance: The Property we wish to set. :param property_map_info: A tuple containing the variable name for this Component instance, the type of the Property and whether the variable can occur multiple times for the same property. If it equals None, this either means it is an x-prop/iana-prop or that the property_map was not checked yet. :param property_map_was_checked: Whether the `property_map_info` was passed or not. If True, and `property_map_info` is `None`, we know that it is an iana property. If False, we still need to consult `_get_property_mapping`. \"\"\" if property_map_info is None and property_map_was_checked is False : property_map_info = self . _get_property_mapping () . get ( property_instance . name ) var_name , var_type , is_list = property_map_info or [ None , None , None ] if var_name is not None and is_list is not None : if is_list is True : if getattr ( self , var_name ) is None : setattr ( self , var_name , [ property_instance ]) else : current_value : List [ Property ] = getattr ( self , var_name ) current_value . append ( property_instance ) else : setattr ( self , var_name , property_instance ) else : self . _extra_properties [ property_instance . name . lower () . replace ( \"-\" , \"_\" )] . append ( property_instance ) ComponentContext Component context is used to keep the current Component when Component is used as ContextManager. You can use components as context: with Component () as my_component : . If you do this the context stores the Component and whenever a new component or property is created, it will use such stored Component as the parent Component. Source code in ical_library/help_modules/component_context.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class ComponentContext : \"\"\" Component context is used to keep the current Component when Component is used as ContextManager. You can use components as context: `#!py3 with Component() as my_component:`. If you do this the context stores the Component and whenever a new component or property is created, it will use such stored Component as the parent Component. \"\"\" _context_managed_component : Optional [ \"Component\" ] = None _previous_context_managed_components : List [ \"Component\" ] = [] @classmethod def push_context_managed_component ( cls , component : \"Component\" ): \"\"\"Set the current context managed component.\"\"\" if cls . _context_managed_component : cls . _previous_context_managed_components . append ( cls . _context_managed_component ) cls . _context_managed_component = component @classmethod def pop_context_managed_component ( cls ) -> Optional [ \"Component\" ]: \"\"\"Pop the current context managed component.\"\"\" old_component = cls . _context_managed_component if cls . _previous_context_managed_components : cls . _context_managed_component = cls . _previous_context_managed_components . pop () else : cls . _context_managed_component = None return old_component @classmethod def get_current_component ( cls ) -> Optional [ \"Component\" ]: \"\"\"Get the current context managed component.\"\"\" return cls . _context_managed_component get_current_component () classmethod Get the current context managed component. Source code in ical_library/help_modules/component_context.py 37 38 39 40 @classmethod def get_current_component ( cls ) -> Optional [ \"Component\" ]: \"\"\"Get the current context managed component.\"\"\" return cls . _context_managed_component pop_context_managed_component () classmethod Pop the current context managed component. Source code in ical_library/help_modules/component_context.py 27 28 29 30 31 32 33 34 35 @classmethod def pop_context_managed_component ( cls ) -> Optional [ \"Component\" ]: \"\"\"Pop the current context managed component.\"\"\" old_component = cls . _context_managed_component if cls . _previous_context_managed_components : cls . _context_managed_component = cls . _previous_context_managed_components . pop () else : cls . _context_managed_component = None return old_component push_context_managed_component ( component ) classmethod Set the current context managed component. Source code in ical_library/help_modules/component_context.py 20 21 22 23 24 25 @classmethod def push_context_managed_component ( cls , component : \"Component\" ): \"\"\"Set the current context managed component.\"\"\" if cls . _context_managed_component : cls . _previous_context_managed_components . append ( cls . _context_managed_component ) cls . _context_managed_component = component","title":"Base classes"},{"location":"code/components/base_class/#the-base-classes","text":"All iCalendar Component classes and iCalendar Property classes inherit from ICalBaseClass . Then ICalBaseClass is extended by both Component and Property .","title":"The base classes"},{"location":"code/components/base_class/#ical_library.base_classes.ICalBaseClass","text":"This is the base class of all custom classes representing an iCal component or iCal property in our library. ical_library.base_classes.Component and :class: Property are the only ones inheriting this class directly, the rest of the classes are inheriting from :class: Component and :class: Property based on whether they represent an iCal component or iCal property. Parameters: Name Type Description Default name str the actual name of this property or component. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT, CUSTOMPROPERTY. required parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. required Source code in ical_library/base_classes/base_class.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class ICalBaseClass : \"\"\" This is the base class of all custom classes representing an iCal component or iCal property in our library. [ical_library.base_classes.Component][] and :class:`Property` are the only ones inheriting this class directly, the rest of the classes are inheriting from :class:`Component` and :class:`Property` based on whether they represent an iCal component or iCal property. :param name: the actual name of this property or component. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT, CUSTOMPROPERTY. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , name : str , parent : Optional [ \"Component\" ]): self . _name = name if self . _name is None : raise ValueError ( \"Name of a Component or Property should not be None. Please specify it.\" ) self . _parent : Optional [ \"Component\" ] = parent @property def parent ( self ) -> Optional [ \"Component\" ]: \"\"\" Return the parent :class:`Component` that contains this :class:`Component`. :return: Return the parent :class:`Component` instance or None in the case there is no parent (for VCalender's). \"\"\" return self . _parent @parent . setter def parent ( self , value : \"Component\" ): \"\"\" Setter for the parent :class:`Component`. This allows us to set the parent at a later moment. :param value: The parent :class:`Component`. \"\"\" self . _parent = value @property def name ( self ) -> str : \"\"\" Return the actual name of this property or component. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT, CUSTOMPROPERTY. We inherit this class, for the general Property and Component but also for the specific VEvent component and the RRule property. Now what do we do with the `x-comp` or `iana-comp` components and `x-prop` and `iana-prop` properties? They also have an iCalendar name, e.g. VCUSTOMCOMPONENT. However, we can't specify them beforehand as we simply can't cover all cases. Therefore, we use `get_ical_name_of_class` to find and map all of our pre-defined Components and Properties but we still specify the name for all custom components. So the rule of thumb: Use `.name` on instantiated classes while we use `.get_ical_name_of_class()` for non-instantiated classes. \"\"\" return self . _name @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\" Return the name of a pre-defined property or pre-defined component. E.g. VEVENT, RRULE, COMPONENT, PROPERTY. For a :class:`Property` this would be the value at the start of the line. Example: a property with the name of `ABC;def=ghi:jkl` would be `ABC`. For a :class:`Component` this would be the value at the start of the component after BEGIN. Example: a VEvent starts with `BEGIN:VEVENT`, hence this function would return `VEVENT`. \"\"\" return cls . __name__ . upper ()","title":"ICalBaseClass"},{"location":"code/components/base_class/#ical_library.base_classes.ICalBaseClass.name","text":"Return the actual name of this property or component. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT, CUSTOMPROPERTY. We inherit this class, for the general Property and Component but also for the specific VEvent component and the RRule property. Now what do we do with the x-comp or iana-comp components and x-prop and iana-prop properties? They also have an iCalendar name, e.g. VCUSTOMCOMPONENT. However, we can't specify them beforehand as we simply can't cover all cases. Therefore, we use get_ical_name_of_class to find and map all of our pre-defined Components and Properties but we still specify the name for all custom components. So the rule of thumb: Use .name on instantiated classes while we use .get_ical_name_of_class() for non-instantiated classes.","title":"name"},{"location":"code/components/base_class/#ical_library.base_classes.ICalBaseClass.parent","text":"Return the parent :class: Component that contains this :class: Component . Returns: Type Description Return the parent :class: Component instance or None in the case there is no parent (for VCalender's).","title":"parent"},{"location":"code/components/base_class/#ical_library.base_classes.ICalBaseClass.get_ical_name_of_class","text":"Return the name of a pre-defined property or pre-defined component. E.g. VEVENT, RRULE, COMPONENT, PROPERTY. For a :class: Property this would be the value at the start of the line. Example: a property with the name of ABC;def=ghi:jkl would be ABC . For a :class: Component this would be the value at the start of the component after BEGIN. Example: a VEvent starts with BEGIN:VEVENT , hence this function would return VEVENT . Source code in ical_library/base_classes/base_class.py 56 57 58 59 60 61 62 63 64 65 66 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\" Return the name of a pre-defined property or pre-defined component. E.g. VEVENT, RRULE, COMPONENT, PROPERTY. For a :class:`Property` this would be the value at the start of the line. Example: a property with the name of `ABC;def=ghi:jkl` would be `ABC`. For a :class:`Component` this would be the value at the start of the component after BEGIN. Example: a VEvent starts with `BEGIN:VEVENT`, hence this function would return `VEVENT`. \"\"\" return cls . __name__ . upper ()","title":"get_ical_name_of_class"},{"location":"code/components/base_class/#ical_library.base_classes.Component","text":"Bases: ICalBaseClass This is the base class for any component (according to the RFC 5545 specification) in iCal-library. Inside all components (so also all classes inheriting this class, e.g. VEvent) there are four kind of variables: variables that start with _ . These are metadata of the class and not parsed as a property or component from the iCalendar data file. variables that have a type of List[x] and a default value of List. These are child components/properties of the instance. These components/properties may or may not be required to be present in the iCal file. variables that have a type of Optional[List[x]] . These are components/properties of the instance. They can be either optional or required and may occur multiple times in the iCal file. variables that have a type of Optional[x] (and not Optional[List[x]] ). These are properties of the instance. They can be either optional or required, but may only occur once in the iCal file. Any Component that is predefined according to the RFC 5545 should inherit this class, e.g. VCalendar, VEVENT. Only x-components or iana-components should instantiate the Component class directly. Parameters: Name Type Description Default name str The actual name of this component instance. E.g. VEVENT , RRULE , VCUSTOMCOMPONENT . required parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/base_classes/component.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 class Component ( ICalBaseClass ): \"\"\" This is the base class for any component (according to the RFC 5545 specification) in iCal-library. Inside all components (so also all classes inheriting this class, e.g. VEvent) there are four kind of variables: - variables that start with `_`. These are metadata of the class and not parsed as a property or component from the iCalendar data file. - variables that have a type of `List[x]` and a default value of List. These are child components/properties of the instance. These components/properties may or may not be required to be present in the iCal file. - variables that have a type of `Optional[List[x]]`. These are components/properties of the instance. They can be either optional or required and may occur multiple times in the iCal file. - variables that have a type of `Optional[x]` (and not `Optional[List[x]]`). These are properties of the instance. They can be either optional or required, but may only occur once in the iCal file. Any Component that is predefined according to the RFC 5545 should inherit this class, e.g. VCalendar, VEVENT. Only x-components or iana-components should instantiate the Component class directly. :param name: The actual name of this component instance. E.g. `VEVENT`, `RRULE`, `VCUSTOMCOMPONENT`. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , name : str , parent : Optional [ \"Component\" ] = None ): name = name if self . __class__ == Component else self . __class__ . get_ical_name_of_class () super () . __init__ ( name = name , parent = parent or ComponentContext . get_current_component ()) if parent is None and self . parent is not None : self . parent . __add_child_without_setting_the_parent ( self ) if self . parent is None and self . name != \"VCALENDAR\" : raise ValueError ( \"We should always set a Parent on __init__ of Components.\" ) self . _parse_line_start : Optional [ int ] = 0 self . _parse_line_end : Optional [ int ] = 0 self . _extra_child_components : Dict [ str , List [ \"Component\" ]] = defaultdict ( list ) self . _extra_properties : Dict [ str , List [ Property ]] = defaultdict ( list ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" properties_as_string = \", \" . join ([ f \" { name } = { value } \" for name , value in self . properties . items ()]) return f \" { self . __class__ . __name__ } ( { properties_as_string } )\" def __eq__ ( self : \"Component\" , other : \"Component\" ) -> bool : \"\"\"Return whether the current instance and the other instance are the same.\"\"\" if type ( self ) != type ( other ): return False return self . properties == other . properties and self . children == other . children def __enter__ ( self ): \"\"\"Enter the context manager. Check ComponentContext for more info.\"\"\" ComponentContext . push_context_managed_component ( self ) return self def __exit__ ( self , _type , _value , _tb ): \"\"\"Exit the context manager. Check ComponentContext for more info.\"\"\" ComponentContext . pop_context_managed_component () def _set_self_as_parent_for_ical_component ( self , prop_or_comp : ICalBaseClass ) -> None : \"\"\"Verifies the parent is not already set to a different component, if not sets the parent.\"\"\" if prop_or_comp . parent is None : prop_or_comp . parent = self elif prop_or_comp . parent != self : raise ValueError ( \"Trying to overwrite a parent. Please do not re-use property instance across different components.\" ) def as_parent ( self , value : T ) -> T : \"\"\"We set self as Parent for Properties and Components but also Properties and Components in lists.\"\"\" if isinstance ( value , ICalBaseClass ): self . _set_self_as_parent_for_ical_component ( value ) elif isinstance ( value , list ): # checking for list over Iterable is ~8,5x faster. for item in value : if isinstance ( item , ICalBaseClass ): self . _set_self_as_parent_for_ical_component ( item ) return value @property def extra_child_components ( self ) -> Dict [ str , List [ \"Component\" ]]: \"\"\"Return all children components that are considered as `x-comp` or `iana-comp` components.\"\"\" return self . _extra_child_components @property def extra_properties ( self ) -> Dict [ str , List [ Property ]]: \"\"\"Return all properties that are considered as `x-prop` or `iana-prop` properties.\"\"\" return self . _extra_properties @property def tree_root ( self ) -> \"VCalendar\" : \"\"\"Return the tree root which should always be a VCalendar object.\"\"\" from ical_library.ical_components import VCalendar instance = self while instance . parent is not None : instance = instance . parent if not isinstance ( instance , VCalendar ): raise CalendarParentRelationError ( f \"TreeRoot { instance =} is of type { type ( instance ) =} instead of VCalendar.\" ) return instance @property def children ( self ) -> List [ \"Component\" ]: \"\"\"Return all children components.\"\"\" extras = ( child for list_of_children in self . _extra_child_components . values () for child in list_of_children ) children = [ item_in_list for ical_name , ( var_name , var_type , is_list ) in self . _get_child_component_mapping () . items () for item_in_list in getattr ( self , var_name ) ] children . extend ( extras ) return children def __add_child_without_setting_the_parent ( self , child : \"Component\" ) -> None : \"\"\" Just add a child component and do not also set the parent. If the child is an undefined `x-comp` or `iana-comp` component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function:`self._get_child_component_mapping()`. \"\"\" child_component_mapping = self . _get_child_component_mapping () if child . name in child_component_mapping : var_name , var_type , is_list = child_component_mapping [ child . name ] getattr ( self , var_name ) . append ( child ) return self . _extra_child_components [ child . name ] . append ( child ) def add_child ( self , child : \"Component\" ) -> None : \"\"\" Add a children component and set its parent. If the child is an undefined `x-comp` or `iana-comp` component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function:`self._get_child_component_mapping()`. \"\"\" self . as_parent ( child ) self . __add_child_without_setting_the_parent ( child ) @property def original_ical_text ( self ) -> str : \"\"\"Return the original iCAL text for your property from the RAW string list as if it is a property.\"\"\" return self . tree_root . get_original_ical_text ( self . _parse_line_start , self . _parse_line_end ) @classmethod @lru_cache () def get_property_ical_names ( cls ) -> Set [ str ]: \"\"\" Get all the variables for this component class that reference a :class:`Property` in the typing information. \"\"\" return { var_name for var_name , var_type , is_list in cls . _get_property_mapping () . values ()} @staticmethod def _extract_ical_class_from_args ( var_name : str , a_type : Union [ Type [ List ], type ( Union )]) -> Type : \"\"\" Given *a_type*, which is either a List or an Optional, return the subtype that is not None. Note: When we execute get_args(some_type), we consider the result to be the subtypes. :param var_name: The variable name of the type we are dissecting. :param a_type: The type we want to get the subtype of. :return: The subtype that is not equal to the NoneType. :raise: TypeError when there is no subtype that does not contain a type that is not equal to NoneType. \"\"\" sub_types : List [ Type ] = [ st for st in get_args ( a_type ) if not issubclass ( get_origin ( st ) or st , type ( None ))] if len ( sub_types ) != 1 : raise TypeError ( f \"Incorrect number of sub_types to follow here for { var_name =} , { a_type =} , { sub_types =} .\" ) return sub_types [ 0 ] @staticmethod def _extract_type_information ( var_name : str , a_type : Type , is_in_list : bool ) -> Optional [ Tuple [ str , Tuple [ str , Optional [ Type [ ICalBaseClass ]], bool ]]]: \"\"\" Extract typing information for an instance variable of the component. The type of the variable should either be (wrapping) a :class:`Property` or a :class:`Component`. :param var_name: The variable name of the type we are dissecting. :param a_type: The type we want to extract a child class of :class:`ICalBaseClass` from. :param is_in_list: Whether the child class of :class:`ICalBaseClass` is contained in a List type. :return: None if there is no child class of :class:`ICalBaseClass` we can detect. Otherwise, we return a tuple containing the iCal name (e.g. VEVENT) and another tuple that contains the variable name, the child class of :class:`ICalBaseClass` and a boolean whether that child class was wrapped in a List. :raise: TypeError if there is no child class of :class:`ICalBaseClass` to detect. \"\"\" if get_origin ( a_type ) is None : if issubclass ( a_type , ICalBaseClass ): return a_type . get_ical_name_of_class (), ( var_name , a_type , is_in_list ) return None elif get_origin ( a_type ) == Union : # This also covers the Optional case. sub_class = Component . _extract_ical_class_from_args ( var_name , a_type ) return Component . _extract_type_information ( var_name , sub_class , is_in_list ) elif issubclass ( get_origin ( a_type ), List ): sub_class = Component . _extract_ical_class_from_args ( var_name , a_type ) return Component . _extract_type_information ( var_name , sub_class , True ) elif get_origin ( a_type ) == ClassVar : return None else : raise TypeError ( f \"Unknown type ' { a_type } ' came by in Component.extract_custom_type.\" ) @classmethod def _get_init_method_for_var_mapping ( cls ) -> Callable : \"\"\" We generate _get_var_mapping based on `cls.__init__`. This var mapping is later used to list all properties, all components but also all the types of the items. This is a function so that it can be overwritten for the recurring components. \"\"\" return cls . __init__ @classmethod @lru_cache () def _get_var_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ ICalBaseClass ], bool ]]: \"\"\" Get a mapping of all variables of this class that do not start with `_`. :return: A class mapping that maps the iCal name (e.g. VEVENT) to another tuple that contains the variable name, the child class of :class:`ICalBaseClass` and a boolean whether that child class was wrapped in a List. \"\"\" var_mapping : Dict [ str , Tuple [ str , Type [ ICalBaseClass ], bool ]] = {} a_field : inspect . Parameter for a_field in inspect . signature ( cls . _get_init_method_for_var_mapping ()) . parameters . values (): if a_field . name . startswith ( \"_\" ) or a_field . name in [ \"self\" , \"parent\" , \"name\" ]: continue result = Component . _extract_type_information ( a_field . name , a_field . annotation , False ) if result is None : continue ical_name , var_type_info = result if issubclass ( var_type_info [ 1 ], ICalBaseClass ): var_mapping [ ical_name ] = var_type_info return var_mapping @classmethod @lru_cache () def _get_property_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ Property ], bool ]]: \"\"\" Return the same mapping as :function:`cls._get_var_mapping()` but only return variables related to :class:`Property` classes. Example: `{\"RRULE\": tuple(\"rrule\", Type[RRule], False), ...}` \"\"\" return { ical_name : var_tuple for ical_name , var_tuple in cls . _get_var_mapping () . items () if issubclass ( var_tuple [ 1 ], Property ) } @classmethod @lru_cache () def _get_child_component_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ \"Component\" ], bool ]]: \"\"\" Return the same mapping as :function:`cls._get_var_mapping()` but only return variables related to :class:`Component` classes. \"\"\" return { ical_name : var_tuple for ical_name , var_tuple in cls . _get_var_mapping () . items () if issubclass ( var_tuple [ 1 ], Component ) } @property def properties ( self ) -> Dict [ str , Union [ Property , List [ Property ]]]: \"\"\"Return all iCalendar properties of this component instance.\"\"\" standard_properties = { var_name : getattr ( self , var_name ) for var_name , var_type , is_list in self . _get_property_mapping () . values () if getattr ( self , var_name ) is not None } return { ** standard_properties , ** self . _extra_properties } def print_tree_structure ( self , indent : int = 0 ) -> None : \"\"\"Print the tree structure of all components starting with this instance.\"\"\" print ( f \" { ' ' * indent } - { self } \" ) for child in self . children : child . print_tree_structure ( indent = indent + 1 ) def set_property ( self , property_instance : Property , property_map_info : Optional [ Tuple [ str , Type [ Property ], bool ]] = None , property_map_was_checked : bool = False , ) -> None : \"\"\" Setting a property for a Component instance. If the `property_map_info` is equal to None, we either have not yet looked up all the properties or it is an x-prop/iana-prop. This can be decided based on property_map_was_checked. This avoids extra (expensive) lookups in our self._get_property_mapping. :param property_instance: The Property we wish to set. :param property_map_info: A tuple containing the variable name for this Component instance, the type of the Property and whether the variable can occur multiple times for the same property. If it equals None, this either means it is an x-prop/iana-prop or that the property_map was not checked yet. :param property_map_was_checked: Whether the `property_map_info` was passed or not. If True, and `property_map_info` is `None`, we know that it is an iana property. If False, we still need to consult `_get_property_mapping`. \"\"\" if property_map_info is None and property_map_was_checked is False : property_map_info = self . _get_property_mapping () . get ( property_instance . name ) var_name , var_type , is_list = property_map_info or [ None , None , None ] if var_name is not None and is_list is not None : if is_list is True : if getattr ( self , var_name ) is None : setattr ( self , var_name , [ property_instance ]) else : current_value : List [ Property ] = getattr ( self , var_name ) current_value . append ( property_instance ) else : setattr ( self , var_name , property_instance ) else : self . _extra_properties [ property_instance . name . lower () . replace ( \"-\" , \"_\" )] . append ( property_instance ) def parse_property ( self , line : str ) -> Property : \"\"\" Parse a raw line containing a :class:`Property` definition, instantiate the corresponding Property and set the variable. Based on the first part of the line (before the ; and :), we know using *self._get_property_mapping()* which property type we should instantiate. Then, depending on whether the typing info of the property denoted it in a List or not, it adds it to a list/instantiates the list, compared to simply setting it as the variable of the :class:`Component` instance. Credits for the excellent regex parsing string go to @Jan Goyvaerts: https://stackoverflow.com/a/2482067/2277445 :param line: The entire line that contains the property string (meaning multi-lines properties are already converted to a single line here). :return: The created Property instance based on the *line* that we set for the component. \"\"\" property_mapping = self . _get_property_mapping () result = re . search ( \"^([^ \\r\\n ;:]+)(;[^ \\r\\n :]+)?:(.*)$\" , line ) if result is None : raise ValueError ( f \" { result =} should never be None! { line =} is invalid.\" ) name , property_parameters , value = result . group ( 1 ), result . group ( 2 ), result . group ( 3 ) property_parameters = property_parameters . lstrip ( \";\" ) if property_parameters else None if name in property_mapping . keys (): property_map_info = property_mapping [ name ] var_name , var_type , is_list = property_map_info property_instance = var_type ( name = name , property_parameters = property_parameters , value = value , parent = self ) self . set_property ( property_instance , property_map_info , property_map_was_checked = True ) else : property_instance = Property ( name = name , property_parameters = property_parameters , value = value , parent = self ) self . set_property ( property_instance , None , property_map_was_checked = True ) return property_instance def _instantiate_component ( self , ical_component_identifier : str ) -> \"Component\" : component_mapping = self . _get_child_component_mapping () if ical_component_identifier in component_mapping : var_name , var_type , is_list = component_mapping [ ical_component_identifier ] return var_type ( parent = self ) # type: ignore else : return Component ( name = ical_component_identifier , parent = self ) def parse_component ( self , lines : List [ str ], line_number : int ) -> int : \"\"\" Parse the raw lines representing this component (which was just instantiated). Based on the first line that starts with `BEGIN:`, we know using *self._get_child_component_mapping()* which specific component type we should instantiate. We then add it to the current component instance as a child. Then we parse line by line, if we find another `BEGIN:`, we create another component instance and proceed to calling :function:`self.parse_component` for parsing all the lines related to that component. If we find a property line (any line that doesn't start with `BEGIN:`), we call :function:`self.parse_property` which then automatically adds it to the current instance. :param lines: A list of all the lines in the iCalendar file. :param line_number: The line number at which this component starts. :return: The line number at which this component ends. \"\"\" self . _parse_line_start = line_number - 1 while not ( current_line := lines [ line_number ]) . startswith ( \"END:\" ): line_number += 1 if current_line . startswith ( \"BEGIN:\" ): component_name = current_line [ len ( \"BEGIN:\" ) :] instance = self . _instantiate_component ( component_name ) self . add_child ( instance ) line_number = instance . parse_component ( lines = lines , line_number = line_number ) continue full_line_without_line_breaks = current_line while ( next_line := lines [ line_number ]) . startswith ( \" \" ): line_number += 1 # [1:] so we skip the space indicating a line break. full_line_without_line_breaks += next_line [ 1 :] self . parse_property ( full_line_without_line_breaks ) if current_line != f \"END: { self . name } \" : raise ValueError ( f \"Expected { current_line =} to be equal to END: { self . name } . It seems { self } was never closed.\" ) self . _parse_line_end = line_number + 1 return line_number + 1","title":"Component"},{"location":"code/components/base_class/#ical_library.base_classes.Component.children","text":"Return all children components.","title":"children"},{"location":"code/components/base_class/#ical_library.base_classes.Component.extra_child_components","text":"Return all children components that are considered as x-comp or iana-comp components.","title":"extra_child_components"},{"location":"code/components/base_class/#ical_library.base_classes.Component.extra_properties","text":"Return all properties that are considered as x-prop or iana-prop properties.","title":"extra_properties"},{"location":"code/components/base_class/#ical_library.base_classes.Component.original_ical_text","text":"Return the original iCAL text for your property from the RAW string list as if it is a property.","title":"original_ical_text"},{"location":"code/components/base_class/#ical_library.base_classes.Component.properties","text":"Return all iCalendar properties of this component instance.","title":"properties"},{"location":"code/components/base_class/#ical_library.base_classes.Component.tree_root","text":"Return the tree root which should always be a VCalendar object.","title":"tree_root"},{"location":"code/components/base_class/#ical_library.base_classes.Component.__add_child_without_setting_the_parent","text":"Just add a child component and do not also set the parent. If the child is an undefined x-comp or iana-comp component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function: self._get_child_component_mapping() . Source code in ical_library/base_classes/component.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def __add_child_without_setting_the_parent ( self , child : \"Component\" ) -> None : \"\"\" Just add a child component and do not also set the parent. If the child is an undefined `x-comp` or `iana-comp` component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function:`self._get_child_component_mapping()`. \"\"\" child_component_mapping = self . _get_child_component_mapping () if child . name in child_component_mapping : var_name , var_type , is_list = child_component_mapping [ child . name ] getattr ( self , var_name ) . append ( child ) return self . _extra_child_components [ child . name ] . append ( child )","title":"__add_child_without_setting_the_parent"},{"location":"code/components/base_class/#ical_library.base_classes.Component.__enter__","text":"Enter the context manager. Check ComponentContext for more info. Source code in ical_library/base_classes/component.py 78 79 80 81 def __enter__ ( self ): \"\"\"Enter the context manager. Check ComponentContext for more info.\"\"\" ComponentContext . push_context_managed_component ( self ) return self","title":"__enter__"},{"location":"code/components/base_class/#ical_library.base_classes.Component.__exit__","text":"Exit the context manager. Check ComponentContext for more info. Source code in ical_library/base_classes/component.py 83 84 85 def __exit__ ( self , _type , _value , _tb ): \"\"\"Exit the context manager. Check ComponentContext for more info.\"\"\" ComponentContext . pop_context_managed_component ()","title":"__exit__"},{"location":"code/components/base_class/#ical_library.base_classes.Component._extract_ical_class_from_args","text":"Given a_type , which is either a List or an Optional, return the subtype that is not None. Note: When we execute get_args(some_type), we consider the result to be the subtypes. Parameters: Name Type Description Default var_name str The variable name of the type we are dissecting. required a_type Union [ Type [ List ], type ( Union )] The type we want to get the subtype of. required Returns: Type Description Type The subtype that is not equal to the NoneType. Source code in ical_library/base_classes/component.py 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @staticmethod def _extract_ical_class_from_args ( var_name : str , a_type : Union [ Type [ List ], type ( Union )]) -> Type : \"\"\" Given *a_type*, which is either a List or an Optional, return the subtype that is not None. Note: When we execute get_args(some_type), we consider the result to be the subtypes. :param var_name: The variable name of the type we are dissecting. :param a_type: The type we want to get the subtype of. :return: The subtype that is not equal to the NoneType. :raise: TypeError when there is no subtype that does not contain a type that is not equal to NoneType. \"\"\" sub_types : List [ Type ] = [ st for st in get_args ( a_type ) if not issubclass ( get_origin ( st ) or st , type ( None ))] if len ( sub_types ) != 1 : raise TypeError ( f \"Incorrect number of sub_types to follow here for { var_name =} , { a_type =} , { sub_types =} .\" ) return sub_types [ 0 ]","title":"_extract_ical_class_from_args"},{"location":"code/components/base_class/#ical_library.base_classes.Component._extract_type_information","text":"Extract typing information for an instance variable of the component. The type of the variable should either be (wrapping) a :class: Property or a :class: Component . Parameters: Name Type Description Default var_name str The variable name of the type we are dissecting. required a_type Type The type we want to extract a child class of :class: ICalBaseClass from. required is_in_list bool Whether the child class of :class: ICalBaseClass is contained in a List type. required Returns: Type Description Optional [ Tuple [ str , Tuple [ str , Optional [ Type [ ICalBaseClass ]], bool ]]] None if there is no child class of :class: ICalBaseClass we can detect. Otherwise, we return a tuple containing the iCal name (e.g. VEVENT) and another tuple that contains the variable name, the child class of :class: ICalBaseClass and a boolean whether that child class was wrapped in a List. Source code in ical_library/base_classes/component.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 @staticmethod def _extract_type_information ( var_name : str , a_type : Type , is_in_list : bool ) -> Optional [ Tuple [ str , Tuple [ str , Optional [ Type [ ICalBaseClass ]], bool ]]]: \"\"\" Extract typing information for an instance variable of the component. The type of the variable should either be (wrapping) a :class:`Property` or a :class:`Component`. :param var_name: The variable name of the type we are dissecting. :param a_type: The type we want to extract a child class of :class:`ICalBaseClass` from. :param is_in_list: Whether the child class of :class:`ICalBaseClass` is contained in a List type. :return: None if there is no child class of :class:`ICalBaseClass` we can detect. Otherwise, we return a tuple containing the iCal name (e.g. VEVENT) and another tuple that contains the variable name, the child class of :class:`ICalBaseClass` and a boolean whether that child class was wrapped in a List. :raise: TypeError if there is no child class of :class:`ICalBaseClass` to detect. \"\"\" if get_origin ( a_type ) is None : if issubclass ( a_type , ICalBaseClass ): return a_type . get_ical_name_of_class (), ( var_name , a_type , is_in_list ) return None elif get_origin ( a_type ) == Union : # This also covers the Optional case. sub_class = Component . _extract_ical_class_from_args ( var_name , a_type ) return Component . _extract_type_information ( var_name , sub_class , is_in_list ) elif issubclass ( get_origin ( a_type ), List ): sub_class = Component . _extract_ical_class_from_args ( var_name , a_type ) return Component . _extract_type_information ( var_name , sub_class , True ) elif get_origin ( a_type ) == ClassVar : return None else : raise TypeError ( f \"Unknown type ' { a_type } ' came by in Component.extract_custom_type.\" )","title":"_extract_type_information"},{"location":"code/components/base_class/#ical_library.base_classes.Component._get_child_component_mapping","text":"Return the same mapping as :function: cls._get_var_mapping() but only return variables related to :class: Component classes. Source code in ical_library/base_classes/component.py 272 273 274 275 276 277 278 279 280 281 282 283 @classmethod @lru_cache () def _get_child_component_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ \"Component\" ], bool ]]: \"\"\" Return the same mapping as :function:`cls._get_var_mapping()` but only return variables related to :class:`Component` classes. \"\"\" return { ical_name : var_tuple for ical_name , var_tuple in cls . _get_var_mapping () . items () if issubclass ( var_tuple [ 1 ], Component ) }","title":"_get_child_component_mapping"},{"location":"code/components/base_class/#ical_library.base_classes.Component._get_init_method_for_var_mapping","text":"We generate _get_var_mapping based on cls.__init__ . This var mapping is later used to list all properties, all components but also all the types of the items. This is a function so that it can be overwritten for the recurring components. Source code in ical_library/base_classes/component.py 228 229 230 231 232 233 234 235 @classmethod def _get_init_method_for_var_mapping ( cls ) -> Callable : \"\"\" We generate _get_var_mapping based on `cls.__init__`. This var mapping is later used to list all properties, all components but also all the types of the items. This is a function so that it can be overwritten for the recurring components. \"\"\" return cls . __init__","title":"_get_init_method_for_var_mapping"},{"location":"code/components/base_class/#ical_library.base_classes.Component._get_property_mapping","text":"Return the same mapping as :function: cls._get_var_mapping() but only return variables related to :class: Property classes. Example: {\"RRULE\": tuple(\"rrule\", Type[RRule], False), ...} Source code in ical_library/base_classes/component.py 259 260 261 262 263 264 265 266 267 268 269 270 @classmethod @lru_cache () def _get_property_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ Property ], bool ]]: \"\"\" Return the same mapping as :function:`cls._get_var_mapping()` but only return variables related to :class:`Property` classes. Example: `{\"RRULE\": tuple(\"rrule\", Type[RRule], False), ...}` \"\"\" return { ical_name : var_tuple for ical_name , var_tuple in cls . _get_var_mapping () . items () if issubclass ( var_tuple [ 1 ], Property ) }","title":"_get_property_mapping"},{"location":"code/components/base_class/#ical_library.base_classes.Component._get_var_mapping","text":"Get a mapping of all variables of this class that do not start with _ . Returns: Type Description Mapping [ str , Tuple [ str , Type [ ICalBaseClass ], bool ]] A class mapping that maps the iCal name (e.g. VEVENT) to another tuple that contains the variable name, the child class of :class: ICalBaseClass and a boolean whether that child class was wrapped in a List. Source code in ical_library/base_classes/component.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 @classmethod @lru_cache () def _get_var_mapping ( cls ) -> Mapping [ str , Tuple [ str , Type [ ICalBaseClass ], bool ]]: \"\"\" Get a mapping of all variables of this class that do not start with `_`. :return: A class mapping that maps the iCal name (e.g. VEVENT) to another tuple that contains the variable name, the child class of :class:`ICalBaseClass` and a boolean whether that child class was wrapped in a List. \"\"\" var_mapping : Dict [ str , Tuple [ str , Type [ ICalBaseClass ], bool ]] = {} a_field : inspect . Parameter for a_field in inspect . signature ( cls . _get_init_method_for_var_mapping ()) . parameters . values (): if a_field . name . startswith ( \"_\" ) or a_field . name in [ \"self\" , \"parent\" , \"name\" ]: continue result = Component . _extract_type_information ( a_field . name , a_field . annotation , False ) if result is None : continue ical_name , var_type_info = result if issubclass ( var_type_info [ 1 ], ICalBaseClass ): var_mapping [ ical_name ] = var_type_info return var_mapping","title":"_get_var_mapping"},{"location":"code/components/base_class/#ical_library.base_classes.Component._set_self_as_parent_for_ical_component","text":"Verifies the parent is not already set to a different component, if not sets the parent. Source code in ical_library/base_classes/component.py 87 88 89 90 91 92 93 94 def _set_self_as_parent_for_ical_component ( self , prop_or_comp : ICalBaseClass ) -> None : \"\"\"Verifies the parent is not already set to a different component, if not sets the parent.\"\"\" if prop_or_comp . parent is None : prop_or_comp . parent = self elif prop_or_comp . parent != self : raise ValueError ( \"Trying to overwrite a parent. Please do not re-use property instance across different components.\" )","title":"_set_self_as_parent_for_ical_component"},{"location":"code/components/base_class/#ical_library.base_classes.Component.add_child","text":"Add a children component and set its parent. If the child is an undefined x-comp or iana-comp component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function: self._get_child_component_mapping() . Source code in ical_library/base_classes/component.py 157 158 159 160 161 162 163 164 165 166 def add_child ( self , child : \"Component\" ) -> None : \"\"\" Add a children component and set its parent. If the child is an undefined `x-comp` or `iana-comp` component, we add it to _extra_child_components. If the child is defined, we add it to one of the other variables according to :function:`self._get_child_component_mapping()`. \"\"\" self . as_parent ( child ) self . __add_child_without_setting_the_parent ( child )","title":"add_child"},{"location":"code/components/base_class/#ical_library.base_classes.Component.as_parent","text":"We set self as Parent for Properties and Components but also Properties and Components in lists. Source code in ical_library/base_classes/component.py 96 97 98 99 100 101 102 103 104 def as_parent ( self , value : T ) -> T : \"\"\"We set self as Parent for Properties and Components but also Properties and Components in lists.\"\"\" if isinstance ( value , ICalBaseClass ): self . _set_self_as_parent_for_ical_component ( value ) elif isinstance ( value , list ): # checking for list over Iterable is ~8,5x faster. for item in value : if isinstance ( item , ICalBaseClass ): self . _set_self_as_parent_for_ical_component ( item ) return value","title":"as_parent"},{"location":"code/components/base_class/#ical_library.base_classes.Component.get_property_ical_names","text":"Get all the variables for this component class that reference a :class: Property in the typing information. Source code in ical_library/base_classes/component.py 173 174 175 176 177 178 179 @classmethod @lru_cache () def get_property_ical_names ( cls ) -> Set [ str ]: \"\"\" Get all the variables for this component class that reference a :class:`Property` in the typing information. \"\"\" return { var_name for var_name , var_type , is_list in cls . _get_property_mapping () . values ()}","title":"get_property_ical_names"},{"location":"code/components/base_class/#ical_library.base_classes.Component.parse_component","text":"Parse the raw lines representing this component (which was just instantiated). Based on the first line that starts with BEGIN: , we know using self._get_child_component_mapping() which specific component type we should instantiate. We then add it to the current component instance as a child. Then we parse line by line, if we find another BEGIN: , we create another component instance and proceed to calling :function: self.parse_component for parsing all the lines related to that component. If we find a property line (any line that doesn't start with BEGIN: ), we call :function: self.parse_property which then automatically adds it to the current instance. Parameters: Name Type Description Default lines List [ str ] A list of all the lines in the iCalendar file. required line_number int The line number at which this component starts. required Returns: Type Description int The line number at which this component ends. Source code in ical_library/base_classes/component.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 def parse_component ( self , lines : List [ str ], line_number : int ) -> int : \"\"\" Parse the raw lines representing this component (which was just instantiated). Based on the first line that starts with `BEGIN:`, we know using *self._get_child_component_mapping()* which specific component type we should instantiate. We then add it to the current component instance as a child. Then we parse line by line, if we find another `BEGIN:`, we create another component instance and proceed to calling :function:`self.parse_component` for parsing all the lines related to that component. If we find a property line (any line that doesn't start with `BEGIN:`), we call :function:`self.parse_property` which then automatically adds it to the current instance. :param lines: A list of all the lines in the iCalendar file. :param line_number: The line number at which this component starts. :return: The line number at which this component ends. \"\"\" self . _parse_line_start = line_number - 1 while not ( current_line := lines [ line_number ]) . startswith ( \"END:\" ): line_number += 1 if current_line . startswith ( \"BEGIN:\" ): component_name = current_line [ len ( \"BEGIN:\" ) :] instance = self . _instantiate_component ( component_name ) self . add_child ( instance ) line_number = instance . parse_component ( lines = lines , line_number = line_number ) continue full_line_without_line_breaks = current_line while ( next_line := lines [ line_number ]) . startswith ( \" \" ): line_number += 1 # [1:] so we skip the space indicating a line break. full_line_without_line_breaks += next_line [ 1 :] self . parse_property ( full_line_without_line_breaks ) if current_line != f \"END: { self . name } \" : raise ValueError ( f \"Expected { current_line =} to be equal to END: { self . name } . It seems { self } was never closed.\" ) self . _parse_line_end = line_number + 1 return line_number + 1","title":"parse_component"},{"location":"code/components/base_class/#ical_library.base_classes.Component.parse_property","text":"Parse a raw line containing a :class: Property definition, instantiate the corresponding Property and set the variable. Based on the first part of the line (before the ; and :), we know using self._get_property_mapping() which property type we should instantiate. Then, depending on whether the typing info of the property denoted it in a List or not, it adds it to a list/instantiates the list, compared to simply setting it as the variable of the :class: Component instance. Credits for the excellent regex parsing string go to @Jan Goyvaerts: https://stackoverflow.com/a/2482067/2277445 Parameters: Name Type Description Default line str The entire line that contains the property string (meaning multi-lines properties are already converted to a single line here). required Returns: Type Description Property The created Property instance based on the line that we set for the component. Source code in ical_library/base_classes/component.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def parse_property ( self , line : str ) -> Property : \"\"\" Parse a raw line containing a :class:`Property` definition, instantiate the corresponding Property and set the variable. Based on the first part of the line (before the ; and :), we know using *self._get_property_mapping()* which property type we should instantiate. Then, depending on whether the typing info of the property denoted it in a List or not, it adds it to a list/instantiates the list, compared to simply setting it as the variable of the :class:`Component` instance. Credits for the excellent regex parsing string go to @Jan Goyvaerts: https://stackoverflow.com/a/2482067/2277445 :param line: The entire line that contains the property string (meaning multi-lines properties are already converted to a single line here). :return: The created Property instance based on the *line* that we set for the component. \"\"\" property_mapping = self . _get_property_mapping () result = re . search ( \"^([^ \\r\\n ;:]+)(;[^ \\r\\n :]+)?:(.*)$\" , line ) if result is None : raise ValueError ( f \" { result =} should never be None! { line =} is invalid.\" ) name , property_parameters , value = result . group ( 1 ), result . group ( 2 ), result . group ( 3 ) property_parameters = property_parameters . lstrip ( \";\" ) if property_parameters else None if name in property_mapping . keys (): property_map_info = property_mapping [ name ] var_name , var_type , is_list = property_map_info property_instance = var_type ( name = name , property_parameters = property_parameters , value = value , parent = self ) self . set_property ( property_instance , property_map_info , property_map_was_checked = True ) else : property_instance = Property ( name = name , property_parameters = property_parameters , value = value , parent = self ) self . set_property ( property_instance , None , property_map_was_checked = True ) return property_instance","title":"parse_property"},{"location":"code/components/base_class/#ical_library.base_classes.Component.print_tree_structure","text":"Print the tree structure of all components starting with this instance. Source code in ical_library/base_classes/component.py 295 296 297 298 299 def print_tree_structure ( self , indent : int = 0 ) -> None : \"\"\"Print the tree structure of all components starting with this instance.\"\"\" print ( f \" { ' ' * indent } - { self } \" ) for child in self . children : child . print_tree_structure ( indent = indent + 1 )","title":"print_tree_structure"},{"location":"code/components/base_class/#ical_library.base_classes.Component.set_property","text":"Setting a property for a Component instance. If the property_map_info is equal to None, we either have not yet looked up all the properties or it is an x-prop/iana-prop. This can be decided based on property_map_was_checked. This avoids extra (expensive) lookups in our self._get_property_mapping. Parameters: Name Type Description Default property_instance Property The Property we wish to set. required property_map_info Optional [ Tuple [ str , Type [ Property ], bool ]] A tuple containing the variable name for this Component instance, the type of the Property and whether the variable can occur multiple times for the same property. If it equals None, this either means it is an x-prop/iana-prop or that the property_map was not checked yet. None property_map_was_checked bool Whether the property_map_info was passed or not. If True, and property_map_info is None , we know that it is an iana property. If False, we still need to consult _get_property_mapping . False Source code in ical_library/base_classes/component.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 def set_property ( self , property_instance : Property , property_map_info : Optional [ Tuple [ str , Type [ Property ], bool ]] = None , property_map_was_checked : bool = False , ) -> None : \"\"\" Setting a property for a Component instance. If the `property_map_info` is equal to None, we either have not yet looked up all the properties or it is an x-prop/iana-prop. This can be decided based on property_map_was_checked. This avoids extra (expensive) lookups in our self._get_property_mapping. :param property_instance: The Property we wish to set. :param property_map_info: A tuple containing the variable name for this Component instance, the type of the Property and whether the variable can occur multiple times for the same property. If it equals None, this either means it is an x-prop/iana-prop or that the property_map was not checked yet. :param property_map_was_checked: Whether the `property_map_info` was passed or not. If True, and `property_map_info` is `None`, we know that it is an iana property. If False, we still need to consult `_get_property_mapping`. \"\"\" if property_map_info is None and property_map_was_checked is False : property_map_info = self . _get_property_mapping () . get ( property_instance . name ) var_name , var_type , is_list = property_map_info or [ None , None , None ] if var_name is not None and is_list is not None : if is_list is True : if getattr ( self , var_name ) is None : setattr ( self , var_name , [ property_instance ]) else : current_value : List [ Property ] = getattr ( self , var_name ) current_value . append ( property_instance ) else : setattr ( self , var_name , property_instance ) else : self . _extra_properties [ property_instance . name . lower () . replace ( \"-\" , \"_\" )] . append ( property_instance )","title":"set_property"},{"location":"code/components/base_class/#ical_library.help_modules.component_context.ComponentContext","text":"Component context is used to keep the current Component when Component is used as ContextManager. You can use components as context: with Component () as my_component : . If you do this the context stores the Component and whenever a new component or property is created, it will use such stored Component as the parent Component. Source code in ical_library/help_modules/component_context.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class ComponentContext : \"\"\" Component context is used to keep the current Component when Component is used as ContextManager. You can use components as context: `#!py3 with Component() as my_component:`. If you do this the context stores the Component and whenever a new component or property is created, it will use such stored Component as the parent Component. \"\"\" _context_managed_component : Optional [ \"Component\" ] = None _previous_context_managed_components : List [ \"Component\" ] = [] @classmethod def push_context_managed_component ( cls , component : \"Component\" ): \"\"\"Set the current context managed component.\"\"\" if cls . _context_managed_component : cls . _previous_context_managed_components . append ( cls . _context_managed_component ) cls . _context_managed_component = component @classmethod def pop_context_managed_component ( cls ) -> Optional [ \"Component\" ]: \"\"\"Pop the current context managed component.\"\"\" old_component = cls . _context_managed_component if cls . _previous_context_managed_components : cls . _context_managed_component = cls . _previous_context_managed_components . pop () else : cls . _context_managed_component = None return old_component @classmethod def get_current_component ( cls ) -> Optional [ \"Component\" ]: \"\"\"Get the current context managed component.\"\"\" return cls . _context_managed_component","title":"ComponentContext"},{"location":"code/components/base_class/#ical_library.help_modules.component_context.ComponentContext.get_current_component","text":"Get the current context managed component. Source code in ical_library/help_modules/component_context.py 37 38 39 40 @classmethod def get_current_component ( cls ) -> Optional [ \"Component\" ]: \"\"\"Get the current context managed component.\"\"\" return cls . _context_managed_component","title":"get_current_component"},{"location":"code/components/base_class/#ical_library.help_modules.component_context.ComponentContext.pop_context_managed_component","text":"Pop the current context managed component. Source code in ical_library/help_modules/component_context.py 27 28 29 30 31 32 33 34 35 @classmethod def pop_context_managed_component ( cls ) -> Optional [ \"Component\" ]: \"\"\"Pop the current context managed component.\"\"\" old_component = cls . _context_managed_component if cls . _previous_context_managed_components : cls . _context_managed_component = cls . _previous_context_managed_components . pop () else : cls . _context_managed_component = None return old_component","title":"pop_context_managed_component"},{"location":"code/components/base_class/#ical_library.help_modules.component_context.ComponentContext.push_context_managed_component","text":"Set the current context managed component. Source code in ical_library/help_modules/component_context.py 20 21 22 23 24 25 @classmethod def push_context_managed_component ( cls , component : \"Component\" ): \"\"\"Set the current context managed component.\"\"\" if cls . _context_managed_component : cls . _previous_context_managed_components . append ( cls . _context_managed_component ) cls . _context_managed_component = component","title":"push_context_managed_component"},{"location":"code/components/recurring_components/","text":"Recurring components These are the components that have the possibility to be recurring. For each of them there is their standard class and their recurring class. The idea is that the original definition is represented by the standard class and any occurrence that is generated based on the recurring properties, is represented by the recurring class. Given all classes that have recurring options have a major overlap, there are two class abstracting the complexity away from them. This is again in the same concept, where the first one covers the standard class, and the other one covers the recurring class. These two are listed here first before the rest. AbstractComponentWithRecurringProperties Bases: Component , ABC This class helps avoid code repetition with different :class: Component classes that have a duration and have recurring properties. This class is inherited by VEvent, VToDo and VJournal as these all have recurring properties like :class: RRule , :class: RDate and :class: EXDate . All properties they had in common are part of this class. Note: VJournal is the odd one out as these events don't have a duration. Parameters: Name Type Description Default name str The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None dtstart Optional [ DTStart ] The DTStart property. Optional and may occur at most once. None rrule Optional [ RRule ] The RRule property. Optional and may occur at most once. None summary Optional [ Summary ] The Summary property. Optional and may occur at most once. None exdate Optional [ List [ EXDate ]] The EXDate property. Optional, but may occur multiple times. None rdate Optional [ List [ RDate ]] The RDate property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/abstract_components.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 class AbstractComponentWithRecurringProperties ( Component , ABC ): \"\"\" This class helps avoid code repetition with different :class:`Component` classes that have a duration and have recurring properties. This class is inherited by VEvent, VToDo and VJournal as these all have recurring properties like :class:`RRule`, :class:`RDate` and :class:`EXDate`. All properties they had in common are part of this class. Note: VJournal is the odd one out as these events don't have a duration. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param dtstart: The DTStart property. Optional and may occur at most once. :param rrule: The RRule property. Optional and may occur at most once. :param summary: The Summary property. Optional and may occur at most once. :param exdate: The EXDate property. Optional, but may occur multiple times. :param rdate: The RDate property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , name : str , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , dtstart : Optional [ DTStart ] = None , rrule : Optional [ RRule ] = None , summary : Optional [ Summary ] = None , recurrence_id : Optional [ RecurrenceID ] = None , exdate : Optional [ List [ EXDate ]] = None , rdate : Optional [ List [ RDate ]] = None , comment : Optional [ List [ Comment ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( name , parent = parent ) # Required self . _dtstamp : Optional [ DTStamp ] = self . as_parent ( dtstamp ) self . _uid : Optional [ UID ] = self . as_parent ( uid ) # Optional, may only occur once self . dtstart : Optional [ DTStart ] = self . as_parent ( dtstart ) self . rrule : Optional [ RRule ] = self . as_parent ( rrule ) self . summary : Optional [ Summary ] = self . as_parent ( summary ) self . recurrence_id : Optional [ RecurrenceID ] = self . as_parent ( recurrence_id ) # Optional, may occur more than once self . exdate : Optional [ List [ EXDate ]] = self . as_parent ( exdate ) self . rdate : Optional [ List [ RDate ]] = self . as_parent ( rdate ) self . comment : Optional [ List [ Comment ]] = self . as_parent ( comment ) @property def dtstamp ( self ) -> DTStamp : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _dtstamp is None : raise MissingRequiredProperty ( self , \"dtstamp\" ) return self . _dtstamp @dtstamp . setter def dtstamp ( self , value : DTStamp ): \"\"\"A setter to set the required property.\"\"\" self . _dtstamp = value @property def uid ( self ) -> UID : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _uid is None : raise MissingRequiredProperty ( self , \"uid\" ) return self . _uid @uid . setter def uid ( self , value : UID ): \"\"\"A setter to set the required property.\"\"\" self . _uid = value @property @abstractmethod def ending ( self ) -> _DTBoth : \"\"\" As the argument for this is different in each class, we ask this to be implemented. :return: The ending of the :class:`Component`, except for :class:`VJournal` which returns the start. \"\"\" pass @abstractmethod def get_duration ( self ) -> Optional [ Duration ]: \"\"\" As the duration is not present in each of them, we ask this to be implemented by the subclasses. :return: The duration of the :class:`Component`. \"\"\" pass @abstractmethod def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this component in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VToDo instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VToDo instances related to this VToDo in the given *return_range*. \"\"\" pass def __eq__ ( self : \"AbstractComponentWithRecurringProperties\" , other : \"AbstractComponentWithRecurringProperties\" ) -> bool : \"\"\"Return whether the current instance and the other instance are the same.\"\"\" if type ( self ) != type ( other ): return False return ( self . dtstart == other . dtstart and self . ending == other . ending and self . summary == other . summary and self . comment == other . comment ) @property def timespan ( self ) -> Optional [ TimespanWithParent ]: \"\"\" Return a timespan as a property representing the start and end of the instance. :return: A timespan instance with this class instance as parent. \"\"\" if self . start is None : return None if self . end is None : TimespanWithParent ( parent = self , begin = self . start , end = self . start ) return TimespanWithParent ( parent = self , begin = self . start , end = self . end ) @property @instance_lru_cache () def start ( self ) -> Optional [ Union [ Date , DateTime ]]: \"\"\"Return the start of this Component as a :class:`Date` or :class:`DateTime` value.\"\"\" return self . dtstart . datetime_or_date_value if self . dtstart else None @property @instance_lru_cache () def end ( self ) -> Optional [ Union [ Date , DateTime ]]: \"\"\"Return the ending of this Component as a Date or DateTime value.\"\"\" if self . ending : return self . ending . datetime_or_date_value elif self . start and self . get_duration (): return self . start + self . get_duration () return None @property @instance_lru_cache () def computed_duration ( self : \"AbstractComponentWithRecurringProperties\" ) -> Optional [ Duration ]: \"\"\"Return the duration of this Component as a :class:`Date` or :class:`DateTime` value.\"\"\" if a_duration := self . get_duration (): return a_duration elif self . end and self . start : result : Period = self . end - self . start return result return None @property @instance_lru_cache () def max_recurring_timespan ( self ) -> Optional [ Timespan ]: if not self . start or not self . computed_duration : return None if not self . rrule and not self . rdate : return self . timespan max_dt : DateTime = DateTime . min if self . rdate : max_dt = max ( max_dt , max ([ rdate . compute_max_end_date ( self . computed_duration ) for rdate in self . rdate ])) if self . rrule : max_dt = max ( max_dt , self . rrule . compute_max_end_date ( self . start , self . computed_duration )) if max_dt != DateTime . min : return Timespan ( self . start , max_dt ) return None computed_duration : Optional [ Duration ] property Return the duration of this Component as a :class: Date or :class: DateTime value. dtstamp : DTStamp property writable A getter to ensure the required property is set. end : Optional [ Union [ Date , DateTime ]] property Return the ending of this Component as a Date or DateTime value. ending : _DTBoth abstractmethod property As the argument for this is different in each class, we ask this to be implemented. Returns: Type Description The ending of the :class: Component , except for :class: VJournal which returns the start. start : Optional [ Union [ Date , DateTime ]] property Return the start of this Component as a :class: Date or :class: DateTime value. timespan : Optional [ TimespanWithParent ] property Return a timespan as a property representing the start and end of the instance. Returns: Type Description A timespan instance with this class instance as parent. uid : UID property writable A getter to ensure the required property is set. expand_component_in_range ( return_range , starts_to_exclude ) abstractmethod Expand this component in range according to its recurring RDate , EXDate and RRule properties. Parameters: Name Type Description Default return_range Timespan The timespan range on which we should return VToDo instances. required starts_to_exclude Union [ List [ Date ], List [ DateTime ]] List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). required Returns: Type Description Iterator [ TimespanWithParent ] Yield all recurring VToDo instances related to this VToDo in the given return_range . Source code in ical_library/ical_components/abstract_components.py 111 112 113 114 115 116 117 118 119 120 121 122 @abstractmethod def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this component in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VToDo instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VToDo instances related to this VToDo in the given *return_range*. \"\"\" pass get_duration () abstractmethod As the duration is not present in each of them, we ask this to be implemented by the subclasses. Returns: Type Description Optional [ Duration ] The duration of the :class: Component . Source code in ical_library/ical_components/abstract_components.py 102 103 104 105 106 107 108 109 @abstractmethod def get_duration ( self ) -> Optional [ Duration ]: \"\"\" As the duration is not present in each of them, we ask this to be implemented by the subclasses. :return: The duration of the :class:`Component`. \"\"\" pass AbstractRecurrence Bases: AbstractComponentWithRecurringProperties , ABC This class extends :class: AbstractComponentWithRecurringProperties to represent a recurring Component. This class is inherited by VRecurringEvent, VRecurringToDo and VRecurringJournal. When we compute the recurrence based on the :class: RRule , :class: RDate and :class: EXDate properties, we create new occurrences of that specific component. Instead of copying over all Properties (and using a lot of memory), this class overwrites the getattribute function to act like the original component for most attributes except for start , end , original and parent . Source code in ical_library/ical_components/abstract_components.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 class AbstractRecurrence ( AbstractComponentWithRecurringProperties , ABC ): \"\"\" This class extends :class:`AbstractComponentWithRecurringProperties` to represent a recurring Component. This class is inherited by VRecurringEvent, VRecurringToDo and VRecurringJournal. When we compute the recurrence based on the :class:`RRule`, :class:`RDate` and :class:`EXDate` properties, we create new occurrences of that specific component. Instead of copying over all Properties (and using a lot of memory), this class overwrites the *__getattribute__* function to act like the original component for most attributes except for *start*, *end*, *original* and *parent*. \"\"\" def __getattribute__ ( self , var_name : str ) -> Any : \"\"\" Overwrite this function to return the originals properties except for *start*, *end*, *original* and *parent*. Depending on the attributes *name* we are requesting, we either return its own properties or the original components properties. This way we don't need to copy over all the variables. :param var_name: Name of the attribute we are accessing. :return: The value of the attribute we are accessing either from the *original* or from this instance itself. \"\"\" if var_name in ( \"_start\" , \"_end\" , \"_original\" , \"_parent\" , \"start\" , \"end\" , \"original\" , \"parent\" ): return object . __getattribute__ ( self , var_name ) if var_name in ( \"_name\" , \"_extra_child_components\" , \"_extra_properties\" ): return object . __getattribute__ ( self . _original , var_name ) if var_name in self . _original . get_property_ical_names (): return object . __getattribute__ ( self . _original , var_name ) return object . __getattribute__ ( self , var_name ) def __setattr__ ( self , key : str , value : Any ) -> None : \"\"\"Overwrite the custom __setattr__ from Components to set it back to the standard behavior.\"\"\" object . __setattr__ ( self , key , value ) @property def start ( self ) -> DateTime : \"\"\"Return the start of this recurring event.\"\"\" return self . _start @property def end ( self ) -> DateTime : \"\"\"Return the end of this recurring event.\"\"\" return self . _end @property def original ( self ) -> AbstractComponentWithRecurringProperties : \"\"\"Return the original component that created this recurring component.\"\"\" return self . _original @property def parent ( self ) -> Component : \"\"\"Return the parent of the original component.\"\"\" return self . _original . parent end : DateTime property Return the end of this recurring event. original : AbstractComponentWithRecurringProperties property Return the original component that created this recurring component. parent : Component property Return the parent of the original component. start : DateTime property Return the start of this recurring event. __getattribute__ ( var_name ) Overwrite this function to return the originals properties except for start , end , original and parent . Depending on the attributes name we are requesting, we either return its own properties or the original components properties. This way we don't need to copy over all the variables. Parameters: Name Type Description Default var_name str Name of the attribute we are accessing. required Returns: Type Description Any The value of the attribute we are accessing either from the original or from this instance itself. Source code in ical_library/ical_components/abstract_components.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def __getattribute__ ( self , var_name : str ) -> Any : \"\"\" Overwrite this function to return the originals properties except for *start*, *end*, *original* and *parent*. Depending on the attributes *name* we are requesting, we either return its own properties or the original components properties. This way we don't need to copy over all the variables. :param var_name: Name of the attribute we are accessing. :return: The value of the attribute we are accessing either from the *original* or from this instance itself. \"\"\" if var_name in ( \"_start\" , \"_end\" , \"_original\" , \"_parent\" , \"start\" , \"end\" , \"original\" , \"parent\" ): return object . __getattribute__ ( self , var_name ) if var_name in ( \"_name\" , \"_extra_child_components\" , \"_extra_properties\" ): return object . __getattribute__ ( self . _original , var_name ) if var_name in self . _original . get_property_ical_names (): return object . __getattribute__ ( self . _original , var_name ) return object . __getattribute__ ( self , var_name ) __setattr__ ( key , value ) Overwrite the custom setattr from Components to set it back to the standard behavior. Source code in ical_library/ical_components/abstract_components.py 221 222 223 def __setattr__ ( self , key : str , value : Any ) -> None : \"\"\"Overwrite the custom __setattr__ from Components to set it back to the standard behavior.\"\"\" object . __setattr__ ( self , key , value ) VEvent Bases: AbstractComponentWithRecurringProperties This class represents the VEVENT component specified in RFC 5545 in '3.6.1. Event Component'. A \"VEVENT\" calendar component is a grouping of component properties, possibly including \"VALARM\" calendar components, that represents a scheduled amount of time on a calendar. For example, it can be an activity; such as a one-hour long, department meeting from 8:00 AM to 9:00 AM, tomorrow. Generally, an event will take up time on an individual calendar. Hence, the event will appear as an opaque interval in a search for busy time. Alternately, the event can have its Time Transparency set to \"TRANSPARENT\" in order to prevent blocking of the event in searches for busy time. Parameters: Name Type Description Default name The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None dtstart Optional [ DTStart ] The DTStart property. Optional and may occur at most once. None rrule Optional [ RRule ] The RRule property. Optional and may occur at most once. None summary Optional [ Summary ] The Summary property. Optional and may occur at most once. None exdate Optional [ List [ EXDate ]] The EXDate property. Optional, but may occur multiple times. None rdate Optional [ List [ RDate ]] The RDate property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None ical_class Optional [ Class ] Optional Class property. Optional, but may occur at most once. None created Optional [ Created ] The Created property. Optional, but may occur at most once. None description Optional [ Description ] The Description property. Optional, but may occur at most once. None duration Optional [ ICALDuration ] The ICALDuration property. Optional, but may occur at most once. None geo Optional [ GEO ] The GEO property. Optional, but may occur at most once. None last_modified Optional [ LastModified ] Optional LastModified property. Optional, but may occur at most once. None location Optional [ Location ] The Location property. Optional, but may occur at most once. None organizer Optional [ Organizer ] The Organizer property. Optional, but may occur at most once. None priority Optional [ Priority ] The Priority property. Optional, but may occur at most once. None sequence Optional [ Sequence ] The Sequence property. Optional, but may occur at most once. None status Optional [ Status ] The Status property. Optional, but may occur at most once. None transp Optional [ TimeTransparency ] The TimeTransparency property. Optional, but may occur at most once. None url Optional [ URL ] The URL property. Optional, but may occur at most once. None recurrence_id Optional [ RecurrenceID ] Optional RecurrenceID property. Optional, but may occur at most once. None dtend Optional [ DTEnd ] The DTEnd property. Optional, but may occur at most once. None attach Optional [ List [ Attach ]] The Attach property. Optional, but may occur multiple times. None attendee Optional [ List [ Attendee ]] The Attendee property. Optional, but may occur multiple times. None categories Optional [ List [ Categories ]] The Categories property. Optional, but may occur multiple times. None contact Optional [ List [ Contact ]] The Contact property. Optional, but may occur multiple times. None rstatus Optional [ List [ RequestStatus ]] The RequestStatus property. Optional, but may occur multiple times. None related Optional [ List [ RelatedTo ]] The RelatedTo property. Optional, but may occur multiple times. None resources Optional [ List [ Resources ]] The Resources property. Optional, but may occur multiple times. None Source code in ical_library/ical_components/v_event.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 class VEvent ( AbstractComponentWithRecurringProperties ): \"\"\" This class represents the VEVENT component specified in RFC 5545 in '3.6.1. Event Component'. A \"VEVENT\" calendar component is a grouping of component properties, possibly including \"VALARM\" calendar components, that represents a scheduled amount of time on a calendar. For example, it can be an activity; such as a one-hour long, department meeting from 8:00 AM to 9:00 AM, tomorrow. Generally, an event will take up time on an individual calendar. Hence, the event will appear as an opaque interval in a search for busy time. Alternately, the event can have its Time Transparency set to \"TRANSPARENT\" in order to prevent blocking of the event in searches for busy time. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param parent: The Component this item is encapsulated by in the iCalendar data file. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param dtstart: The DTStart property. Optional and may occur at most once. :param rrule: The RRule property. Optional and may occur at most once. :param summary: The Summary property. Optional and may occur at most once. :param exdate: The EXDate property. Optional, but may occur multiple times. :param rdate: The RDate property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param ical_class: Optional Class property. Optional, but may occur at most once. :param created: The Created property. Optional, but may occur at most once. :param description: The Description property. Optional, but may occur at most once. :param duration: The ICALDuration property. Optional, but may occur at most once. :param geo: The GEO property. Optional, but may occur at most once. :param last_modified: Optional LastModified property. Optional, but may occur at most once. :param location: The Location property. Optional, but may occur at most once. :param organizer: The Organizer property. Optional, but may occur at most once. :param priority: The Priority property. Optional, but may occur at most once. :param sequence: The Sequence property. Optional, but may occur at most once. :param status: The Status property. Optional, but may occur at most once. :param transp: The TimeTransparency property. Optional, but may occur at most once. :param url: The URL property. Optional, but may occur at most once. :param recurrence_id: Optional RecurrenceID property. Optional, but may occur at most once. :param dtend: The DTEnd property. Optional, but may occur at most once. :param attach: The Attach property. Optional, but may occur multiple times. :param attendee: The Attendee property. Optional, but may occur multiple times. :param categories: The Categories property. Optional, but may occur multiple times. :param contact: The Contact property. Optional, but may occur multiple times. :param rstatus: The RequestStatus property. Optional, but may occur multiple times. :param related: The RelatedTo property. Optional, but may occur multiple times. :param resources: The Resources property. Optional, but may occur multiple times. \"\"\" def __init__ ( self , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , dtstart : Optional [ DTStart ] = None , rrule : Optional [ RRule ] = None , summary : Optional [ Summary ] = None , exdate : Optional [ List [ EXDate ]] = None , rdate : Optional [ List [ RDate ]] = None , comment : Optional [ List [ Comment ]] = None , ical_class : Optional [ Class ] = None , created : Optional [ Created ] = None , description : Optional [ Description ] = None , duration : Optional [ ICALDuration ] = None , geo : Optional [ GEO ] = None , last_modified : Optional [ LastModified ] = None , location : Optional [ Location ] = None , organizer : Optional [ Organizer ] = None , priority : Optional [ Priority ] = None , sequence : Optional [ Sequence ] = None , status : Optional [ Status ] = None , transp : Optional [ TimeTransparency ] = None , url : Optional [ URL ] = None , recurrence_id : Optional [ RecurrenceID ] = None , dtend : Optional [ DTEnd ] = None , attach : Optional [ List [ Attach ]] = None , attendee : Optional [ List [ Attendee ]] = None , categories : Optional [ List [ Categories ]] = None , contact : Optional [ List [ Contact ]] = None , rstatus : Optional [ List [ RequestStatus ]] = None , related : Optional [ List [ RelatedTo ]] = None , resources : Optional [ List [ Resources ]] = None , alarms : Optional [ List [ VAlarm ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( name = \"VEVENT\" , dtstamp = dtstamp , uid = uid , dtstart = dtstart , rrule = rrule , summary = summary , recurrence_id = recurrence_id , exdate = exdate , rdate = rdate , comment = comment , parent = parent , ) # Optional, may only occur once # As class is a reserved keyword in python, we prefixed it with `ical_`. self . ical_class : Optional [ Class ] = self . as_parent ( ical_class ) self . created : Optional [ Created ] = self . as_parent ( created ) self . description : Optional [ Description ] = self . as_parent ( description ) self . duration : Optional [ ICALDuration ] = self . as_parent ( duration ) self . geo : Optional [ GEO ] = self . as_parent ( geo ) self . last_modified : Optional [ LastModified ] = self . as_parent ( last_modified ) self . location : Optional [ Location ] = self . as_parent ( location ) self . organizer : Optional [ Organizer ] = self . as_parent ( organizer ) self . priority : Optional [ Priority ] = self . as_parent ( priority ) self . sequence : Optional [ Sequence ] = self . as_parent ( sequence ) self . status : Optional [ Status ] = self . as_parent ( status ) self . transp : Optional [ TimeTransparency ] = self . as_parent ( transp ) self . url : Optional [ URL ] = self . as_parent ( url ) self . dtend : Optional [ DTEnd ] = self . as_parent ( dtend ) # Optional, may occur more than once self . attach : Optional [ List [ Attach ]] = self . as_parent ( attach ) self . attendee : Optional [ List [ Attendee ]] = self . as_parent ( attendee ) self . categories : Optional [ List [ Categories ]] = self . as_parent ( categories ) self . contact : Optional [ List [ Contact ]] = self . as_parent ( contact ) self . rstatus : Optional [ List [ RequestStatus ]] = self . as_parent ( rstatus ) self . related : Optional [ List [ RelatedTo ]] = self . as_parent ( related ) self . resources : Optional [ List [ Resources ]] = self . as_parent ( resources ) # This is a child component self . alarms : List [ VAlarm ] = alarms or [] def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" if self . dtstart and self . dtend : return f \"VEvent( { self . start } - { self . end } : { self . summary . value if self . summary else '' } )\" else : return f \"VEvent( { self . summary . value if self . summary else '' } )\" @property def ending ( self ) -> Optional [ _DTBoth ]: \"\"\" Return the ending of the event. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . dtend def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return the duration of the event. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . duration . duration if self . duration else None def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VEvent in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VEvent instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we should exclude as they were defined in EXDATE, have already been returned or have been completely redefined in another element. :return: Yield all recurring VEvent instances related to this VEvent in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = start , first_event_duration = duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringEvent ( original_component_instance = self , start = event_start_time , end = event_end_time , ) . timespan ending : Optional [ _DTBoth ] property Return the ending of the event. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement. expand_component_in_range ( return_range , starts_to_exclude ) Expand this VEvent in range according to its recurring RDate , EXDate and RRule properties. Parameters: Name Type Description Default return_range Timespan The timespan range on which we should return VEvent instances. required starts_to_exclude Union [ List [ Date ], List [ DateTime ]] List of start Dates or list of start DateTimes of which we should exclude as they were defined in EXDATE, have already been returned or have been completely redefined in another element. required Returns: Type Description Iterator [ TimespanWithParent ] Yield all recurring VEvent instances related to this VEvent in the given return_range . Source code in ical_library/ical_components/v_event.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VEvent in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VEvent instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we should exclude as they were defined in EXDATE, have already been returned or have been completely redefined in another element. :return: Yield all recurring VEvent instances related to this VEvent in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = start , first_event_duration = duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringEvent ( original_component_instance = self , start = event_start_time , end = event_end_time , ) . timespan get_duration () Return the duration of the event. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement. Source code in ical_library/ical_components/v_event.py 178 179 180 181 182 183 184 def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return the duration of the event. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . duration . duration if self . duration else None VRecurringEvent Bases: AbstractRecurrence , VEvent This class represents VEvents that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VEvent but without us needing to code the exact same thing twice. Parameters: Name Type Description Default original_component_instance VEvent The original VEvent instance. required start DateTime The start of this occurrence. required end DateTime The end of this occurrence. required Source code in ical_library/ical_components/v_event.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 class VRecurringEvent ( AbstractRecurrence , VEvent ): \"\"\" This class represents VEvents that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VEvent but without us needing to code the exact same thing twice. :param original_component_instance: The original VEvent instance. :param start: The start of this occurrence. :param end: The end of this occurrence. \"\"\" def __init__ ( self , original_component_instance : VEvent , start : DateTime , end : DateTime ): self . _original = original_component_instance self . _start = start self . _end = end super ( VEvent , self ) . __init__ ( \"VEVENT\" , parent = original_component_instance ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"RVEvent( { self . _start } - { self . _end } : { self . original . summary . value if self . original . summary else '' } )\" VToDo Bases: AbstractComponentWithRecurringProperties This class represents the VTODO component specified in RFC 5545 in '3.6.2. To-Do Component'. A \"VTODO\" calendar component is a grouping of component properties and possibly \"VALARM\" calendar components that represent an action-item or assignment. For example, it can be used to represent an item of work assigned to an individual; such as \"turn in travel expense today\". Parameters: Name Type Description Default name The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None dtstart Optional [ DTStart ] The DTStart property. Optional and may occur at most once. None rrule Optional [ RRule ] The RRule property. Optional and may occur at most once. None summary Optional [ Summary ] The Summary property. Optional and may occur at most once. None exdate Optional [ List [ EXDate ]] The EXDate property. Optional, but may occur multiple times. None rdate Optional [ List [ RDate ]] The RDate property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None ical_class Optional [ Class ] Optional Class property. Optional, but may occur at most once. None completed Optional [ Completed ] The Completed property. Optional, but may occur at most once. None created Optional [ Created ] The Created property. Optional, but may occur at most once. None description Optional [ Description ] The Description property. Optional, but may occur at most once. None duration Optional [ ICALDuration ] The ICALDuration property. Optional, but may occur at most once. None geo Optional [ GEO ] The GEO property. Optional, but may occur at most once. None last_modified Optional [ LastModified ] Optional LastModified property. Optional, but may occur at most once. None location Optional [ Location ] The Location property. Optional, but may occur at most once. None organizer Optional [ Organizer ] The Organizer property. Optional, but may occur at most once. None percent Optional [ PercentComplete ] The PercentComplete property. Optional, but may occur at most once. None priority Optional [ Priority ] The Priority property. Optional, but may occur at most once. None sequence Optional [ Sequence ] The Sequence property. Optional, but may occur at most once. None status Optional [ Status ] The Status property. Optional, but may occur at most once. None url Optional [ URL ] The URL property. Optional, but may occur at most once. None recurrence_id Optional [ RecurrenceID ] Optional RecurrenceID property. Optional, but may occur at most once. None due Optional [ Due ] The Due property. Optional, but may occur at most once. None attach Optional [ List [ Attach ]] The Attach property. Optional, but may occur multiple times. None attendee Optional [ List [ Attendee ]] The Attendee property. Optional, but may occur multiple times. None categories Optional [ List [ Categories ]] The Categories property. Optional, but may occur multiple times. None contact Optional [ List [ Contact ]] The Contact property. Optional, but may occur multiple times. None rstatus Optional [ List [ RequestStatus ]] The RequestStatus property. Optional, but may occur multiple times. None related Optional [ List [ RelatedTo ]] The RelatedTo property. Optional, but may occur multiple times. None resources Optional [ List [ Resources ]] The Resources property. Optional, but may occur multiple times. None Source code in ical_library/ical_components/v_todo.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 class VToDo ( AbstractComponentWithRecurringProperties ): \"\"\" This class represents the VTODO component specified in RFC 5545 in '3.6.2. To-Do Component'. A \"VTODO\" calendar component is a grouping of component properties and possibly \"VALARM\" calendar components that represent an action-item or assignment. For example, it can be used to represent an item of work assigned to an individual; such as \"turn in travel expense today\". :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param parent: The Component this item is encapsulated by in the iCalendar data file. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param dtstart: The DTStart property. Optional and may occur at most once. :param rrule: The RRule property. Optional and may occur at most once. :param summary: The Summary property. Optional and may occur at most once. :param exdate: The EXDate property. Optional, but may occur multiple times. :param rdate: The RDate property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param ical_class: Optional Class property. Optional, but may occur at most once. :param completed: The Completed property. Optional, but may occur at most once. :param created: The Created property. Optional, but may occur at most once. :param description: The Description property. Optional, but may occur at most once. :param duration: The ICALDuration property. Optional, but may occur at most once. :param geo: The GEO property. Optional, but may occur at most once. :param last_modified: Optional LastModified property. Optional, but may occur at most once. :param location: The Location property. Optional, but may occur at most once. :param organizer: The Organizer property. Optional, but may occur at most once. :param percent: The PercentComplete property. Optional, but may occur at most once. :param priority: The Priority property. Optional, but may occur at most once. :param sequence: The Sequence property. Optional, but may occur at most once. :param status: The Status property. Optional, but may occur at most once. :param url: The URL property. Optional, but may occur at most once. :param recurrence_id: Optional RecurrenceID property. Optional, but may occur at most once. :param due: The Due property. Optional, but may occur at most once. :param attach: The Attach property. Optional, but may occur multiple times. :param attendee: The Attendee property. Optional, but may occur multiple times. :param categories: The Categories property. Optional, but may occur multiple times. :param contact: The Contact property. Optional, but may occur multiple times. :param rstatus: The RequestStatus property. Optional, but may occur multiple times. :param related: The RelatedTo property. Optional, but may occur multiple times. :param resources: The Resources property. Optional, but may occur multiple times. \"\"\" def __init__ ( self , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , dtstart : Optional [ DTStart ] = None , rrule : Optional [ RRule ] = None , summary : Optional [ Summary ] = None , exdate : Optional [ List [ EXDate ]] = None , rdate : Optional [ List [ RDate ]] = None , comment : Optional [ List [ Comment ]] = None , ical_class : Optional [ Class ] = None , completed : Optional [ Completed ] = None , created : Optional [ Created ] = None , description : Optional [ Description ] = None , duration : Optional [ ICALDuration ] = None , geo : Optional [ GEO ] = None , last_modified : Optional [ LastModified ] = None , location : Optional [ Location ] = None , organizer : Optional [ Organizer ] = None , percent : Optional [ PercentComplete ] = None , priority : Optional [ Priority ] = None , sequence : Optional [ Sequence ] = None , status : Optional [ Status ] = None , url : Optional [ URL ] = None , recurrence_id : Optional [ RecurrenceID ] = None , due : Optional [ Due ] = None , attach : Optional [ List [ Attach ]] = None , attendee : Optional [ List [ Attendee ]] = None , categories : Optional [ List [ Categories ]] = None , contact : Optional [ List [ Contact ]] = None , rstatus : Optional [ List [ RequestStatus ]] = None , related : Optional [ List [ RelatedTo ]] = None , resources : Optional [ List [ Resources ]] = None , alarms : Optional [ List [ VAlarm ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( name = \"VTODO\" , dtstamp = dtstamp , uid = uid , dtstart = dtstart , rrule = rrule , summary = summary , exdate = exdate , rdate = rdate , comment = comment , parent = parent , ) # Optional, may only occur once # As class is a reserved keyword in python, we prefixed it with `ical_`. self . ical_class : Optional [ Class ] = self . as_parent ( ical_class ) self . completed : Optional [ Completed ] = self . as_parent ( completed ) self . created : Optional [ Created ] = self . as_parent ( created ) self . description : Optional [ Description ] = self . as_parent ( description ) self . duration : Optional [ ICALDuration ] = self . as_parent ( duration ) self . geo : Optional [ GEO ] = self . as_parent ( geo ) self . last_modified : Optional [ LastModified ] = self . as_parent ( last_modified ) self . location : Optional [ Location ] = self . as_parent ( location ) self . organizer : Optional [ Organizer ] = self . as_parent ( organizer ) self . percent : Optional [ PercentComplete ] = self . as_parent ( percent ) self . priority : Optional [ Priority ] = self . as_parent ( priority ) self . sequence : Optional [ Sequence ] = self . as_parent ( sequence ) self . status : Optional [ Status ] = self . as_parent ( status ) self . url : Optional [ URL ] = self . as_parent ( url ) self . due : Optional [ Due ] = self . as_parent ( due ) # Optional, may occur more than once self . attach : Optional [ List [ Attach ]] = self . as_parent ( attach ) self . attendee : Optional [ List [ Attendee ]] = self . as_parent ( attendee ) self . categories : Optional [ List [ Categories ]] = self . as_parent ( categories ) self . contact : Optional [ List [ Contact ]] = self . as_parent ( contact ) self . rstatus : Optional [ List [ RequestStatus ]] = self . as_parent ( rstatus ) self . related : Optional [ List [ RelatedTo ]] = self . as_parent ( related ) self . resources : Optional [ List [ Resources ]] = self . as_parent ( resources ) # This is a child component self . alarms : List [ VAlarm ] = alarms or [] def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return ( f \"VToDo( { self . dtstart . value if self . dtstart else '' } - { self . due . value if self . due else '' } : \" f \" { self . summary . value if self . summary else '' } )\" ) @property def ending ( self ) -> Optional [ _DTBoth ]: \"\"\" Return the ending of the vtodo. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . due def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return the duration of the vtodo. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . duration . duration if self . duration else None def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VToDo in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VToDo instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VToDo instances related to this VToDo in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . start , first_event_duration = self . computed_duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringToDo ( original_component_instance = self , start = event_start_time , end = event_end_time , ) . timespan ending : Optional [ _DTBoth ] property Return the ending of the vtodo. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement. expand_component_in_range ( return_range , starts_to_exclude ) Expand this VToDo in range according to its recurring RDate , EXDate and RRule properties. Parameters: Name Type Description Default return_range Timespan The timespan range on which we should return VToDo instances. required starts_to_exclude Union [ List [ Date ], List [ DateTime ]] List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). required Returns: Type Description Iterator [ TimespanWithParent ] Yield all recurring VToDo instances related to this VToDo in the given return_range . Source code in ical_library/ical_components/v_todo.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VToDo in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VToDo instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VToDo instances related to this VToDo in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . start , first_event_duration = self . computed_duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringToDo ( original_component_instance = self , start = event_start_time , end = event_end_time , ) . timespan get_duration () Return the duration of the vtodo. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement. Source code in ical_library/ical_components/v_todo.py 185 186 187 188 189 190 191 def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return the duration of the vtodo. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . duration . duration if self . duration else None VRecurringToDo Bases: AbstractRecurrence , VToDo This class represents VToDo that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VToDo but without us needing to code the exact same thing twice. Parameters: Name Type Description Default original_component_instance VToDo The original VToDo instance. required start DateTime The start of this occurrence. required end DateTime The end of this occurrence. required Source code in ical_library/ical_components/v_todo.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 class VRecurringToDo ( AbstractRecurrence , VToDo ): \"\"\" This class represents VToDo that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VToDo but without us needing to code the exact same thing twice. :param original_component_instance: The original VToDo instance. :param start: The start of this occurrence. :param end: The end of this occurrence. \"\"\" def __init__ ( self , original_component_instance : VToDo , start : DateTime , end : DateTime ): self . _original = original_component_instance self . _start = start self . _end = end super ( VToDo , self ) . __init__ ( \"VTODO\" , parent = original_component_instance ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"RVToDo( { self . _start } - { self . _end } : { self . original . summary . value if self . original . summary else '' } )\" VJournal Bases: AbstractComponentWithRecurringProperties This class represents the VJOURNAL component specified in RFC 5545 in '3.6.3. Journal Component'. A \"VJOURNAL\" calendar component is a grouping of component properties that represent one or more descriptive text notes associated with a particular calendar date. The \"DTSTART\" property is used to specify the calendar date with which the journal entry is associated. Generally, it will have a DATE value data type, but it can also be used to specify a DATE-TIME value data type. Examples of a journal entry include a daily record of a legislative body or a journal entry of individual telephone contacts for the day or an ordered list of accomplishments for the day. The \"VJOURNAL\" calendar component can also be used to associate a document with a calendar date. Parameters: Name Type Description Default name The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None dtstart Optional [ DTStart ] The DTStart property. Optional and may occur at most once. None rrule Optional [ RRule ] The RRule property. Optional and may occur at most once. None summary Optional [ Summary ] The Summary property. Optional and may occur at most once. None exdate Optional [ List [ EXDate ]] The EXDate property. Optional, but may occur multiple times. None rdate Optional [ List [ RDate ]] The RDate property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None ical_class Optional [ Class ] Optional Class property. Optional, but may occur at most once. None created Optional [ Created ] The Created property. Optional, but may occur at most once. None last_modified Optional [ LastModified ] Optional LastModified property. Optional, but may occur at most once. None organizer Optional [ Organizer ] The Organizer property. Optional, but may occur at most once. None sequence Optional [ Sequence ] The Sequence property. Optional, but may occur at most once. None status Optional [ Status ] The Status property. Optional, but may occur at most once. None url Optional [ URL ] The URL property. Optional, but may occur at most once. None recurrence_id Optional [ RecurrenceID ] Optional RecurrenceID property. Optional, but may occur at most once. None attach Optional [ List [ Attach ]] The Attach property. Optional, but may occur multiple times. None attendee Optional [ List [ Attendee ]] The Attendee property. Optional, but may occur multiple times. None categories Optional [ List [ Categories ]] The Categories property. Optional, but may occur multiple times. None contact Optional [ List [ Contact ]] The Contact property. Optional, but may occur multiple times. None description Optional [ List [ Description ]] The Description property. Optional, but may occur multiple times. None related Optional [ List [ RelatedTo ]] The RelatedTo property. Optional, but may occur multiple times. None rstatus Optional [ List [ RequestStatus ]] The RequestStatus property. Optional, but may occur multiple times. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_journal.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class VJournal ( AbstractComponentWithRecurringProperties ): \"\"\" This class represents the VJOURNAL component specified in RFC 5545 in '3.6.3. Journal Component'. A \"VJOURNAL\" calendar component is a grouping of component properties that represent one or more descriptive text notes associated with a particular calendar date. The \"DTSTART\" property is used to specify the calendar date with which the journal entry is associated. Generally, it will have a DATE value data type, but it can also be used to specify a DATE-TIME value data type. Examples of a journal entry include a daily record of a legislative body or a journal entry of individual telephone contacts for the day or an ordered list of accomplishments for the day. The \"VJOURNAL\" calendar component can also be used to associate a document with a calendar date. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param dtstart: The DTStart property. Optional and may occur at most once. :param rrule: The RRule property. Optional and may occur at most once. :param summary: The Summary property. Optional and may occur at most once. :param exdate: The EXDate property. Optional, but may occur multiple times. :param rdate: The RDate property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param ical_class: Optional Class property. Optional, but may occur at most once. :param created: The Created property. Optional, but may occur at most once. :param last_modified: Optional LastModified property. Optional, but may occur at most once. :param organizer: The Organizer property. Optional, but may occur at most once. :param sequence: The Sequence property. Optional, but may occur at most once. :param status: The Status property. Optional, but may occur at most once. :param url: The URL property. Optional, but may occur at most once. :param recurrence_id: Optional RecurrenceID property. Optional, but may occur at most once. :param attach: The Attach property. Optional, but may occur multiple times. :param attendee: The Attendee property. Optional, but may occur multiple times. :param categories: The Categories property. Optional, but may occur multiple times. :param contact: The Contact property. Optional, but may occur multiple times. :param description: The Description property. Optional, but may occur multiple times. :param related: The RelatedTo property. Optional, but may occur multiple times. :param rstatus: The RequestStatus property. Optional, but may occur multiple times. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , dtstart : Optional [ DTStart ] = None , rrule : Optional [ RRule ] = None , summary : Optional [ Summary ] = None , exdate : Optional [ List [ EXDate ]] = None , rdate : Optional [ List [ RDate ]] = None , comment : Optional [ List [ Comment ]] = None , ical_class : Optional [ Class ] = None , created : Optional [ Created ] = None , last_modified : Optional [ LastModified ] = None , organizer : Optional [ Organizer ] = None , sequence : Optional [ Sequence ] = None , status : Optional [ Status ] = None , url : Optional [ URL ] = None , recurrence_id : Optional [ RecurrenceID ] = None , attach : Optional [ List [ Attach ]] = None , attendee : Optional [ List [ Attendee ]] = None , categories : Optional [ List [ Categories ]] = None , contact : Optional [ List [ Contact ]] = None , description : Optional [ List [ Description ]] = None , related : Optional [ List [ RelatedTo ]] = None , rstatus : Optional [ List [ RequestStatus ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( name = \"VJOURNAL\" , dtstamp = dtstamp , uid = uid , dtstart = dtstart , rrule = rrule , summary = summary , exdate = exdate , rdate = rdate , comment = comment , parent = parent , ) # Optional, may only occur once # As class is a reserved keyword in python, we prefixed it with `ical_`. self . ical_class : Optional [ Class ] = self . as_parent ( ical_class ) self . created : Optional [ Created ] = self . as_parent ( created ) self . last_modified : Optional [ LastModified ] = self . as_parent ( last_modified ) self . organizer : Optional [ Organizer ] = self . as_parent ( organizer ) self . sequence : Optional [ Sequence ] = self . as_parent ( sequence ) self . status : Optional [ Status ] = self . as_parent ( status ) self . url : Optional [ URL ] = self . as_parent ( url ) # Optional, may occur more than once self . attach : Optional [ List [ Attach ]] = self . as_parent ( attach ) self . attendee : Optional [ List [ Attendee ]] = self . as_parent ( attendee ) self . categories : Optional [ List [ Categories ]] = self . as_parent ( categories ) self . contact : Optional [ List [ Contact ]] = self . as_parent ( contact ) self . description : Optional [ List [ Description ]] = self . as_parent ( description ) self . related : Optional [ List [ RelatedTo ]] = self . as_parent ( related ) self . rstatus : Optional [ List [ RequestStatus ]] = self . as_parent ( rstatus ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VJournal( { self . start } : { self . summary . value if self . summary else '' } )\" @property def ending ( self ) -> Optional [ _DTBoth ]: \"\"\" Return the start time of the journal. This is because the Journal does not have a duration. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . dtstart def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return an empty Duration as a Journal does not have a duration. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return Duration () def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VJournal in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VJournal instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VJournal instances related to this VJournal in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . start , first_event_duration = self . computed_duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringJournal ( original_component_instance = self , start = event_start_time ) . timespan ending : Optional [ _DTBoth ] property Return the start time of the journal. This is because the Journal does not have a duration. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement. expand_component_in_range ( return_range , starts_to_exclude ) Expand this VJournal in range according to its recurring RDate , EXDate and RRule properties. Parameters: Name Type Description Default return_range Timespan The timespan range on which we should return VJournal instances. required starts_to_exclude Union [ List [ Date ], List [ DateTime ]] List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). required Returns: Type Description Iterator [ TimespanWithParent ] Yield all recurring VJournal instances related to this VJournal in the given return_range . Source code in ical_library/ical_components/v_journal.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VJournal in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VJournal instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VJournal instances related to this VJournal in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . start , first_event_duration = self . computed_duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringJournal ( original_component_instance = self , start = event_start_time ) . timespan get_duration () Return an empty Duration as a Journal does not have a duration. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement. Source code in ical_library/ical_components/v_journal.py 143 144 145 146 147 148 149 def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return an empty Duration as a Journal does not have a duration. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return Duration () VRecurringJournal Bases: AbstractRecurrence , VJournal This class represents VJournal that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VJournal but without us needing to code the exact same thing twice. Parameters: Name Type Description Default original_component_instance VJournal The original VJournal instance. required start DateTime The start of this occurrence. required end The end of this occurrence. required Source code in ical_library/ical_components/v_journal.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 class VRecurringJournal ( AbstractRecurrence , VJournal ): \"\"\" This class represents VJournal that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VJournal but without us needing to code the exact same thing twice. :param original_component_instance: The original VJournal instance. :param start: The start of this occurrence. :param end: The end of this occurrence. \"\"\" def __init__ ( self , original_component_instance : VJournal , start : DateTime ): self . _original = original_component_instance self . _start = start self . _end = start super ( VJournal , self ) . __init__ ( \"VJOURNAL\" , parent = original_component_instance ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"RVJournal( { self . _start } : { self . original . summary . value if self . original . summary else '' } )\"","title":"Recurring components"},{"location":"code/components/recurring_components/#recurring-components","text":"These are the components that have the possibility to be recurring. For each of them there is their standard class and their recurring class. The idea is that the original definition is represented by the standard class and any occurrence that is generated based on the recurring properties, is represented by the recurring class. Given all classes that have recurring options have a major overlap, there are two class abstracting the complexity away from them. This is again in the same concept, where the first one covers the standard class, and the other one covers the recurring class. These two are listed here first before the rest.","title":"Recurring components"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractComponentWithRecurringProperties","text":"Bases: Component , ABC This class helps avoid code repetition with different :class: Component classes that have a duration and have recurring properties. This class is inherited by VEvent, VToDo and VJournal as these all have recurring properties like :class: RRule , :class: RDate and :class: EXDate . All properties they had in common are part of this class. Note: VJournal is the odd one out as these events don't have a duration. Parameters: Name Type Description Default name str The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None dtstart Optional [ DTStart ] The DTStart property. Optional and may occur at most once. None rrule Optional [ RRule ] The RRule property. Optional and may occur at most once. None summary Optional [ Summary ] The Summary property. Optional and may occur at most once. None exdate Optional [ List [ EXDate ]] The EXDate property. Optional, but may occur multiple times. None rdate Optional [ List [ RDate ]] The RDate property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/abstract_components.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 class AbstractComponentWithRecurringProperties ( Component , ABC ): \"\"\" This class helps avoid code repetition with different :class:`Component` classes that have a duration and have recurring properties. This class is inherited by VEvent, VToDo and VJournal as these all have recurring properties like :class:`RRule`, :class:`RDate` and :class:`EXDate`. All properties they had in common are part of this class. Note: VJournal is the odd one out as these events don't have a duration. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param dtstart: The DTStart property. Optional and may occur at most once. :param rrule: The RRule property. Optional and may occur at most once. :param summary: The Summary property. Optional and may occur at most once. :param exdate: The EXDate property. Optional, but may occur multiple times. :param rdate: The RDate property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , name : str , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , dtstart : Optional [ DTStart ] = None , rrule : Optional [ RRule ] = None , summary : Optional [ Summary ] = None , recurrence_id : Optional [ RecurrenceID ] = None , exdate : Optional [ List [ EXDate ]] = None , rdate : Optional [ List [ RDate ]] = None , comment : Optional [ List [ Comment ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( name , parent = parent ) # Required self . _dtstamp : Optional [ DTStamp ] = self . as_parent ( dtstamp ) self . _uid : Optional [ UID ] = self . as_parent ( uid ) # Optional, may only occur once self . dtstart : Optional [ DTStart ] = self . as_parent ( dtstart ) self . rrule : Optional [ RRule ] = self . as_parent ( rrule ) self . summary : Optional [ Summary ] = self . as_parent ( summary ) self . recurrence_id : Optional [ RecurrenceID ] = self . as_parent ( recurrence_id ) # Optional, may occur more than once self . exdate : Optional [ List [ EXDate ]] = self . as_parent ( exdate ) self . rdate : Optional [ List [ RDate ]] = self . as_parent ( rdate ) self . comment : Optional [ List [ Comment ]] = self . as_parent ( comment ) @property def dtstamp ( self ) -> DTStamp : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _dtstamp is None : raise MissingRequiredProperty ( self , \"dtstamp\" ) return self . _dtstamp @dtstamp . setter def dtstamp ( self , value : DTStamp ): \"\"\"A setter to set the required property.\"\"\" self . _dtstamp = value @property def uid ( self ) -> UID : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _uid is None : raise MissingRequiredProperty ( self , \"uid\" ) return self . _uid @uid . setter def uid ( self , value : UID ): \"\"\"A setter to set the required property.\"\"\" self . _uid = value @property @abstractmethod def ending ( self ) -> _DTBoth : \"\"\" As the argument for this is different in each class, we ask this to be implemented. :return: The ending of the :class:`Component`, except for :class:`VJournal` which returns the start. \"\"\" pass @abstractmethod def get_duration ( self ) -> Optional [ Duration ]: \"\"\" As the duration is not present in each of them, we ask this to be implemented by the subclasses. :return: The duration of the :class:`Component`. \"\"\" pass @abstractmethod def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this component in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VToDo instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VToDo instances related to this VToDo in the given *return_range*. \"\"\" pass def __eq__ ( self : \"AbstractComponentWithRecurringProperties\" , other : \"AbstractComponentWithRecurringProperties\" ) -> bool : \"\"\"Return whether the current instance and the other instance are the same.\"\"\" if type ( self ) != type ( other ): return False return ( self . dtstart == other . dtstart and self . ending == other . ending and self . summary == other . summary and self . comment == other . comment ) @property def timespan ( self ) -> Optional [ TimespanWithParent ]: \"\"\" Return a timespan as a property representing the start and end of the instance. :return: A timespan instance with this class instance as parent. \"\"\" if self . start is None : return None if self . end is None : TimespanWithParent ( parent = self , begin = self . start , end = self . start ) return TimespanWithParent ( parent = self , begin = self . start , end = self . end ) @property @instance_lru_cache () def start ( self ) -> Optional [ Union [ Date , DateTime ]]: \"\"\"Return the start of this Component as a :class:`Date` or :class:`DateTime` value.\"\"\" return self . dtstart . datetime_or_date_value if self . dtstart else None @property @instance_lru_cache () def end ( self ) -> Optional [ Union [ Date , DateTime ]]: \"\"\"Return the ending of this Component as a Date or DateTime value.\"\"\" if self . ending : return self . ending . datetime_or_date_value elif self . start and self . get_duration (): return self . start + self . get_duration () return None @property @instance_lru_cache () def computed_duration ( self : \"AbstractComponentWithRecurringProperties\" ) -> Optional [ Duration ]: \"\"\"Return the duration of this Component as a :class:`Date` or :class:`DateTime` value.\"\"\" if a_duration := self . get_duration (): return a_duration elif self . end and self . start : result : Period = self . end - self . start return result return None @property @instance_lru_cache () def max_recurring_timespan ( self ) -> Optional [ Timespan ]: if not self . start or not self . computed_duration : return None if not self . rrule and not self . rdate : return self . timespan max_dt : DateTime = DateTime . min if self . rdate : max_dt = max ( max_dt , max ([ rdate . compute_max_end_date ( self . computed_duration ) for rdate in self . rdate ])) if self . rrule : max_dt = max ( max_dt , self . rrule . compute_max_end_date ( self . start , self . computed_duration )) if max_dt != DateTime . min : return Timespan ( self . start , max_dt ) return None","title":"AbstractComponentWithRecurringProperties"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractComponentWithRecurringProperties.computed_duration","text":"Return the duration of this Component as a :class: Date or :class: DateTime value.","title":"computed_duration"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractComponentWithRecurringProperties.dtstamp","text":"A getter to ensure the required property is set.","title":"dtstamp"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractComponentWithRecurringProperties.end","text":"Return the ending of this Component as a Date or DateTime value.","title":"end"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractComponentWithRecurringProperties.ending","text":"As the argument for this is different in each class, we ask this to be implemented. Returns: Type Description The ending of the :class: Component , except for :class: VJournal which returns the start.","title":"ending"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractComponentWithRecurringProperties.start","text":"Return the start of this Component as a :class: Date or :class: DateTime value.","title":"start"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractComponentWithRecurringProperties.timespan","text":"Return a timespan as a property representing the start and end of the instance. Returns: Type Description A timespan instance with this class instance as parent.","title":"timespan"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractComponentWithRecurringProperties.uid","text":"A getter to ensure the required property is set.","title":"uid"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractComponentWithRecurringProperties.expand_component_in_range","text":"Expand this component in range according to its recurring RDate , EXDate and RRule properties. Parameters: Name Type Description Default return_range Timespan The timespan range on which we should return VToDo instances. required starts_to_exclude Union [ List [ Date ], List [ DateTime ]] List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). required Returns: Type Description Iterator [ TimespanWithParent ] Yield all recurring VToDo instances related to this VToDo in the given return_range . Source code in ical_library/ical_components/abstract_components.py 111 112 113 114 115 116 117 118 119 120 121 122 @abstractmethod def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this component in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VToDo instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VToDo instances related to this VToDo in the given *return_range*. \"\"\" pass","title":"expand_component_in_range"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractComponentWithRecurringProperties.get_duration","text":"As the duration is not present in each of them, we ask this to be implemented by the subclasses. Returns: Type Description Optional [ Duration ] The duration of the :class: Component . Source code in ical_library/ical_components/abstract_components.py 102 103 104 105 106 107 108 109 @abstractmethod def get_duration ( self ) -> Optional [ Duration ]: \"\"\" As the duration is not present in each of them, we ask this to be implemented by the subclasses. :return: The duration of the :class:`Component`. \"\"\" pass","title":"get_duration"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractRecurrence","text":"Bases: AbstractComponentWithRecurringProperties , ABC This class extends :class: AbstractComponentWithRecurringProperties to represent a recurring Component. This class is inherited by VRecurringEvent, VRecurringToDo and VRecurringJournal. When we compute the recurrence based on the :class: RRule , :class: RDate and :class: EXDate properties, we create new occurrences of that specific component. Instead of copying over all Properties (and using a lot of memory), this class overwrites the getattribute function to act like the original component for most attributes except for start , end , original and parent . Source code in ical_library/ical_components/abstract_components.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 class AbstractRecurrence ( AbstractComponentWithRecurringProperties , ABC ): \"\"\" This class extends :class:`AbstractComponentWithRecurringProperties` to represent a recurring Component. This class is inherited by VRecurringEvent, VRecurringToDo and VRecurringJournal. When we compute the recurrence based on the :class:`RRule`, :class:`RDate` and :class:`EXDate` properties, we create new occurrences of that specific component. Instead of copying over all Properties (and using a lot of memory), this class overwrites the *__getattribute__* function to act like the original component for most attributes except for *start*, *end*, *original* and *parent*. \"\"\" def __getattribute__ ( self , var_name : str ) -> Any : \"\"\" Overwrite this function to return the originals properties except for *start*, *end*, *original* and *parent*. Depending on the attributes *name* we are requesting, we either return its own properties or the original components properties. This way we don't need to copy over all the variables. :param var_name: Name of the attribute we are accessing. :return: The value of the attribute we are accessing either from the *original* or from this instance itself. \"\"\" if var_name in ( \"_start\" , \"_end\" , \"_original\" , \"_parent\" , \"start\" , \"end\" , \"original\" , \"parent\" ): return object . __getattribute__ ( self , var_name ) if var_name in ( \"_name\" , \"_extra_child_components\" , \"_extra_properties\" ): return object . __getattribute__ ( self . _original , var_name ) if var_name in self . _original . get_property_ical_names (): return object . __getattribute__ ( self . _original , var_name ) return object . __getattribute__ ( self , var_name ) def __setattr__ ( self , key : str , value : Any ) -> None : \"\"\"Overwrite the custom __setattr__ from Components to set it back to the standard behavior.\"\"\" object . __setattr__ ( self , key , value ) @property def start ( self ) -> DateTime : \"\"\"Return the start of this recurring event.\"\"\" return self . _start @property def end ( self ) -> DateTime : \"\"\"Return the end of this recurring event.\"\"\" return self . _end @property def original ( self ) -> AbstractComponentWithRecurringProperties : \"\"\"Return the original component that created this recurring component.\"\"\" return self . _original @property def parent ( self ) -> Component : \"\"\"Return the parent of the original component.\"\"\" return self . _original . parent","title":"AbstractRecurrence"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractRecurrence.end","text":"Return the end of this recurring event.","title":"end"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractRecurrence.original","text":"Return the original component that created this recurring component.","title":"original"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractRecurrence.parent","text":"Return the parent of the original component.","title":"parent"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractRecurrence.start","text":"Return the start of this recurring event.","title":"start"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractRecurrence.__getattribute__","text":"Overwrite this function to return the originals properties except for start , end , original and parent . Depending on the attributes name we are requesting, we either return its own properties or the original components properties. This way we don't need to copy over all the variables. Parameters: Name Type Description Default var_name str Name of the attribute we are accessing. required Returns: Type Description Any The value of the attribute we are accessing either from the original or from this instance itself. Source code in ical_library/ical_components/abstract_components.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def __getattribute__ ( self , var_name : str ) -> Any : \"\"\" Overwrite this function to return the originals properties except for *start*, *end*, *original* and *parent*. Depending on the attributes *name* we are requesting, we either return its own properties or the original components properties. This way we don't need to copy over all the variables. :param var_name: Name of the attribute we are accessing. :return: The value of the attribute we are accessing either from the *original* or from this instance itself. \"\"\" if var_name in ( \"_start\" , \"_end\" , \"_original\" , \"_parent\" , \"start\" , \"end\" , \"original\" , \"parent\" ): return object . __getattribute__ ( self , var_name ) if var_name in ( \"_name\" , \"_extra_child_components\" , \"_extra_properties\" ): return object . __getattribute__ ( self . _original , var_name ) if var_name in self . _original . get_property_ical_names (): return object . __getattribute__ ( self . _original , var_name ) return object . __getattribute__ ( self , var_name )","title":"__getattribute__"},{"location":"code/components/recurring_components/#ical_library.ical_components.abstract_components.AbstractRecurrence.__setattr__","text":"Overwrite the custom setattr from Components to set it back to the standard behavior. Source code in ical_library/ical_components/abstract_components.py 221 222 223 def __setattr__ ( self , key : str , value : Any ) -> None : \"\"\"Overwrite the custom __setattr__ from Components to set it back to the standard behavior.\"\"\" object . __setattr__ ( self , key , value )","title":"__setattr__"},{"location":"code/components/recurring_components/#ical_library.ical_components.VEvent","text":"Bases: AbstractComponentWithRecurringProperties This class represents the VEVENT component specified in RFC 5545 in '3.6.1. Event Component'. A \"VEVENT\" calendar component is a grouping of component properties, possibly including \"VALARM\" calendar components, that represents a scheduled amount of time on a calendar. For example, it can be an activity; such as a one-hour long, department meeting from 8:00 AM to 9:00 AM, tomorrow. Generally, an event will take up time on an individual calendar. Hence, the event will appear as an opaque interval in a search for busy time. Alternately, the event can have its Time Transparency set to \"TRANSPARENT\" in order to prevent blocking of the event in searches for busy time. Parameters: Name Type Description Default name The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None dtstart Optional [ DTStart ] The DTStart property. Optional and may occur at most once. None rrule Optional [ RRule ] The RRule property. Optional and may occur at most once. None summary Optional [ Summary ] The Summary property. Optional and may occur at most once. None exdate Optional [ List [ EXDate ]] The EXDate property. Optional, but may occur multiple times. None rdate Optional [ List [ RDate ]] The RDate property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None ical_class Optional [ Class ] Optional Class property. Optional, but may occur at most once. None created Optional [ Created ] The Created property. Optional, but may occur at most once. None description Optional [ Description ] The Description property. Optional, but may occur at most once. None duration Optional [ ICALDuration ] The ICALDuration property. Optional, but may occur at most once. None geo Optional [ GEO ] The GEO property. Optional, but may occur at most once. None last_modified Optional [ LastModified ] Optional LastModified property. Optional, but may occur at most once. None location Optional [ Location ] The Location property. Optional, but may occur at most once. None organizer Optional [ Organizer ] The Organizer property. Optional, but may occur at most once. None priority Optional [ Priority ] The Priority property. Optional, but may occur at most once. None sequence Optional [ Sequence ] The Sequence property. Optional, but may occur at most once. None status Optional [ Status ] The Status property. Optional, but may occur at most once. None transp Optional [ TimeTransparency ] The TimeTransparency property. Optional, but may occur at most once. None url Optional [ URL ] The URL property. Optional, but may occur at most once. None recurrence_id Optional [ RecurrenceID ] Optional RecurrenceID property. Optional, but may occur at most once. None dtend Optional [ DTEnd ] The DTEnd property. Optional, but may occur at most once. None attach Optional [ List [ Attach ]] The Attach property. Optional, but may occur multiple times. None attendee Optional [ List [ Attendee ]] The Attendee property. Optional, but may occur multiple times. None categories Optional [ List [ Categories ]] The Categories property. Optional, but may occur multiple times. None contact Optional [ List [ Contact ]] The Contact property. Optional, but may occur multiple times. None rstatus Optional [ List [ RequestStatus ]] The RequestStatus property. Optional, but may occur multiple times. None related Optional [ List [ RelatedTo ]] The RelatedTo property. Optional, but may occur multiple times. None resources Optional [ List [ Resources ]] The Resources property. Optional, but may occur multiple times. None Source code in ical_library/ical_components/v_event.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 class VEvent ( AbstractComponentWithRecurringProperties ): \"\"\" This class represents the VEVENT component specified in RFC 5545 in '3.6.1. Event Component'. A \"VEVENT\" calendar component is a grouping of component properties, possibly including \"VALARM\" calendar components, that represents a scheduled amount of time on a calendar. For example, it can be an activity; such as a one-hour long, department meeting from 8:00 AM to 9:00 AM, tomorrow. Generally, an event will take up time on an individual calendar. Hence, the event will appear as an opaque interval in a search for busy time. Alternately, the event can have its Time Transparency set to \"TRANSPARENT\" in order to prevent blocking of the event in searches for busy time. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param parent: The Component this item is encapsulated by in the iCalendar data file. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param dtstart: The DTStart property. Optional and may occur at most once. :param rrule: The RRule property. Optional and may occur at most once. :param summary: The Summary property. Optional and may occur at most once. :param exdate: The EXDate property. Optional, but may occur multiple times. :param rdate: The RDate property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param ical_class: Optional Class property. Optional, but may occur at most once. :param created: The Created property. Optional, but may occur at most once. :param description: The Description property. Optional, but may occur at most once. :param duration: The ICALDuration property. Optional, but may occur at most once. :param geo: The GEO property. Optional, but may occur at most once. :param last_modified: Optional LastModified property. Optional, but may occur at most once. :param location: The Location property. Optional, but may occur at most once. :param organizer: The Organizer property. Optional, but may occur at most once. :param priority: The Priority property. Optional, but may occur at most once. :param sequence: The Sequence property. Optional, but may occur at most once. :param status: The Status property. Optional, but may occur at most once. :param transp: The TimeTransparency property. Optional, but may occur at most once. :param url: The URL property. Optional, but may occur at most once. :param recurrence_id: Optional RecurrenceID property. Optional, but may occur at most once. :param dtend: The DTEnd property. Optional, but may occur at most once. :param attach: The Attach property. Optional, but may occur multiple times. :param attendee: The Attendee property. Optional, but may occur multiple times. :param categories: The Categories property. Optional, but may occur multiple times. :param contact: The Contact property. Optional, but may occur multiple times. :param rstatus: The RequestStatus property. Optional, but may occur multiple times. :param related: The RelatedTo property. Optional, but may occur multiple times. :param resources: The Resources property. Optional, but may occur multiple times. \"\"\" def __init__ ( self , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , dtstart : Optional [ DTStart ] = None , rrule : Optional [ RRule ] = None , summary : Optional [ Summary ] = None , exdate : Optional [ List [ EXDate ]] = None , rdate : Optional [ List [ RDate ]] = None , comment : Optional [ List [ Comment ]] = None , ical_class : Optional [ Class ] = None , created : Optional [ Created ] = None , description : Optional [ Description ] = None , duration : Optional [ ICALDuration ] = None , geo : Optional [ GEO ] = None , last_modified : Optional [ LastModified ] = None , location : Optional [ Location ] = None , organizer : Optional [ Organizer ] = None , priority : Optional [ Priority ] = None , sequence : Optional [ Sequence ] = None , status : Optional [ Status ] = None , transp : Optional [ TimeTransparency ] = None , url : Optional [ URL ] = None , recurrence_id : Optional [ RecurrenceID ] = None , dtend : Optional [ DTEnd ] = None , attach : Optional [ List [ Attach ]] = None , attendee : Optional [ List [ Attendee ]] = None , categories : Optional [ List [ Categories ]] = None , contact : Optional [ List [ Contact ]] = None , rstatus : Optional [ List [ RequestStatus ]] = None , related : Optional [ List [ RelatedTo ]] = None , resources : Optional [ List [ Resources ]] = None , alarms : Optional [ List [ VAlarm ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( name = \"VEVENT\" , dtstamp = dtstamp , uid = uid , dtstart = dtstart , rrule = rrule , summary = summary , recurrence_id = recurrence_id , exdate = exdate , rdate = rdate , comment = comment , parent = parent , ) # Optional, may only occur once # As class is a reserved keyword in python, we prefixed it with `ical_`. self . ical_class : Optional [ Class ] = self . as_parent ( ical_class ) self . created : Optional [ Created ] = self . as_parent ( created ) self . description : Optional [ Description ] = self . as_parent ( description ) self . duration : Optional [ ICALDuration ] = self . as_parent ( duration ) self . geo : Optional [ GEO ] = self . as_parent ( geo ) self . last_modified : Optional [ LastModified ] = self . as_parent ( last_modified ) self . location : Optional [ Location ] = self . as_parent ( location ) self . organizer : Optional [ Organizer ] = self . as_parent ( organizer ) self . priority : Optional [ Priority ] = self . as_parent ( priority ) self . sequence : Optional [ Sequence ] = self . as_parent ( sequence ) self . status : Optional [ Status ] = self . as_parent ( status ) self . transp : Optional [ TimeTransparency ] = self . as_parent ( transp ) self . url : Optional [ URL ] = self . as_parent ( url ) self . dtend : Optional [ DTEnd ] = self . as_parent ( dtend ) # Optional, may occur more than once self . attach : Optional [ List [ Attach ]] = self . as_parent ( attach ) self . attendee : Optional [ List [ Attendee ]] = self . as_parent ( attendee ) self . categories : Optional [ List [ Categories ]] = self . as_parent ( categories ) self . contact : Optional [ List [ Contact ]] = self . as_parent ( contact ) self . rstatus : Optional [ List [ RequestStatus ]] = self . as_parent ( rstatus ) self . related : Optional [ List [ RelatedTo ]] = self . as_parent ( related ) self . resources : Optional [ List [ Resources ]] = self . as_parent ( resources ) # This is a child component self . alarms : List [ VAlarm ] = alarms or [] def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" if self . dtstart and self . dtend : return f \"VEvent( { self . start } - { self . end } : { self . summary . value if self . summary else '' } )\" else : return f \"VEvent( { self . summary . value if self . summary else '' } )\" @property def ending ( self ) -> Optional [ _DTBoth ]: \"\"\" Return the ending of the event. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . dtend def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return the duration of the event. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . duration . duration if self . duration else None def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VEvent in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VEvent instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we should exclude as they were defined in EXDATE, have already been returned or have been completely redefined in another element. :return: Yield all recurring VEvent instances related to this VEvent in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = start , first_event_duration = duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringEvent ( original_component_instance = self , start = event_start_time , end = event_end_time , ) . timespan","title":"VEvent"},{"location":"code/components/recurring_components/#ical_library.ical_components.VEvent.ending","text":"Return the ending of the event. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement.","title":"ending"},{"location":"code/components/recurring_components/#ical_library.ical_components.VEvent.expand_component_in_range","text":"Expand this VEvent in range according to its recurring RDate , EXDate and RRule properties. Parameters: Name Type Description Default return_range Timespan The timespan range on which we should return VEvent instances. required starts_to_exclude Union [ List [ Date ], List [ DateTime ]] List of start Dates or list of start DateTimes of which we should exclude as they were defined in EXDATE, have already been returned or have been completely redefined in another element. required Returns: Type Description Iterator [ TimespanWithParent ] Yield all recurring VEvent instances related to this VEvent in the given return_range . Source code in ical_library/ical_components/v_event.py 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VEvent in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VEvent instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we should exclude as they were defined in EXDATE, have already been returned or have been completely redefined in another element. :return: Yield all recurring VEvent instances related to this VEvent in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = start , first_event_duration = duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringEvent ( original_component_instance = self , start = event_start_time , end = event_end_time , ) . timespan","title":"expand_component_in_range"},{"location":"code/components/recurring_components/#ical_library.ical_components.VEvent.get_duration","text":"Return the duration of the event. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement. Source code in ical_library/ical_components/v_event.py 178 179 180 181 182 183 184 def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return the duration of the event. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . duration . duration if self . duration else None","title":"get_duration"},{"location":"code/components/recurring_components/#ical_library.ical_components.VRecurringEvent","text":"Bases: AbstractRecurrence , VEvent This class represents VEvents that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VEvent but without us needing to code the exact same thing twice. Parameters: Name Type Description Default original_component_instance VEvent The original VEvent instance. required start DateTime The start of this occurrence. required end DateTime The end of this occurrence. required Source code in ical_library/ical_components/v_event.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 class VRecurringEvent ( AbstractRecurrence , VEvent ): \"\"\" This class represents VEvents that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VEvent but without us needing to code the exact same thing twice. :param original_component_instance: The original VEvent instance. :param start: The start of this occurrence. :param end: The end of this occurrence. \"\"\" def __init__ ( self , original_component_instance : VEvent , start : DateTime , end : DateTime ): self . _original = original_component_instance self . _start = start self . _end = end super ( VEvent , self ) . __init__ ( \"VEVENT\" , parent = original_component_instance ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"RVEvent( { self . _start } - { self . _end } : { self . original . summary . value if self . original . summary else '' } )\"","title":"VRecurringEvent"},{"location":"code/components/recurring_components/#ical_library.ical_components.VToDo","text":"Bases: AbstractComponentWithRecurringProperties This class represents the VTODO component specified in RFC 5545 in '3.6.2. To-Do Component'. A \"VTODO\" calendar component is a grouping of component properties and possibly \"VALARM\" calendar components that represent an action-item or assignment. For example, it can be used to represent an item of work assigned to an individual; such as \"turn in travel expense today\". Parameters: Name Type Description Default name The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None dtstart Optional [ DTStart ] The DTStart property. Optional and may occur at most once. None rrule Optional [ RRule ] The RRule property. Optional and may occur at most once. None summary Optional [ Summary ] The Summary property. Optional and may occur at most once. None exdate Optional [ List [ EXDate ]] The EXDate property. Optional, but may occur multiple times. None rdate Optional [ List [ RDate ]] The RDate property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None ical_class Optional [ Class ] Optional Class property. Optional, but may occur at most once. None completed Optional [ Completed ] The Completed property. Optional, but may occur at most once. None created Optional [ Created ] The Created property. Optional, but may occur at most once. None description Optional [ Description ] The Description property. Optional, but may occur at most once. None duration Optional [ ICALDuration ] The ICALDuration property. Optional, but may occur at most once. None geo Optional [ GEO ] The GEO property. Optional, but may occur at most once. None last_modified Optional [ LastModified ] Optional LastModified property. Optional, but may occur at most once. None location Optional [ Location ] The Location property. Optional, but may occur at most once. None organizer Optional [ Organizer ] The Organizer property. Optional, but may occur at most once. None percent Optional [ PercentComplete ] The PercentComplete property. Optional, but may occur at most once. None priority Optional [ Priority ] The Priority property. Optional, but may occur at most once. None sequence Optional [ Sequence ] The Sequence property. Optional, but may occur at most once. None status Optional [ Status ] The Status property. Optional, but may occur at most once. None url Optional [ URL ] The URL property. Optional, but may occur at most once. None recurrence_id Optional [ RecurrenceID ] Optional RecurrenceID property. Optional, but may occur at most once. None due Optional [ Due ] The Due property. Optional, but may occur at most once. None attach Optional [ List [ Attach ]] The Attach property. Optional, but may occur multiple times. None attendee Optional [ List [ Attendee ]] The Attendee property. Optional, but may occur multiple times. None categories Optional [ List [ Categories ]] The Categories property. Optional, but may occur multiple times. None contact Optional [ List [ Contact ]] The Contact property. Optional, but may occur multiple times. None rstatus Optional [ List [ RequestStatus ]] The RequestStatus property. Optional, but may occur multiple times. None related Optional [ List [ RelatedTo ]] The RelatedTo property. Optional, but may occur multiple times. None resources Optional [ List [ Resources ]] The Resources property. Optional, but may occur multiple times. None Source code in ical_library/ical_components/v_todo.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 class VToDo ( AbstractComponentWithRecurringProperties ): \"\"\" This class represents the VTODO component specified in RFC 5545 in '3.6.2. To-Do Component'. A \"VTODO\" calendar component is a grouping of component properties and possibly \"VALARM\" calendar components that represent an action-item or assignment. For example, it can be used to represent an item of work assigned to an individual; such as \"turn in travel expense today\". :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param parent: The Component this item is encapsulated by in the iCalendar data file. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param dtstart: The DTStart property. Optional and may occur at most once. :param rrule: The RRule property. Optional and may occur at most once. :param summary: The Summary property. Optional and may occur at most once. :param exdate: The EXDate property. Optional, but may occur multiple times. :param rdate: The RDate property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param ical_class: Optional Class property. Optional, but may occur at most once. :param completed: The Completed property. Optional, but may occur at most once. :param created: The Created property. Optional, but may occur at most once. :param description: The Description property. Optional, but may occur at most once. :param duration: The ICALDuration property. Optional, but may occur at most once. :param geo: The GEO property. Optional, but may occur at most once. :param last_modified: Optional LastModified property. Optional, but may occur at most once. :param location: The Location property. Optional, but may occur at most once. :param organizer: The Organizer property. Optional, but may occur at most once. :param percent: The PercentComplete property. Optional, but may occur at most once. :param priority: The Priority property. Optional, but may occur at most once. :param sequence: The Sequence property. Optional, but may occur at most once. :param status: The Status property. Optional, but may occur at most once. :param url: The URL property. Optional, but may occur at most once. :param recurrence_id: Optional RecurrenceID property. Optional, but may occur at most once. :param due: The Due property. Optional, but may occur at most once. :param attach: The Attach property. Optional, but may occur multiple times. :param attendee: The Attendee property. Optional, but may occur multiple times. :param categories: The Categories property. Optional, but may occur multiple times. :param contact: The Contact property. Optional, but may occur multiple times. :param rstatus: The RequestStatus property. Optional, but may occur multiple times. :param related: The RelatedTo property. Optional, but may occur multiple times. :param resources: The Resources property. Optional, but may occur multiple times. \"\"\" def __init__ ( self , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , dtstart : Optional [ DTStart ] = None , rrule : Optional [ RRule ] = None , summary : Optional [ Summary ] = None , exdate : Optional [ List [ EXDate ]] = None , rdate : Optional [ List [ RDate ]] = None , comment : Optional [ List [ Comment ]] = None , ical_class : Optional [ Class ] = None , completed : Optional [ Completed ] = None , created : Optional [ Created ] = None , description : Optional [ Description ] = None , duration : Optional [ ICALDuration ] = None , geo : Optional [ GEO ] = None , last_modified : Optional [ LastModified ] = None , location : Optional [ Location ] = None , organizer : Optional [ Organizer ] = None , percent : Optional [ PercentComplete ] = None , priority : Optional [ Priority ] = None , sequence : Optional [ Sequence ] = None , status : Optional [ Status ] = None , url : Optional [ URL ] = None , recurrence_id : Optional [ RecurrenceID ] = None , due : Optional [ Due ] = None , attach : Optional [ List [ Attach ]] = None , attendee : Optional [ List [ Attendee ]] = None , categories : Optional [ List [ Categories ]] = None , contact : Optional [ List [ Contact ]] = None , rstatus : Optional [ List [ RequestStatus ]] = None , related : Optional [ List [ RelatedTo ]] = None , resources : Optional [ List [ Resources ]] = None , alarms : Optional [ List [ VAlarm ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( name = \"VTODO\" , dtstamp = dtstamp , uid = uid , dtstart = dtstart , rrule = rrule , summary = summary , exdate = exdate , rdate = rdate , comment = comment , parent = parent , ) # Optional, may only occur once # As class is a reserved keyword in python, we prefixed it with `ical_`. self . ical_class : Optional [ Class ] = self . as_parent ( ical_class ) self . completed : Optional [ Completed ] = self . as_parent ( completed ) self . created : Optional [ Created ] = self . as_parent ( created ) self . description : Optional [ Description ] = self . as_parent ( description ) self . duration : Optional [ ICALDuration ] = self . as_parent ( duration ) self . geo : Optional [ GEO ] = self . as_parent ( geo ) self . last_modified : Optional [ LastModified ] = self . as_parent ( last_modified ) self . location : Optional [ Location ] = self . as_parent ( location ) self . organizer : Optional [ Organizer ] = self . as_parent ( organizer ) self . percent : Optional [ PercentComplete ] = self . as_parent ( percent ) self . priority : Optional [ Priority ] = self . as_parent ( priority ) self . sequence : Optional [ Sequence ] = self . as_parent ( sequence ) self . status : Optional [ Status ] = self . as_parent ( status ) self . url : Optional [ URL ] = self . as_parent ( url ) self . due : Optional [ Due ] = self . as_parent ( due ) # Optional, may occur more than once self . attach : Optional [ List [ Attach ]] = self . as_parent ( attach ) self . attendee : Optional [ List [ Attendee ]] = self . as_parent ( attendee ) self . categories : Optional [ List [ Categories ]] = self . as_parent ( categories ) self . contact : Optional [ List [ Contact ]] = self . as_parent ( contact ) self . rstatus : Optional [ List [ RequestStatus ]] = self . as_parent ( rstatus ) self . related : Optional [ List [ RelatedTo ]] = self . as_parent ( related ) self . resources : Optional [ List [ Resources ]] = self . as_parent ( resources ) # This is a child component self . alarms : List [ VAlarm ] = alarms or [] def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return ( f \"VToDo( { self . dtstart . value if self . dtstart else '' } - { self . due . value if self . due else '' } : \" f \" { self . summary . value if self . summary else '' } )\" ) @property def ending ( self ) -> Optional [ _DTBoth ]: \"\"\" Return the ending of the vtodo. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . due def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return the duration of the vtodo. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . duration . duration if self . duration else None def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VToDo in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VToDo instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VToDo instances related to this VToDo in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . start , first_event_duration = self . computed_duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringToDo ( original_component_instance = self , start = event_start_time , end = event_end_time , ) . timespan","title":"VToDo"},{"location":"code/components/recurring_components/#ical_library.ical_components.VToDo.ending","text":"Return the ending of the vtodo. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement.","title":"ending"},{"location":"code/components/recurring_components/#ical_library.ical_components.VToDo.expand_component_in_range","text":"Expand this VToDo in range according to its recurring RDate , EXDate and RRule properties. Parameters: Name Type Description Default return_range Timespan The timespan range on which we should return VToDo instances. required starts_to_exclude Union [ List [ Date ], List [ DateTime ]] List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). required Returns: Type Description Iterator [ TimespanWithParent ] Yield all recurring VToDo instances related to this VToDo in the given return_range . Source code in ical_library/ical_components/v_todo.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VToDo in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VToDo instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VToDo instances related to this VToDo in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . start , first_event_duration = self . computed_duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringToDo ( original_component_instance = self , start = event_start_time , end = event_end_time , ) . timespan","title":"expand_component_in_range"},{"location":"code/components/recurring_components/#ical_library.ical_components.VToDo.get_duration","text":"Return the duration of the vtodo. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement. Source code in ical_library/ical_components/v_todo.py 185 186 187 188 189 190 191 def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return the duration of the vtodo. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . duration . duration if self . duration else None","title":"get_duration"},{"location":"code/components/recurring_components/#ical_library.ical_components.VRecurringToDo","text":"Bases: AbstractRecurrence , VToDo This class represents VToDo that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VToDo but without us needing to code the exact same thing twice. Parameters: Name Type Description Default original_component_instance VToDo The original VToDo instance. required start DateTime The start of this occurrence. required end DateTime The end of this occurrence. required Source code in ical_library/ical_components/v_todo.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 class VRecurringToDo ( AbstractRecurrence , VToDo ): \"\"\" This class represents VToDo that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VToDo but without us needing to code the exact same thing twice. :param original_component_instance: The original VToDo instance. :param start: The start of this occurrence. :param end: The end of this occurrence. \"\"\" def __init__ ( self , original_component_instance : VToDo , start : DateTime , end : DateTime ): self . _original = original_component_instance self . _start = start self . _end = end super ( VToDo , self ) . __init__ ( \"VTODO\" , parent = original_component_instance ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"RVToDo( { self . _start } - { self . _end } : { self . original . summary . value if self . original . summary else '' } )\"","title":"VRecurringToDo"},{"location":"code/components/recurring_components/#ical_library.ical_components.VJournal","text":"Bases: AbstractComponentWithRecurringProperties This class represents the VJOURNAL component specified in RFC 5545 in '3.6.3. Journal Component'. A \"VJOURNAL\" calendar component is a grouping of component properties that represent one or more descriptive text notes associated with a particular calendar date. The \"DTSTART\" property is used to specify the calendar date with which the journal entry is associated. Generally, it will have a DATE value data type, but it can also be used to specify a DATE-TIME value data type. Examples of a journal entry include a daily record of a legislative body or a journal entry of individual telephone contacts for the day or an ordered list of accomplishments for the day. The \"VJOURNAL\" calendar component can also be used to associate a document with a calendar date. Parameters: Name Type Description Default name The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None dtstart Optional [ DTStart ] The DTStart property. Optional and may occur at most once. None rrule Optional [ RRule ] The RRule property. Optional and may occur at most once. None summary Optional [ Summary ] The Summary property. Optional and may occur at most once. None exdate Optional [ List [ EXDate ]] The EXDate property. Optional, but may occur multiple times. None rdate Optional [ List [ RDate ]] The RDate property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None ical_class Optional [ Class ] Optional Class property. Optional, but may occur at most once. None created Optional [ Created ] The Created property. Optional, but may occur at most once. None last_modified Optional [ LastModified ] Optional LastModified property. Optional, but may occur at most once. None organizer Optional [ Organizer ] The Organizer property. Optional, but may occur at most once. None sequence Optional [ Sequence ] The Sequence property. Optional, but may occur at most once. None status Optional [ Status ] The Status property. Optional, but may occur at most once. None url Optional [ URL ] The URL property. Optional, but may occur at most once. None recurrence_id Optional [ RecurrenceID ] Optional RecurrenceID property. Optional, but may occur at most once. None attach Optional [ List [ Attach ]] The Attach property. Optional, but may occur multiple times. None attendee Optional [ List [ Attendee ]] The Attendee property. Optional, but may occur multiple times. None categories Optional [ List [ Categories ]] The Categories property. Optional, but may occur multiple times. None contact Optional [ List [ Contact ]] The Contact property. Optional, but may occur multiple times. None description Optional [ List [ Description ]] The Description property. Optional, but may occur multiple times. None related Optional [ List [ RelatedTo ]] The RelatedTo property. Optional, but may occur multiple times. None rstatus Optional [ List [ RequestStatus ]] The RequestStatus property. Optional, but may occur multiple times. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_journal.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class VJournal ( AbstractComponentWithRecurringProperties ): \"\"\" This class represents the VJOURNAL component specified in RFC 5545 in '3.6.3. Journal Component'. A \"VJOURNAL\" calendar component is a grouping of component properties that represent one or more descriptive text notes associated with a particular calendar date. The \"DTSTART\" property is used to specify the calendar date with which the journal entry is associated. Generally, it will have a DATE value data type, but it can also be used to specify a DATE-TIME value data type. Examples of a journal entry include a daily record of a legislative body or a journal entry of individual telephone contacts for the day or an ordered list of accomplishments for the day. The \"VJOURNAL\" calendar component can also be used to associate a document with a calendar date. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param dtstart: The DTStart property. Optional and may occur at most once. :param rrule: The RRule property. Optional and may occur at most once. :param summary: The Summary property. Optional and may occur at most once. :param exdate: The EXDate property. Optional, but may occur multiple times. :param rdate: The RDate property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param ical_class: Optional Class property. Optional, but may occur at most once. :param created: The Created property. Optional, but may occur at most once. :param last_modified: Optional LastModified property. Optional, but may occur at most once. :param organizer: The Organizer property. Optional, but may occur at most once. :param sequence: The Sequence property. Optional, but may occur at most once. :param status: The Status property. Optional, but may occur at most once. :param url: The URL property. Optional, but may occur at most once. :param recurrence_id: Optional RecurrenceID property. Optional, but may occur at most once. :param attach: The Attach property. Optional, but may occur multiple times. :param attendee: The Attendee property. Optional, but may occur multiple times. :param categories: The Categories property. Optional, but may occur multiple times. :param contact: The Contact property. Optional, but may occur multiple times. :param description: The Description property. Optional, but may occur multiple times. :param related: The RelatedTo property. Optional, but may occur multiple times. :param rstatus: The RequestStatus property. Optional, but may occur multiple times. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , dtstart : Optional [ DTStart ] = None , rrule : Optional [ RRule ] = None , summary : Optional [ Summary ] = None , exdate : Optional [ List [ EXDate ]] = None , rdate : Optional [ List [ RDate ]] = None , comment : Optional [ List [ Comment ]] = None , ical_class : Optional [ Class ] = None , created : Optional [ Created ] = None , last_modified : Optional [ LastModified ] = None , organizer : Optional [ Organizer ] = None , sequence : Optional [ Sequence ] = None , status : Optional [ Status ] = None , url : Optional [ URL ] = None , recurrence_id : Optional [ RecurrenceID ] = None , attach : Optional [ List [ Attach ]] = None , attendee : Optional [ List [ Attendee ]] = None , categories : Optional [ List [ Categories ]] = None , contact : Optional [ List [ Contact ]] = None , description : Optional [ List [ Description ]] = None , related : Optional [ List [ RelatedTo ]] = None , rstatus : Optional [ List [ RequestStatus ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( name = \"VJOURNAL\" , dtstamp = dtstamp , uid = uid , dtstart = dtstart , rrule = rrule , summary = summary , exdate = exdate , rdate = rdate , comment = comment , parent = parent , ) # Optional, may only occur once # As class is a reserved keyword in python, we prefixed it with `ical_`. self . ical_class : Optional [ Class ] = self . as_parent ( ical_class ) self . created : Optional [ Created ] = self . as_parent ( created ) self . last_modified : Optional [ LastModified ] = self . as_parent ( last_modified ) self . organizer : Optional [ Organizer ] = self . as_parent ( organizer ) self . sequence : Optional [ Sequence ] = self . as_parent ( sequence ) self . status : Optional [ Status ] = self . as_parent ( status ) self . url : Optional [ URL ] = self . as_parent ( url ) # Optional, may occur more than once self . attach : Optional [ List [ Attach ]] = self . as_parent ( attach ) self . attendee : Optional [ List [ Attendee ]] = self . as_parent ( attendee ) self . categories : Optional [ List [ Categories ]] = self . as_parent ( categories ) self . contact : Optional [ List [ Contact ]] = self . as_parent ( contact ) self . description : Optional [ List [ Description ]] = self . as_parent ( description ) self . related : Optional [ List [ RelatedTo ]] = self . as_parent ( related ) self . rstatus : Optional [ List [ RequestStatus ]] = self . as_parent ( rstatus ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VJournal( { self . start } : { self . summary . value if self . summary else '' } )\" @property def ending ( self ) -> Optional [ _DTBoth ]: \"\"\" Return the start time of the journal. This is because the Journal does not have a duration. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return self . dtstart def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return an empty Duration as a Journal does not have a duration. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return Duration () def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VJournal in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VJournal instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VJournal instances related to this VJournal in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . start , first_event_duration = self . computed_duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringJournal ( original_component_instance = self , start = event_start_time ) . timespan","title":"VJournal"},{"location":"code/components/recurring_components/#ical_library.ical_components.VJournal.ending","text":"Return the start time of the journal. This is because the Journal does not have a duration. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement.","title":"ending"},{"location":"code/components/recurring_components/#ical_library.ical_components.VJournal.expand_component_in_range","text":"Expand this VJournal in range according to its recurring RDate , EXDate and RRule properties. Parameters: Name Type Description Default return_range Timespan The timespan range on which we should return VJournal instances. required starts_to_exclude Union [ List [ Date ], List [ DateTime ]] List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). required Returns: Type Description Iterator [ TimespanWithParent ] Yield all recurring VJournal instances related to this VJournal in the given return_range . Source code in ical_library/ical_components/v_journal.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def expand_component_in_range ( self , return_range : Timespan , starts_to_exclude : Union [ List [ Date ], List [ DateTime ]] ) -> Iterator [ TimespanWithParent ]: \"\"\" Expand this VJournal in range according to its recurring *RDate*, *EXDate* and *RRule* properties. :param return_range: The timespan range on which we should return VJournal instances. :param starts_to_exclude: List of start Dates or list of start DateTimes of which we already know we should exclude them from our recurrence computation (as they have been completely redefined in another element). :return: Yield all recurring VJournal instances related to this VJournal in the given *return_range*. \"\"\" if self . timespan . intersects ( return_range ): yield self . timespan starts_to_exclude . append ( self . start ) start = self . start duration = self . computed_duration if not start or not duration : return None iterator = property_utils . expand_component_in_range ( exdate_list = self . exdate or [], rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . start , first_event_duration = self . computed_duration , starts_to_exclude = starts_to_exclude , return_range = return_range , make_tz_aware = None , ) for event_start_time , event_end_time in iterator : yield VRecurringJournal ( original_component_instance = self , start = event_start_time ) . timespan","title":"expand_component_in_range"},{"location":"code/components/recurring_components/#ical_library.ical_components.VJournal.get_duration","text":"Return an empty Duration as a Journal does not have a duration. Note: This is an abstract method from :class: AbstractComponentWithRecurringProperties we have to implement. Source code in ical_library/ical_components/v_journal.py 143 144 145 146 147 148 149 def get_duration ( self ) -> Optional [ Duration ]: \"\"\" Return an empty Duration as a Journal does not have a duration. Note: This is an abstract method from :class:`AbstractComponentWithRecurringProperties` we have to implement. \"\"\" return Duration ()","title":"get_duration"},{"location":"code/components/recurring_components/#ical_library.ical_components.VRecurringJournal","text":"Bases: AbstractRecurrence , VJournal This class represents VJournal that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VJournal but without us needing to code the exact same thing twice. Parameters: Name Type Description Default original_component_instance VJournal The original VJournal instance. required start DateTime The start of this occurrence. required end The end of this occurrence. required Source code in ical_library/ical_components/v_journal.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 class VRecurringJournal ( AbstractRecurrence , VJournal ): \"\"\" This class represents VJournal that are recurring. Inside the AbstractRecurrence class we overwrite specific dunder methods and property methods. This way our end users have a very similar interface to an actual VJournal but without us needing to code the exact same thing twice. :param original_component_instance: The original VJournal instance. :param start: The start of this occurrence. :param end: The end of this occurrence. \"\"\" def __init__ ( self , original_component_instance : VJournal , start : DateTime ): self . _original = original_component_instance self . _start = start self . _end = start super ( VJournal , self ) . __init__ ( \"VJOURNAL\" , parent = original_component_instance ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"RVJournal( { self . _start } : { self . original . summary . value if self . original . summary else '' } )\"","title":"VRecurringJournal"},{"location":"code/components/simple_components/","text":"Simple components We start out with the components that are relatively straight forward. There is no recurring option here. VFreeBusy Bases: Component This class represents the VFREEBUSY component specified in RFC 5545 in '3.6.4. Free/Busy Component'. A \"VFREEBUSY\" calendar component is a grouping of component properties that represents either a request for free or busy time information, a reply to a request for free or busy time information, or a published set of busy time information. Parameters: Name Type Description Default name The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None contact Optional [ Contact ] The Contact property. Optional, but may occur at most once. None dtstart Optional [ DTStart ] The DTStart property. Optional, but may occur at most once. None dtend Optional [ DTEnd ] The DTEnd property. Optional, but may occur at most once. None organizer Optional [ Organizer ] The Organizer property. Optional, but may occur at most once. None url Optional [ URL ] The URL property. Optional, but may occur at most once. None attendee Optional [ List [ Attendee ]] The Attendee property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None freebusy Optional [ List [ FreeBusyProperty ]] The FreeBusyProperty property. Optional, but may occur multiple times. None rstatus Optional [ List [ RequestStatus ]] The RequestStatus property. Optional, but may occur multiple times. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_free_busy.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class VFreeBusy ( Component ): \"\"\" This class represents the VFREEBUSY component specified in RFC 5545 in '3.6.4. Free/Busy Component'. A \"VFREEBUSY\" calendar component is a grouping of component properties that represents either a request for free or busy time information, a reply to a request for free or busy time information, or a published set of busy time information. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param contact: The Contact property. Optional, but may occur at most once. :param dtstart: The DTStart property. Optional, but may occur at most once. :param dtend: The DTEnd property. Optional, but may occur at most once. :param organizer: The Organizer property. Optional, but may occur at most once. :param url: The URL property. Optional, but may occur at most once. :param attendee: The Attendee property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param freebusy: The FreeBusyProperty property. Optional, but may occur multiple times. :param rstatus: The RequestStatus property. Optional, but may occur multiple times. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , contact : Optional [ Contact ] = None , dtstart : Optional [ DTStart ] = None , dtend : Optional [ DTEnd ] = None , organizer : Optional [ Organizer ] = None , url : Optional [ URL ] = None , attendee : Optional [ List [ Attendee ]] = None , comment : Optional [ List [ Comment ]] = None , freebusy : Optional [ List [ FreeBusyProperty ]] = None , rstatus : Optional [ List [ RequestStatus ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( \"VFREEBUSY\" , parent = parent ) # Required self . _dtstamp : Optional [ DTStamp ] = self . as_parent ( dtstamp ) self . _uid : Optional [ UID ] = self . as_parent ( uid ) # Optional, may only occur once self . contact : Optional [ Contact ] = self . as_parent ( contact ) self . dtstart : Optional [ DTStart ] = self . as_parent ( dtstart ) self . dtend : Optional [ DTEnd ] = self . as_parent ( dtend ) self . organizer : Optional [ Organizer ] = self . as_parent ( organizer ) self . url : Optional [ URL ] = self . as_parent ( url ) # Optional, may occur more than once self . attendee : Optional [ List [ Attendee ]] = self . as_parent ( attendee ) self . comment : Optional [ List [ Comment ]] = self . as_parent ( comment ) self . freebusy : Optional [ List [ FreeBusyProperty ]] = self . as_parent ( freebusy ) self . rstatus : Optional [ List [ RequestStatus ]] = self . as_parent ( rstatus ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VFreeBusy( { self . dtstart . value if self . dtstart else '' } , { self . dtend . value if self . dtend else '' } )\" @property def dtstamp ( self ) -> DTStamp : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _dtstamp is None : raise MissingRequiredProperty ( self , \"dtstamp\" ) return self . _dtstamp @dtstamp . setter def dtstamp ( self , value : DTStamp ): \"\"\"A setter to set the required property.\"\"\" self . _dtstamp = value @property def uid ( self ) -> UID : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _uid is None : raise MissingRequiredProperty ( self , \"uid\" ) return self . _uid @uid . setter def uid ( self , value : UID ): \"\"\"A setter to set the required property.\"\"\" self . _uid = value @property def timespan ( self ) -> Optional [ TimespanWithParent ]: start = self . dtstart . datetime_or_date_value if self . dtstart else None end = self . dtend . datetime_or_date_value if self . dtend else None if start is None : return None if end is None : TimespanWithParent ( parent = self , begin = start , end = start ) return TimespanWithParent ( parent = self , begin = start , end = end ) dtstamp : DTStamp property writable A getter to ensure the required property is set. uid : UID property writable A getter to ensure the required property is set. VAlarm Bases: Component This class represents the VAlarm component specified in RFC 5545 in '3.6.6. Alarm Component'. A \"VALARM\" calendar component is a grouping of component properties that is a reminder or alarm for an event or a to-do. For example, it may be used to define a reminder for a pending event or an overdue to-do. The \"VALARM\" calendar component MUST only appear within either a \"VEVENT\" or \"VTODO\" calendar component Parameters: Name Type Description Default action Optional [ Action ] The Action property. Required and must occur exactly once. None trigger Optional [ Trigger ] The Trigger property. Required and must occur exactly once. None duration Optional [ ICALDuration ] The ICALDuration property. Optional, but may occur at most once. If this item is present, repeat may not be present. None repeat Optional [ Repeat ] The Repeat property. Optional, but may occur at most once. If this item is present, duration may not be present. None attach Optional [ Attach ] The Attach property. Optional, but may occur at most once. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_alarm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class VAlarm ( Component ): \"\"\" This class represents the VAlarm component specified in RFC 5545 in '3.6.6. Alarm Component'. A \"VALARM\" calendar component is a grouping of component properties that is a reminder or alarm for an event or a to-do. For example, it may be used to define a reminder for a pending event or an overdue to-do. The \"VALARM\" calendar component MUST only appear within either a \"VEVENT\" or \"VTODO\" calendar component :param action: The Action property. Required and must occur exactly once. :param trigger: The Trigger property. Required and must occur exactly once. :param duration: The ICALDuration property. Optional, but may occur at most once. If this item is present, repeat may not be present. :param repeat: The Repeat property. Optional, but may occur at most once. If this item is present, duration may not be present. :param attach: The Attach property. Optional, but may occur at most once. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , action : Optional [ Action ] = None , trigger : Optional [ Trigger ] = None , duration : Optional [ ICALDuration ] = None , repeat : Optional [ Repeat ] = None , attach : Optional [ Attach ] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( \"VALARM\" , parent = parent ) # Required self . _action : Optional [ Action ] = self . as_parent ( action ) self . _trigger : Optional [ Trigger ] = self . as_parent ( trigger ) # Both optional and may only occur once. But if one occurs, the other also has to occur. self . duration : Optional [ ICALDuration ] = self . as_parent ( duration ) self . repeat : Optional [ Repeat ] = self . as_parent ( repeat ) # Optional, may only occur once self . attach : Optional [ Attach ] = self . as_parent ( attach ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VAlarm( { self . action . value } : { self . trigger . value } )\" @property def action ( self ) -> Action : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _action is None : raise MissingRequiredProperty ( self , \"action\" ) return self . _action @action . setter def action ( self , value : Action ): \"\"\"A setter to set the required property.\"\"\" self . _action = value @property def trigger ( self ) -> Trigger : \"\"\"Getter that ensures the required property is set.\"\"\" if self . _trigger is None : raise MissingRequiredProperty ( self , \"trigger\" ) return self . _trigger @trigger . setter def trigger ( self , value : Trigger ): \"\"\"A setter to set the required property.\"\"\" self . _trigger = value action : Action property writable A getter to ensure the required property is set. trigger : Trigger property writable Getter that ensures the required property is set.","title":"Simple components"},{"location":"code/components/simple_components/#simple-components","text":"We start out with the components that are relatively straight forward. There is no recurring option here.","title":"Simple components"},{"location":"code/components/simple_components/#ical_library.ical_components.VFreeBusy","text":"Bases: Component This class represents the VFREEBUSY component specified in RFC 5545 in '3.6.4. Free/Busy Component'. A \"VFREEBUSY\" calendar component is a grouping of component properties that represents either a request for free or busy time information, a reply to a request for free or busy time information, or a published set of busy time information. Parameters: Name Type Description Default name The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required dtstamp Optional [ DTStamp ] The DTStamp property. Required and must occur exactly once. None uid Optional [ UID ] The UID property. Required and must occur exactly once. None contact Optional [ Contact ] The Contact property. Optional, but may occur at most once. None dtstart Optional [ DTStart ] The DTStart property. Optional, but may occur at most once. None dtend Optional [ DTEnd ] The DTEnd property. Optional, but may occur at most once. None organizer Optional [ Organizer ] The Organizer property. Optional, but may occur at most once. None url Optional [ URL ] The URL property. Optional, but may occur at most once. None attendee Optional [ List [ Attendee ]] The Attendee property. Optional, but may occur multiple times. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None freebusy Optional [ List [ FreeBusyProperty ]] The FreeBusyProperty property. Optional, but may occur multiple times. None rstatus Optional [ List [ RequestStatus ]] The RequestStatus property. Optional, but may occur multiple times. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_free_busy.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class VFreeBusy ( Component ): \"\"\" This class represents the VFREEBUSY component specified in RFC 5545 in '3.6.4. Free/Busy Component'. A \"VFREEBUSY\" calendar component is a grouping of component properties that represents either a request for free or busy time information, a reply to a request for free or busy time information, or a published set of busy time information. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param dtstamp: The DTStamp property. Required and must occur exactly once. :param uid: The UID property. Required and must occur exactly once. :param contact: The Contact property. Optional, but may occur at most once. :param dtstart: The DTStart property. Optional, but may occur at most once. :param dtend: The DTEnd property. Optional, but may occur at most once. :param organizer: The Organizer property. Optional, but may occur at most once. :param url: The URL property. Optional, but may occur at most once. :param attendee: The Attendee property. Optional, but may occur multiple times. :param comment: The Comment property. Optional, but may occur multiple times. :param freebusy: The FreeBusyProperty property. Optional, but may occur multiple times. :param rstatus: The RequestStatus property. Optional, but may occur multiple times. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , dtstamp : Optional [ DTStamp ] = None , uid : Optional [ UID ] = None , contact : Optional [ Contact ] = None , dtstart : Optional [ DTStart ] = None , dtend : Optional [ DTEnd ] = None , organizer : Optional [ Organizer ] = None , url : Optional [ URL ] = None , attendee : Optional [ List [ Attendee ]] = None , comment : Optional [ List [ Comment ]] = None , freebusy : Optional [ List [ FreeBusyProperty ]] = None , rstatus : Optional [ List [ RequestStatus ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( \"VFREEBUSY\" , parent = parent ) # Required self . _dtstamp : Optional [ DTStamp ] = self . as_parent ( dtstamp ) self . _uid : Optional [ UID ] = self . as_parent ( uid ) # Optional, may only occur once self . contact : Optional [ Contact ] = self . as_parent ( contact ) self . dtstart : Optional [ DTStart ] = self . as_parent ( dtstart ) self . dtend : Optional [ DTEnd ] = self . as_parent ( dtend ) self . organizer : Optional [ Organizer ] = self . as_parent ( organizer ) self . url : Optional [ URL ] = self . as_parent ( url ) # Optional, may occur more than once self . attendee : Optional [ List [ Attendee ]] = self . as_parent ( attendee ) self . comment : Optional [ List [ Comment ]] = self . as_parent ( comment ) self . freebusy : Optional [ List [ FreeBusyProperty ]] = self . as_parent ( freebusy ) self . rstatus : Optional [ List [ RequestStatus ]] = self . as_parent ( rstatus ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VFreeBusy( { self . dtstart . value if self . dtstart else '' } , { self . dtend . value if self . dtend else '' } )\" @property def dtstamp ( self ) -> DTStamp : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _dtstamp is None : raise MissingRequiredProperty ( self , \"dtstamp\" ) return self . _dtstamp @dtstamp . setter def dtstamp ( self , value : DTStamp ): \"\"\"A setter to set the required property.\"\"\" self . _dtstamp = value @property def uid ( self ) -> UID : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _uid is None : raise MissingRequiredProperty ( self , \"uid\" ) return self . _uid @uid . setter def uid ( self , value : UID ): \"\"\"A setter to set the required property.\"\"\" self . _uid = value @property def timespan ( self ) -> Optional [ TimespanWithParent ]: start = self . dtstart . datetime_or_date_value if self . dtstart else None end = self . dtend . datetime_or_date_value if self . dtend else None if start is None : return None if end is None : TimespanWithParent ( parent = self , begin = start , end = start ) return TimespanWithParent ( parent = self , begin = start , end = end )","title":"VFreeBusy"},{"location":"code/components/simple_components/#ical_library.ical_components.VFreeBusy.dtstamp","text":"A getter to ensure the required property is set.","title":"dtstamp"},{"location":"code/components/simple_components/#ical_library.ical_components.VFreeBusy.uid","text":"A getter to ensure the required property is set.","title":"uid"},{"location":"code/components/simple_components/#ical_library.ical_components.VAlarm","text":"Bases: Component This class represents the VAlarm component specified in RFC 5545 in '3.6.6. Alarm Component'. A \"VALARM\" calendar component is a grouping of component properties that is a reminder or alarm for an event or a to-do. For example, it may be used to define a reminder for a pending event or an overdue to-do. The \"VALARM\" calendar component MUST only appear within either a \"VEVENT\" or \"VTODO\" calendar component Parameters: Name Type Description Default action Optional [ Action ] The Action property. Required and must occur exactly once. None trigger Optional [ Trigger ] The Trigger property. Required and must occur exactly once. None duration Optional [ ICALDuration ] The ICALDuration property. Optional, but may occur at most once. If this item is present, repeat may not be present. None repeat Optional [ Repeat ] The Repeat property. Optional, but may occur at most once. If this item is present, duration may not be present. None attach Optional [ Attach ] The Attach property. Optional, but may occur at most once. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_alarm.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class VAlarm ( Component ): \"\"\" This class represents the VAlarm component specified in RFC 5545 in '3.6.6. Alarm Component'. A \"VALARM\" calendar component is a grouping of component properties that is a reminder or alarm for an event or a to-do. For example, it may be used to define a reminder for a pending event or an overdue to-do. The \"VALARM\" calendar component MUST only appear within either a \"VEVENT\" or \"VTODO\" calendar component :param action: The Action property. Required and must occur exactly once. :param trigger: The Trigger property. Required and must occur exactly once. :param duration: The ICALDuration property. Optional, but may occur at most once. If this item is present, repeat may not be present. :param repeat: The Repeat property. Optional, but may occur at most once. If this item is present, duration may not be present. :param attach: The Attach property. Optional, but may occur at most once. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , action : Optional [ Action ] = None , trigger : Optional [ Trigger ] = None , duration : Optional [ ICALDuration ] = None , repeat : Optional [ Repeat ] = None , attach : Optional [ Attach ] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( \"VALARM\" , parent = parent ) # Required self . _action : Optional [ Action ] = self . as_parent ( action ) self . _trigger : Optional [ Trigger ] = self . as_parent ( trigger ) # Both optional and may only occur once. But if one occurs, the other also has to occur. self . duration : Optional [ ICALDuration ] = self . as_parent ( duration ) self . repeat : Optional [ Repeat ] = self . as_parent ( repeat ) # Optional, may only occur once self . attach : Optional [ Attach ] = self . as_parent ( attach ) def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VAlarm( { self . action . value } : { self . trigger . value } )\" @property def action ( self ) -> Action : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _action is None : raise MissingRequiredProperty ( self , \"action\" ) return self . _action @action . setter def action ( self , value : Action ): \"\"\"A setter to set the required property.\"\"\" self . _action = value @property def trigger ( self ) -> Trigger : \"\"\"Getter that ensures the required property is set.\"\"\" if self . _trigger is None : raise MissingRequiredProperty ( self , \"trigger\" ) return self . _trigger @trigger . setter def trigger ( self , value : Trigger ): \"\"\"A setter to set the required property.\"\"\" self . _trigger = value","title":"VAlarm"},{"location":"code/components/simple_components/#ical_library.ical_components.VAlarm.action","text":"A getter to ensure the required property is set.","title":"action"},{"location":"code/components/simple_components/#ical_library.ical_components.VAlarm.trigger","text":"Getter that ensures the required property is set.","title":"trigger"},{"location":"code/components/timezone_components/","text":"Timezone components These are the components that are related to TimeZone information. You generally don't use these directly but let iCal-library use it when there is a TZID parameter set for a property. The DayLight and Standard class both extend the _TimeOffsetPeriod . VTimeZone Bases: Component This class represents the VTIMEZONE component specified in RFC 5545 in '3.6.5. Time Zone Component'. If present, the \"VTIMEZONE\" calendar component defines the set of Standard Time and Daylight Saving Time observances (or rules) for a particular time zone for a given interval of time. The \"VTIMEZONE\" calendar component cannot be nested within other calendar components. Multiple \"VTIMEZONE\" calendar components can exist in an iCalendar object. In this situation, each \"VTIMEZONE\" MUST represent a unique time zone definition. This is necessary for some classes of events, such as airline flights, that start in one time zone and end in another. Parameters: Name Type Description Default parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None tzid Optional [ TZID ] The TZID property. Required and must occur exactly once. None last_mod Optional [ LastModified ] Optional LastModified property. Optional, but may occur at most once. None tzurl Optional [ TZURL ] The TZURL property. Optional, but may occur at most once. None standardc Optional [ List [ Standard ]] Optional list of Standard components. Each component may occur multiple times. Either standardc or daylightc must contain at least one TimeOffsetPeriod. None daylightc Optional [ List [ DayLight ]] Optional list of DayLight components. Each component may occur multiple times. Either standardc or daylightc must contain at least one TimeOffsetPeriod. None Source code in ical_library/ical_components/v_timezone.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class VTimeZone ( Component ): \"\"\" This class represents the VTIMEZONE component specified in RFC 5545 in '3.6.5. Time Zone Component'. If present, the \"VTIMEZONE\" calendar component defines the set of Standard Time and Daylight Saving Time observances (or rules) for a particular time zone for a given interval of time. The \"VTIMEZONE\" calendar component cannot be nested within other calendar components. Multiple \"VTIMEZONE\" calendar components can exist in an iCalendar object. In this situation, each \"VTIMEZONE\" MUST represent a unique time zone definition. This is necessary for some classes of events, such as airline flights, that start in one time zone and end in another. :param parent: The Component this item is encapsulated by in the iCalendar data file. :param tzid: The TZID property. Required and must occur exactly once. :param last_mod: Optional LastModified property. Optional, but may occur at most once. :param tzurl: The TZURL property. Optional, but may occur at most once. :param standardc: Optional list of Standard components. Each component may occur multiple times. Either standardc or daylightc must contain at least one TimeOffsetPeriod. :param daylightc: Optional list of DayLight components. Each component may occur multiple times. Either standardc or daylightc must contain at least one TimeOffsetPeriod. \"\"\" def __init__ ( self , tzid : Optional [ TZID ] = None , last_mod : Optional [ LastModified ] = None , tzurl : Optional [ TZURL ] = None , standardc : Optional [ List [ Standard ]] = None , daylightc : Optional [ List [ DayLight ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( \"VTIMEZONE\" , parent = parent ) # Required properties, must occur one. self . _tzid : Optional [ TZID ] = self . as_parent ( tzid ) # Optional properties, may only occur once. self . last_mod : Optional [ LastModified ] = self . as_parent ( last_mod ) self . tzurl : Optional [ TZURL ] = self . as_parent ( tzurl ) # Either one of these components must have at least one record. May occur multiple times. self . standardc : List [ Standard ] = standardc or [] self . daylightc : List [ DayLight ] = daylightc or [] self . __storage_of_results : Dict [ DateTime , List [ Tuple [ DateTime , _TimeOffsetPeriod ]]] = {} def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VTimeZone( { self . tzid . value } )\" @property def tzid ( self ) -> TZID : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _tzid is None : raise MissingRequiredProperty ( self , \"tzid\" ) return self . _tzid @tzid . setter def tzid ( self , value : TZID ): \"\"\"A setter to set the required property.\"\"\" self . _tzid = value def get_ordered_timezone_overview ( self , max_datetime : DateTime ) -> List [ Tuple [ DateTime , _TimeOffsetPeriod ]]: \"\"\" Expand all TimeOffsetPeriod configuration and return them in an ordered by time fashion. :param max_datetime: The maximum datetime value we wish to expand to. :return: A sorted list on datetime containing tuples of datetime and offset period where the datetime is lower than *max_datetime*. \"\"\" if max_datetime in self . __storage_of_results . keys (): return self . __storage_of_results [ max_datetime ] all_timezones : List [ Tuple [ Union [ DateTime , Date ], _TimeOffsetPeriod ]] = [] for a_standard in self . standardc : all_timezones . extend ( a_standard . get_time_sequence ( max_datetime = max_datetime )) for a_daylight in self . daylightc : all_timezones . extend ( a_daylight . get_time_sequence ( max_datetime = max_datetime )) sorted_list = sorted ( all_timezones , key = lambda tup : tup [ 0 ]) self . __storage_of_results [ max_datetime ] = sorted_list return sorted_list def convert_naive_datetime_to_aware ( self , dt : DateTime ) -> DateTime : \"\"\" Convert a naive datetime to an aware datetime using the configuration of this TimeZone object. :param dt: The (possibly naive) datetime to convert to this timezone configuration. :return: The timezone aware datetime. \"\"\" if dt . tzinfo is not None : return dt return dt . in_timezone ( self . get_as_timezone_object ()) def get_ordered_timezone_overview_as_transition ( self , max_datetime : DateTime ) -> List [ Transition ]: \"\"\" Get timezone components as a list of pendulum Transitions. :param max_datetime: The maximum datetime for which we include transitions. Any transitions after are excluded. :return: Return the list of pendulum Transitions for this VTimezone. \"\"\" timezones : List [ Tuple [ DateTime , _TimeOffsetPeriod ]] = self . get_ordered_timezone_overview ( max_datetime ) transitions : List [ Transition ] = [] previous_transition : Optional [ Transition ] = None for time , offset_period in timezones : new_transition_type = TransitionType ( offset = offset_period . tzoffsetto . parse_value_as_seconds (), is_dst = offset_period . is_dst , abbr = offset_period . tzname [ 0 ] . value if offset_period . tzname else \"unknown\" , ) at = int ( time . in_tz ( \"UTC\" ) . timestamp ()) new_transition = Transition ( at = at , ttype = new_transition_type , previous = previous_transition ) previous_transition = new_transition transitions . append ( new_transition ) return transitions @instance_lru_cache () def get_as_timezone_object ( self , max_datetime : DateTime = DateTime ( 2100 , 1 , 1 )) -> Timezone : \"\"\" For a given maximum datetime, compute a pendulum Timezone object that contains all transition till max_datetime. :param max_datetime: The maximum datetime for which we include transitions. Any transitions after are excluded. :return: Returns a pendulum Timezone object that you can use for DateTimes. \"\"\" return CustomTimezone ( name = self . tzid . value , transitions = self . get_ordered_timezone_overview_as_transition ( max_datetime ) ) tzid : TZID property writable A getter to ensure the required property is set. convert_naive_datetime_to_aware ( dt ) Convert a naive datetime to an aware datetime using the configuration of this TimeZone object. Parameters: Name Type Description Default dt DateTime The (possibly naive) datetime to convert to this timezone configuration. required Returns: Type Description DateTime The timezone aware datetime. Source code in ical_library/ical_components/v_timezone.py 189 190 191 192 193 194 195 196 197 def convert_naive_datetime_to_aware ( self , dt : DateTime ) -> DateTime : \"\"\" Convert a naive datetime to an aware datetime using the configuration of this TimeZone object. :param dt: The (possibly naive) datetime to convert to this timezone configuration. :return: The timezone aware datetime. \"\"\" if dt . tzinfo is not None : return dt return dt . in_timezone ( self . get_as_timezone_object ()) get_as_timezone_object ( max_datetime = DateTime ( 2100 , 1 , 1 )) For a given maximum datetime, compute a pendulum Timezone object that contains all transition till max_datetime. Parameters: Name Type Description Default max_datetime DateTime The maximum datetime for which we include transitions. Any transitions after are excluded. DateTime (2100, 1, 1) Returns: Type Description Timezone Returns a pendulum Timezone object that you can use for DateTimes. Source code in ical_library/ical_components/v_timezone.py 220 221 222 223 224 225 226 227 228 229 @instance_lru_cache () def get_as_timezone_object ( self , max_datetime : DateTime = DateTime ( 2100 , 1 , 1 )) -> Timezone : \"\"\" For a given maximum datetime, compute a pendulum Timezone object that contains all transition till max_datetime. :param max_datetime: The maximum datetime for which we include transitions. Any transitions after are excluded. :return: Returns a pendulum Timezone object that you can use for DateTimes. \"\"\" return CustomTimezone ( name = self . tzid . value , transitions = self . get_ordered_timezone_overview_as_transition ( max_datetime ) ) get_ordered_timezone_overview ( max_datetime ) Expand all TimeOffsetPeriod configuration and return them in an ordered by time fashion. Parameters: Name Type Description Default max_datetime DateTime The maximum datetime value we wish to expand to. required Returns: Type Description List [ Tuple [ DateTime , _TimeOffsetPeriod ]] A sorted list on datetime containing tuples of datetime and offset period where the datetime is lower than max_datetime . Source code in ical_library/ical_components/v_timezone.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def get_ordered_timezone_overview ( self , max_datetime : DateTime ) -> List [ Tuple [ DateTime , _TimeOffsetPeriod ]]: \"\"\" Expand all TimeOffsetPeriod configuration and return them in an ordered by time fashion. :param max_datetime: The maximum datetime value we wish to expand to. :return: A sorted list on datetime containing tuples of datetime and offset period where the datetime is lower than *max_datetime*. \"\"\" if max_datetime in self . __storage_of_results . keys (): return self . __storage_of_results [ max_datetime ] all_timezones : List [ Tuple [ Union [ DateTime , Date ], _TimeOffsetPeriod ]] = [] for a_standard in self . standardc : all_timezones . extend ( a_standard . get_time_sequence ( max_datetime = max_datetime )) for a_daylight in self . daylightc : all_timezones . extend ( a_daylight . get_time_sequence ( max_datetime = max_datetime )) sorted_list = sorted ( all_timezones , key = lambda tup : tup [ 0 ]) self . __storage_of_results [ max_datetime ] = sorted_list return sorted_list get_ordered_timezone_overview_as_transition ( max_datetime ) Get timezone components as a list of pendulum Transitions. Parameters: Name Type Description Default max_datetime DateTime The maximum datetime for which we include transitions. Any transitions after are excluded. required Returns: Type Description List [ Transition ] Return the list of pendulum Transitions for this VTimezone. Source code in ical_library/ical_components/v_timezone.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def get_ordered_timezone_overview_as_transition ( self , max_datetime : DateTime ) -> List [ Transition ]: \"\"\" Get timezone components as a list of pendulum Transitions. :param max_datetime: The maximum datetime for which we include transitions. Any transitions after are excluded. :return: Return the list of pendulum Transitions for this VTimezone. \"\"\" timezones : List [ Tuple [ DateTime , _TimeOffsetPeriod ]] = self . get_ordered_timezone_overview ( max_datetime ) transitions : List [ Transition ] = [] previous_transition : Optional [ Transition ] = None for time , offset_period in timezones : new_transition_type = TransitionType ( offset = offset_period . tzoffsetto . parse_value_as_seconds (), is_dst = offset_period . is_dst , abbr = offset_period . tzname [ 0 ] . value if offset_period . tzname else \"unknown\" , ) at = int ( time . in_tz ( \"UTC\" ) . timestamp ()) new_transition = Transition ( at = at , ttype = new_transition_type , previous = previous_transition ) previous_transition = new_transition transitions . append ( new_transition ) return transitions _TimeOffsetPeriod Bases: Component A _TimeOffsetPeriod representing either a Standard configuration or a Winter configuration. Parameters: Name Type Description Default name str The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required dtstart Optional [ DTStart ] The DTStart property. Required and must occur exactly once. None tzoffsetto Optional [ TZOffsetTo ] The TZOffsetTo property. Required and must occur exactly once. None tzoffsetfrom Optional [ TZOffsetFrom ] The TZOffsetFrom property. Required and must occur exactly once. None rrule Optional [ RRule ] The RRule property. Optional, but may occur at most once. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None rdate Optional [ List [ RDate ]] The RDate property. Optional, but may occur multiple times. None tzname Optional [ List [ TZName ]] The TZName property. Optional, but may occur multiple times. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_timezone.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class _TimeOffsetPeriod ( Component ): \"\"\" A _TimeOffsetPeriod representing either a Standard configuration or a Winter configuration. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param dtstart: The DTStart property. Required and must occur exactly once. :param tzoffsetto: The TZOffsetTo property. Required and must occur exactly once. :param tzoffsetfrom: The TZOffsetFrom property. Required and must occur exactly once. :param rrule: The RRule property. Optional, but may occur at most once. :param comment: The Comment property. Optional, but may occur multiple times. :param rdate: The RDate property. Optional, but may occur multiple times. :param tzname: The TZName property. Optional, but may occur multiple times. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , name : str , dtstart : Optional [ DTStart ] = None , tzoffsetto : Optional [ TZOffsetTo ] = None , tzoffsetfrom : Optional [ TZOffsetFrom ] = None , rrule : Optional [ RRule ] = None , comment : Optional [ List [ Comment ]] = None , rdate : Optional [ List [ RDate ]] = None , tzname : Optional [ List [ TZName ]] = None , parent : Optional [ Component ] = None , is_dst : bool = False , ): super () . __init__ ( name , parent = parent ) # Required, must occur only once. self . dtstart : Optional [ DTStart ] = self . as_parent ( dtstart ) self . tzoffsetto : Optional [ TZOffsetTo ] = self . as_parent ( tzoffsetto ) self . tzoffsetfrom : Optional [ TZOffsetFrom ] = self . as_parent ( tzoffsetfrom ) # Optional, may only occur once. self . rrule : Optional [ RRule ] = self . as_parent ( rrule ) # Optional, may occur more than once. self . comment : Optional [ List [ Comment ]] = self . as_parent ( comment ) self . rdate : Optional [ List [ RDate ]] = self . as_parent ( rdate ) self . tzname : Optional [ List [ TZName ]] = self . as_parent ( tzname ) self . is_dst = is_dst def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \" { self . __class__ . __name__ } ( { self . dtstart . value } : { self . tzoffsetto . value } )\" def timezone_aware_start ( self ) -> DateTime : \"\"\"Return a timezone aware start.\"\"\" dt : DateTime = dt_utils . convert_time_object_to_datetime ( self . dtstart . datetime_or_date_value ) return dt . in_timezone ( tz = self . tzoffsetfrom . as_timezone_object ()) def get_time_sequence ( self , max_datetime : Optional [ DateTime ] = None ) -> Iterator [ Tuple [ DateTime , \"_TimeOffsetPeriod\" ]]: \"\"\" Expand the TimeZone start date according to its recurring *RDate* and *RRule* properties. :param max_datetime: The maximum datetime value we wish to expand to. :return: Yield all the datetime values according to the recurring properties that are lower than *max_datetime*. \"\"\" for rtime in property_utils . expand_event_in_range_only_return_first ( rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . timezone_aware_start (), return_range = Timespan ( self . timezone_aware_start () - timedelta ( days = 1 ), max_datetime ), make_tz_aware = self . tzoffsetfrom . as_timezone_object (), ): if not isinstance ( rtime , DateTime ): raise TypeError ( f \" { rtime } was expected to be a DateTime object.\" ) yield rtime , self get_time_sequence ( max_datetime = None ) Expand the TimeZone start date according to its recurring RDate and RRule properties. Parameters: Name Type Description Default max_datetime Optional [ DateTime ] The maximum datetime value we wish to expand to. None Returns: Type Description Iterator [ Tuple [ DateTime , _TimeOffsetPeriod ]] Yield all the datetime values according to the recurring properties that are lower than max_datetime . Source code in ical_library/ical_components/v_timezone.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def get_time_sequence ( self , max_datetime : Optional [ DateTime ] = None ) -> Iterator [ Tuple [ DateTime , \"_TimeOffsetPeriod\" ]]: \"\"\" Expand the TimeZone start date according to its recurring *RDate* and *RRule* properties. :param max_datetime: The maximum datetime value we wish to expand to. :return: Yield all the datetime values according to the recurring properties that are lower than *max_datetime*. \"\"\" for rtime in property_utils . expand_event_in_range_only_return_first ( rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . timezone_aware_start (), return_range = Timespan ( self . timezone_aware_start () - timedelta ( days = 1 ), max_datetime ), make_tz_aware = self . tzoffsetfrom . as_timezone_object (), ): if not isinstance ( rtime , DateTime ): raise TypeError ( f \" { rtime } was expected to be a DateTime object.\" ) yield rtime , self timezone_aware_start () Return a timezone aware start. Source code in ical_library/ical_components/v_timezone.py 66 67 68 69 def timezone_aware_start ( self ) -> DateTime : \"\"\"Return a timezone aware start.\"\"\" dt : DateTime = dt_utils . convert_time_object_to_datetime ( self . dtstart . datetime_or_date_value ) return dt . in_timezone ( tz = self . tzoffsetfrom . as_timezone_object ()) DayLight Bases: _TimeOffsetPeriod A TimeOffsetPeriod representing a DayLight(a.k.a. Advanced Time, Summer Time or Legal Time) configuration. Source code in ical_library/ical_components/v_timezone.py 91 92 93 94 95 96 97 98 99 class DayLight ( _TimeOffsetPeriod ): \"\"\"A TimeOffsetPeriod representing a DayLight(a.k.a. Advanced Time, Summer Time or Legal Time) configuration.\"\"\" def __init__ ( self , parent : Optional [ Component ] = None , ** kwargs ): super () . __init__ ( \"DAYLIGHT\" , parent = parent , is_dst = True , ** kwargs ) @classmethod def _get_init_method_for_var_mapping ( cls ) -> Callable : return _TimeOffsetPeriod . __init__ Standard Bases: _TimeOffsetPeriod A TimeOffsetPeriod representing a Standard(a.k.a. Winter Time) configuration. Source code in ical_library/ical_components/v_timezone.py 102 103 104 105 106 107 108 109 110 class Standard ( _TimeOffsetPeriod ): \"\"\"A TimeOffsetPeriod representing a Standard(a.k.a. Winter Time) configuration.\"\"\" def __init__ ( self , parent : Optional [ Component ] = None , ** kwargs ): super () . __init__ ( \"STANDARD\" , parent = parent , is_dst = False , ** kwargs ) @classmethod def _get_init_method_for_var_mapping ( cls ) -> Callable : return _TimeOffsetPeriod . __init__","title":"Timezone components"},{"location":"code/components/timezone_components/#timezone-components","text":"These are the components that are related to TimeZone information. You generally don't use these directly but let iCal-library use it when there is a TZID parameter set for a property. The DayLight and Standard class both extend the _TimeOffsetPeriod .","title":"Timezone components"},{"location":"code/components/timezone_components/#ical_library.ical_components.VTimeZone","text":"Bases: Component This class represents the VTIMEZONE component specified in RFC 5545 in '3.6.5. Time Zone Component'. If present, the \"VTIMEZONE\" calendar component defines the set of Standard Time and Daylight Saving Time observances (or rules) for a particular time zone for a given interval of time. The \"VTIMEZONE\" calendar component cannot be nested within other calendar components. Multiple \"VTIMEZONE\" calendar components can exist in an iCalendar object. In this situation, each \"VTIMEZONE\" MUST represent a unique time zone definition. This is necessary for some classes of events, such as airline flights, that start in one time zone and end in another. Parameters: Name Type Description Default parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None tzid Optional [ TZID ] The TZID property. Required and must occur exactly once. None last_mod Optional [ LastModified ] Optional LastModified property. Optional, but may occur at most once. None tzurl Optional [ TZURL ] The TZURL property. Optional, but may occur at most once. None standardc Optional [ List [ Standard ]] Optional list of Standard components. Each component may occur multiple times. Either standardc or daylightc must contain at least one TimeOffsetPeriod. None daylightc Optional [ List [ DayLight ]] Optional list of DayLight components. Each component may occur multiple times. Either standardc or daylightc must contain at least one TimeOffsetPeriod. None Source code in ical_library/ical_components/v_timezone.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 class VTimeZone ( Component ): \"\"\" This class represents the VTIMEZONE component specified in RFC 5545 in '3.6.5. Time Zone Component'. If present, the \"VTIMEZONE\" calendar component defines the set of Standard Time and Daylight Saving Time observances (or rules) for a particular time zone for a given interval of time. The \"VTIMEZONE\" calendar component cannot be nested within other calendar components. Multiple \"VTIMEZONE\" calendar components can exist in an iCalendar object. In this situation, each \"VTIMEZONE\" MUST represent a unique time zone definition. This is necessary for some classes of events, such as airline flights, that start in one time zone and end in another. :param parent: The Component this item is encapsulated by in the iCalendar data file. :param tzid: The TZID property. Required and must occur exactly once. :param last_mod: Optional LastModified property. Optional, but may occur at most once. :param tzurl: The TZURL property. Optional, but may occur at most once. :param standardc: Optional list of Standard components. Each component may occur multiple times. Either standardc or daylightc must contain at least one TimeOffsetPeriod. :param daylightc: Optional list of DayLight components. Each component may occur multiple times. Either standardc or daylightc must contain at least one TimeOffsetPeriod. \"\"\" def __init__ ( self , tzid : Optional [ TZID ] = None , last_mod : Optional [ LastModified ] = None , tzurl : Optional [ TZURL ] = None , standardc : Optional [ List [ Standard ]] = None , daylightc : Optional [ List [ DayLight ]] = None , parent : Optional [ Component ] = None , ): super () . __init__ ( \"VTIMEZONE\" , parent = parent ) # Required properties, must occur one. self . _tzid : Optional [ TZID ] = self . as_parent ( tzid ) # Optional properties, may only occur once. self . last_mod : Optional [ LastModified ] = self . as_parent ( last_mod ) self . tzurl : Optional [ TZURL ] = self . as_parent ( tzurl ) # Either one of these components must have at least one record. May occur multiple times. self . standardc : List [ Standard ] = standardc or [] self . daylightc : List [ DayLight ] = daylightc or [] self . __storage_of_results : Dict [ DateTime , List [ Tuple [ DateTime , _TimeOffsetPeriod ]]] = {} def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \"VTimeZone( { self . tzid . value } )\" @property def tzid ( self ) -> TZID : \"\"\"A getter to ensure the required property is set.\"\"\" if self . _tzid is None : raise MissingRequiredProperty ( self , \"tzid\" ) return self . _tzid @tzid . setter def tzid ( self , value : TZID ): \"\"\"A setter to set the required property.\"\"\" self . _tzid = value def get_ordered_timezone_overview ( self , max_datetime : DateTime ) -> List [ Tuple [ DateTime , _TimeOffsetPeriod ]]: \"\"\" Expand all TimeOffsetPeriod configuration and return them in an ordered by time fashion. :param max_datetime: The maximum datetime value we wish to expand to. :return: A sorted list on datetime containing tuples of datetime and offset period where the datetime is lower than *max_datetime*. \"\"\" if max_datetime in self . __storage_of_results . keys (): return self . __storage_of_results [ max_datetime ] all_timezones : List [ Tuple [ Union [ DateTime , Date ], _TimeOffsetPeriod ]] = [] for a_standard in self . standardc : all_timezones . extend ( a_standard . get_time_sequence ( max_datetime = max_datetime )) for a_daylight in self . daylightc : all_timezones . extend ( a_daylight . get_time_sequence ( max_datetime = max_datetime )) sorted_list = sorted ( all_timezones , key = lambda tup : tup [ 0 ]) self . __storage_of_results [ max_datetime ] = sorted_list return sorted_list def convert_naive_datetime_to_aware ( self , dt : DateTime ) -> DateTime : \"\"\" Convert a naive datetime to an aware datetime using the configuration of this TimeZone object. :param dt: The (possibly naive) datetime to convert to this timezone configuration. :return: The timezone aware datetime. \"\"\" if dt . tzinfo is not None : return dt return dt . in_timezone ( self . get_as_timezone_object ()) def get_ordered_timezone_overview_as_transition ( self , max_datetime : DateTime ) -> List [ Transition ]: \"\"\" Get timezone components as a list of pendulum Transitions. :param max_datetime: The maximum datetime for which we include transitions. Any transitions after are excluded. :return: Return the list of pendulum Transitions for this VTimezone. \"\"\" timezones : List [ Tuple [ DateTime , _TimeOffsetPeriod ]] = self . get_ordered_timezone_overview ( max_datetime ) transitions : List [ Transition ] = [] previous_transition : Optional [ Transition ] = None for time , offset_period in timezones : new_transition_type = TransitionType ( offset = offset_period . tzoffsetto . parse_value_as_seconds (), is_dst = offset_period . is_dst , abbr = offset_period . tzname [ 0 ] . value if offset_period . tzname else \"unknown\" , ) at = int ( time . in_tz ( \"UTC\" ) . timestamp ()) new_transition = Transition ( at = at , ttype = new_transition_type , previous = previous_transition ) previous_transition = new_transition transitions . append ( new_transition ) return transitions @instance_lru_cache () def get_as_timezone_object ( self , max_datetime : DateTime = DateTime ( 2100 , 1 , 1 )) -> Timezone : \"\"\" For a given maximum datetime, compute a pendulum Timezone object that contains all transition till max_datetime. :param max_datetime: The maximum datetime for which we include transitions. Any transitions after are excluded. :return: Returns a pendulum Timezone object that you can use for DateTimes. \"\"\" return CustomTimezone ( name = self . tzid . value , transitions = self . get_ordered_timezone_overview_as_transition ( max_datetime ) )","title":"VTimeZone"},{"location":"code/components/timezone_components/#ical_library.ical_components.VTimeZone.tzid","text":"A getter to ensure the required property is set.","title":"tzid"},{"location":"code/components/timezone_components/#ical_library.ical_components.VTimeZone.convert_naive_datetime_to_aware","text":"Convert a naive datetime to an aware datetime using the configuration of this TimeZone object. Parameters: Name Type Description Default dt DateTime The (possibly naive) datetime to convert to this timezone configuration. required Returns: Type Description DateTime The timezone aware datetime. Source code in ical_library/ical_components/v_timezone.py 189 190 191 192 193 194 195 196 197 def convert_naive_datetime_to_aware ( self , dt : DateTime ) -> DateTime : \"\"\" Convert a naive datetime to an aware datetime using the configuration of this TimeZone object. :param dt: The (possibly naive) datetime to convert to this timezone configuration. :return: The timezone aware datetime. \"\"\" if dt . tzinfo is not None : return dt return dt . in_timezone ( self . get_as_timezone_object ())","title":"convert_naive_datetime_to_aware"},{"location":"code/components/timezone_components/#ical_library.ical_components.VTimeZone.get_as_timezone_object","text":"For a given maximum datetime, compute a pendulum Timezone object that contains all transition till max_datetime. Parameters: Name Type Description Default max_datetime DateTime The maximum datetime for which we include transitions. Any transitions after are excluded. DateTime (2100, 1, 1) Returns: Type Description Timezone Returns a pendulum Timezone object that you can use for DateTimes. Source code in ical_library/ical_components/v_timezone.py 220 221 222 223 224 225 226 227 228 229 @instance_lru_cache () def get_as_timezone_object ( self , max_datetime : DateTime = DateTime ( 2100 , 1 , 1 )) -> Timezone : \"\"\" For a given maximum datetime, compute a pendulum Timezone object that contains all transition till max_datetime. :param max_datetime: The maximum datetime for which we include transitions. Any transitions after are excluded. :return: Returns a pendulum Timezone object that you can use for DateTimes. \"\"\" return CustomTimezone ( name = self . tzid . value , transitions = self . get_ordered_timezone_overview_as_transition ( max_datetime ) )","title":"get_as_timezone_object"},{"location":"code/components/timezone_components/#ical_library.ical_components.VTimeZone.get_ordered_timezone_overview","text":"Expand all TimeOffsetPeriod configuration and return them in an ordered by time fashion. Parameters: Name Type Description Default max_datetime DateTime The maximum datetime value we wish to expand to. required Returns: Type Description List [ Tuple [ DateTime , _TimeOffsetPeriod ]] A sorted list on datetime containing tuples of datetime and offset period where the datetime is lower than max_datetime . Source code in ical_library/ical_components/v_timezone.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def get_ordered_timezone_overview ( self , max_datetime : DateTime ) -> List [ Tuple [ DateTime , _TimeOffsetPeriod ]]: \"\"\" Expand all TimeOffsetPeriod configuration and return them in an ordered by time fashion. :param max_datetime: The maximum datetime value we wish to expand to. :return: A sorted list on datetime containing tuples of datetime and offset period where the datetime is lower than *max_datetime*. \"\"\" if max_datetime in self . __storage_of_results . keys (): return self . __storage_of_results [ max_datetime ] all_timezones : List [ Tuple [ Union [ DateTime , Date ], _TimeOffsetPeriod ]] = [] for a_standard in self . standardc : all_timezones . extend ( a_standard . get_time_sequence ( max_datetime = max_datetime )) for a_daylight in self . daylightc : all_timezones . extend ( a_daylight . get_time_sequence ( max_datetime = max_datetime )) sorted_list = sorted ( all_timezones , key = lambda tup : tup [ 0 ]) self . __storage_of_results [ max_datetime ] = sorted_list return sorted_list","title":"get_ordered_timezone_overview"},{"location":"code/components/timezone_components/#ical_library.ical_components.VTimeZone.get_ordered_timezone_overview_as_transition","text":"Get timezone components as a list of pendulum Transitions. Parameters: Name Type Description Default max_datetime DateTime The maximum datetime for which we include transitions. Any transitions after are excluded. required Returns: Type Description List [ Transition ] Return the list of pendulum Transitions for this VTimezone. Source code in ical_library/ical_components/v_timezone.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def get_ordered_timezone_overview_as_transition ( self , max_datetime : DateTime ) -> List [ Transition ]: \"\"\" Get timezone components as a list of pendulum Transitions. :param max_datetime: The maximum datetime for which we include transitions. Any transitions after are excluded. :return: Return the list of pendulum Transitions for this VTimezone. \"\"\" timezones : List [ Tuple [ DateTime , _TimeOffsetPeriod ]] = self . get_ordered_timezone_overview ( max_datetime ) transitions : List [ Transition ] = [] previous_transition : Optional [ Transition ] = None for time , offset_period in timezones : new_transition_type = TransitionType ( offset = offset_period . tzoffsetto . parse_value_as_seconds (), is_dst = offset_period . is_dst , abbr = offset_period . tzname [ 0 ] . value if offset_period . tzname else \"unknown\" , ) at = int ( time . in_tz ( \"UTC\" ) . timestamp ()) new_transition = Transition ( at = at , ttype = new_transition_type , previous = previous_transition ) previous_transition = new_transition transitions . append ( new_transition ) return transitions","title":"get_ordered_timezone_overview_as_transition"},{"location":"code/components/timezone_components/#ical_library.ical_components.v_timezone._TimeOffsetPeriod","text":"Bases: Component A _TimeOffsetPeriod representing either a Standard configuration or a Winter configuration. Parameters: Name Type Description Default name str The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. required dtstart Optional [ DTStart ] The DTStart property. Required and must occur exactly once. None tzoffsetto Optional [ TZOffsetTo ] The TZOffsetTo property. Required and must occur exactly once. None tzoffsetfrom Optional [ TZOffsetFrom ] The TZOffsetFrom property. Required and must occur exactly once. None rrule Optional [ RRule ] The RRule property. Optional, but may occur at most once. None comment Optional [ List [ Comment ]] The Comment property. Optional, but may occur multiple times. None rdate Optional [ List [ RDate ]] The RDate property. Optional, but may occur multiple times. None tzname Optional [ List [ TZName ]] The TZName property. Optional, but may occur multiple times. None parent Optional [ Component ] The Component this item is encapsulated by in the iCalendar data file. None Source code in ical_library/ical_components/v_timezone.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class _TimeOffsetPeriod ( Component ): \"\"\" A _TimeOffsetPeriod representing either a Standard configuration or a Winter configuration. :param name: The actual name of this component instance. E.g. VEVENT, RRULE, VCUSTOMCOMPONENT. :param dtstart: The DTStart property. Required and must occur exactly once. :param tzoffsetto: The TZOffsetTo property. Required and must occur exactly once. :param tzoffsetfrom: The TZOffsetFrom property. Required and must occur exactly once. :param rrule: The RRule property. Optional, but may occur at most once. :param comment: The Comment property. Optional, but may occur multiple times. :param rdate: The RDate property. Optional, but may occur multiple times. :param tzname: The TZName property. Optional, but may occur multiple times. :param parent: The Component this item is encapsulated by in the iCalendar data file. \"\"\" def __init__ ( self , name : str , dtstart : Optional [ DTStart ] = None , tzoffsetto : Optional [ TZOffsetTo ] = None , tzoffsetfrom : Optional [ TZOffsetFrom ] = None , rrule : Optional [ RRule ] = None , comment : Optional [ List [ Comment ]] = None , rdate : Optional [ List [ RDate ]] = None , tzname : Optional [ List [ TZName ]] = None , parent : Optional [ Component ] = None , is_dst : bool = False , ): super () . __init__ ( name , parent = parent ) # Required, must occur only once. self . dtstart : Optional [ DTStart ] = self . as_parent ( dtstart ) self . tzoffsetto : Optional [ TZOffsetTo ] = self . as_parent ( tzoffsetto ) self . tzoffsetfrom : Optional [ TZOffsetFrom ] = self . as_parent ( tzoffsetfrom ) # Optional, may only occur once. self . rrule : Optional [ RRule ] = self . as_parent ( rrule ) # Optional, may occur more than once. self . comment : Optional [ List [ Comment ]] = self . as_parent ( comment ) self . rdate : Optional [ List [ RDate ]] = self . as_parent ( rdate ) self . tzname : Optional [ List [ TZName ]] = self . as_parent ( tzname ) self . is_dst = is_dst def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \" { self . __class__ . __name__ } ( { self . dtstart . value } : { self . tzoffsetto . value } )\" def timezone_aware_start ( self ) -> DateTime : \"\"\"Return a timezone aware start.\"\"\" dt : DateTime = dt_utils . convert_time_object_to_datetime ( self . dtstart . datetime_or_date_value ) return dt . in_timezone ( tz = self . tzoffsetfrom . as_timezone_object ()) def get_time_sequence ( self , max_datetime : Optional [ DateTime ] = None ) -> Iterator [ Tuple [ DateTime , \"_TimeOffsetPeriod\" ]]: \"\"\" Expand the TimeZone start date according to its recurring *RDate* and *RRule* properties. :param max_datetime: The maximum datetime value we wish to expand to. :return: Yield all the datetime values according to the recurring properties that are lower than *max_datetime*. \"\"\" for rtime in property_utils . expand_event_in_range_only_return_first ( rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . timezone_aware_start (), return_range = Timespan ( self . timezone_aware_start () - timedelta ( days = 1 ), max_datetime ), make_tz_aware = self . tzoffsetfrom . as_timezone_object (), ): if not isinstance ( rtime , DateTime ): raise TypeError ( f \" { rtime } was expected to be a DateTime object.\" ) yield rtime , self","title":"_TimeOffsetPeriod"},{"location":"code/components/timezone_components/#ical_library.ical_components.v_timezone._TimeOffsetPeriod.get_time_sequence","text":"Expand the TimeZone start date according to its recurring RDate and RRule properties. Parameters: Name Type Description Default max_datetime Optional [ DateTime ] The maximum datetime value we wish to expand to. None Returns: Type Description Iterator [ Tuple [ DateTime , _TimeOffsetPeriod ]] Yield all the datetime values according to the recurring properties that are lower than max_datetime . Source code in ical_library/ical_components/v_timezone.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def get_time_sequence ( self , max_datetime : Optional [ DateTime ] = None ) -> Iterator [ Tuple [ DateTime , \"_TimeOffsetPeriod\" ]]: \"\"\" Expand the TimeZone start date according to its recurring *RDate* and *RRule* properties. :param max_datetime: The maximum datetime value we wish to expand to. :return: Yield all the datetime values according to the recurring properties that are lower than *max_datetime*. \"\"\" for rtime in property_utils . expand_event_in_range_only_return_first ( rdate_list = self . rdate or [], rrule = self . rrule , first_event_start = self . timezone_aware_start (), return_range = Timespan ( self . timezone_aware_start () - timedelta ( days = 1 ), max_datetime ), make_tz_aware = self . tzoffsetfrom . as_timezone_object (), ): if not isinstance ( rtime , DateTime ): raise TypeError ( f \" { rtime } was expected to be a DateTime object.\" ) yield rtime , self","title":"get_time_sequence"},{"location":"code/components/timezone_components/#ical_library.ical_components.v_timezone._TimeOffsetPeriod.timezone_aware_start","text":"Return a timezone aware start. Source code in ical_library/ical_components/v_timezone.py 66 67 68 69 def timezone_aware_start ( self ) -> DateTime : \"\"\"Return a timezone aware start.\"\"\" dt : DateTime = dt_utils . convert_time_object_to_datetime ( self . dtstart . datetime_or_date_value ) return dt . in_timezone ( tz = self . tzoffsetfrom . as_timezone_object ())","title":"timezone_aware_start"},{"location":"code/components/timezone_components/#ical_library.ical_components.DayLight","text":"Bases: _TimeOffsetPeriod A TimeOffsetPeriod representing a DayLight(a.k.a. Advanced Time, Summer Time or Legal Time) configuration. Source code in ical_library/ical_components/v_timezone.py 91 92 93 94 95 96 97 98 99 class DayLight ( _TimeOffsetPeriod ): \"\"\"A TimeOffsetPeriod representing a DayLight(a.k.a. Advanced Time, Summer Time or Legal Time) configuration.\"\"\" def __init__ ( self , parent : Optional [ Component ] = None , ** kwargs ): super () . __init__ ( \"DAYLIGHT\" , parent = parent , is_dst = True , ** kwargs ) @classmethod def _get_init_method_for_var_mapping ( cls ) -> Callable : return _TimeOffsetPeriod . __init__","title":"DayLight"},{"location":"code/components/timezone_components/#ical_library.ical_components.Standard","text":"Bases: _TimeOffsetPeriod A TimeOffsetPeriod representing a Standard(a.k.a. Winter Time) configuration. Source code in ical_library/ical_components/v_timezone.py 102 103 104 105 106 107 108 109 110 class Standard ( _TimeOffsetPeriod ): \"\"\"A TimeOffsetPeriod representing a Standard(a.k.a. Winter Time) configuration.\"\"\" def __init__ ( self , parent : Optional [ Component ] = None , ** kwargs ): super () . __init__ ( \"STANDARD\" , parent = parent , is_dst = False , ** kwargs ) @classmethod def _get_init_method_for_var_mapping ( cls ) -> Callable : return _TimeOffsetPeriod . __init__","title":"Standard"},{"location":"code/properties/all_properties/","text":"All properties This is a list of all properties Action Bases: Property The ACTION property defines the action to be invoked when an alarm is triggered. Source code in ical_library/ical_properties/pass_properties.py 126 127 128 129 class Action ( Property ): \"\"\"The ACTION property defines the action to be invoked when an alarm is triggered.\"\"\" pass Attach Bases: Property The ATTACH property provides the capability to associate a document object with a calendar component. Source code in ical_library/ical_properties/pass_properties.py 76 77 78 79 class Attach ( Property ): \"\"\"The ATTACH property provides the capability to associate a document object with a calendar component.\"\"\" pass Attendee Bases: _CalAddress The ATTENDEE property defines an \"Attendee\" within a calendar component. Source code in ical_library/ical_properties/cal_address.py 40 41 42 43 class Attendee ( _CalAddress ): \"\"\"The ATTENDEE property defines an \"Attendee\" within a calendar component.\"\"\" pass CalScale Bases: Property The CALSCALE property defines the calendar scale used for the calendar information specified in the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 19 20 21 22 23 24 25 class CalScale ( Property ): \"\"\" The CALSCALE property defines the calendar scale used for the calendar information specified in the iCalendar object. \"\"\" pass Categories Bases: Property The CATEGORIES property defines the categories for a calendar component. Source code in ical_library/ical_properties/pass_properties.py 82 83 84 85 class Categories ( Property ): \"\"\"The CATEGORIES property defines the categories for a calendar component.\"\"\" pass Class Bases: Property The CLASS property defines the access classification for a calendar component. Source code in ical_library/ical_properties/pass_properties.py 34 35 36 37 class Class ( Property ): \"\"\"The CLASS property defines the access classification for a calendar component.\"\"\" pass Comment Bases: Property The COMMENT property specifies non-processing information intended to provide a comment to the calendar user. Source code in ical_library/ical_properties/pass_properties.py 138 139 140 141 class Comment ( Property ): \"\"\"The COMMENT property specifies non-processing information intended to provide a comment to the calendar user.\"\"\" pass Completed Bases: _DTSingular The COMPLETED property defines the date and time that a to-do was actually completed. Source code in ical_library/ical_properties/dt.py 106 107 108 109 class Completed ( _DTSingular ): \"\"\"The COMPLETED property defines the date and time that a to-do was actually completed.\"\"\" pass Contact Bases: Property The CONTACT property is used to represent contact information or alternately a reference to contact information associated with the calendar component. Source code in ical_library/ical_properties/pass_properties.py 88 89 90 91 92 93 94 class Contact ( Property ): \"\"\" The CONTACT property is used to represent contact information or alternately a reference to contact information associated with the calendar component. \"\"\" pass Created Bases: _DTSingular The CREATED property defines the date and time that the calendar information was created by the calendar user agent in the calendar store. Source code in ical_library/ical_properties/dt.py 113 114 115 116 117 118 119 class Created ( _DTSingular ): \"\"\" The CREATED property defines the date and time that the calendar information was created by the calendar user agent in the calendar store. \"\"\" pass DTEnd Bases: _DTBoth The DTEND property specifies the date and time that a calendar component ends. Source code in ical_library/ical_properties/dt.py 60 61 62 63 class DTEnd ( _DTBoth ): \"\"\"The DTEND property specifies the date and time that a calendar component ends.\"\"\" pass DTStamp Bases: _DTBoth The DTSTAMP property is defined as followed. In the case of an iCalendar object that specifies a \"METHOD\" property, this property specifies the date and time that the instance of the iCalendar object was created. In the case of an iCalendar object that doesn't specify a \"METHOD\" property, this property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. Source code in ical_library/ical_properties/dt.py 93 94 95 96 97 98 99 100 101 102 class DTStamp ( _DTBoth ): \"\"\"The DTSTAMP property is defined as followed. In the case of an iCalendar object that specifies a \"METHOD\" property, this property specifies the date and time that the instance of the iCalendar object was created. In the case of an iCalendar object that doesn't specify a \"METHOD\" property, this property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. \"\"\" pass DTStart Bases: _DTBoth The DTSTART property specifies when the calendar component begins.. Source code in ical_library/ical_properties/dt.py 53 54 55 56 class DTStart ( _DTBoth ): \"\"\"The DTSTART property specifies when the calendar component begins..\"\"\" pass Description Bases: Property The DESCRIPTION property provides a more complete description of the calendar component than that provided by the \"SUMMARY\" property. Source code in ical_library/ical_properties/pass_properties.py 40 41 42 43 44 45 46 class Description ( Property ): \"\"\" The DESCRIPTION property provides a more complete description of the calendar component than that provided by the \"SUMMARY\" property. \"\"\" pass Due Bases: _DTBoth This DUE property defines the date and time that a to-do is expected to be completed.. Source code in ical_library/ical_properties/dt.py 67 68 69 70 class Due ( _DTBoth ): \"\"\"This DUE property defines the date and time that a to-do is expected to be completed..\"\"\" pass EXDate Bases: _ExOrRDate The EXDATE property defines the list of DATE-TIME exceptions for recurring events, to-dos, journal entries, or time zone definitions. Source code in ical_library/ical_properties/periods.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class EXDate ( _ExOrRDate ): \"\"\" The EXDATE property defines the list of DATE-TIME exceptions for recurring events, to-dos, journal entries, or time zone definitions. \"\"\" @property def kind ( self ) -> Optional [ Literal [ \"DATE-TIME\" , \"DATE\" ]]: \"\"\"The kind of the values. It is either DATE-TIME or DATE. The default is DATE-TIME.\"\"\" return self . property_parameters . get ( \"VALUE\" , \"DATE-TIME\" ) @property def excluded_date_times ( self ) -> Union [ List [ DateTime ], List [ Date ]]: \"\"\"A list of all excluded Dates or DateTimes. The type will be according to kind reported by `self.kind()`.\"\"\" if self . kind == \"DATE-TIME\" : return self . _parse_datetime_values () elif self . kind == \"DATE\" : return self . _parse_date_values () else : raise ValueError ( f \" { self . kind =} should be one in ['DATE-TIME', 'DATE'].\" ) excluded_date_times : Union [ List [ DateTime ], List [ Date ]] property A list of all excluded Dates or DateTimes. The type will be according to kind reported by self.kind() . kind : Optional [ Literal [ 'DATE-TIME' , 'DATE' ]] property The kind of the values. It is either DATE-TIME or DATE. The default is DATE-TIME. FreeBusyProperty Bases: _PeriodFunctionality The FREEBUSY property defines one or more free or busy time intervals. Note: This class is called FreeBusyProperty to not be confused with the VFreeBusy component. Source code in ical_library/ical_properties/periods.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class FreeBusyProperty ( _PeriodFunctionality ): \"\"\" The FREEBUSY property defines one or more free or busy time intervals. Note: This class is called FreeBusyProperty to not be confused with the VFreeBusy component. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *FREEBUSYPROPERTY* but *FREEBUSY*.\"\"\" return \"FREEBUSY\" @property def free_busy_type ( self ) -> str : \"\"\" Specifies the free or busy time type. Values are usually in the following list but can be anything: FREE, BUSY, BUSY-UNAVAILABLE, BUSY-TENTATIVE \"\"\" return self . get_property_parameter_default ( \"FBTYPE\" , \"BUSY\" ) @property def periods ( self ) -> List [ Tuple [ DateTime , DateTime ]]: \"\"\" All the periods present in this property for which we define a free or busy time. :return: A list of tuples, where each tuple values consists of two DateTimes indicating the start and end respectively. \"\"\" return self . _parse_period_values () free_busy_type : str property Specifies the free or busy time type. Values are usually in the following list but can be anything: FREE, BUSY, BUSY-UNAVAILABLE, BUSY-TENTATIVE periods : List [ Tuple [ DateTime , DateTime ]] property All the periods present in this property for which we define a free or busy time. Returns: Type Description A list of tuples, where each tuple values consists of two DateTimes indicating the start and end respectively. get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not FREEBUSYPROPERTY but FREEBUSY . Source code in ical_library/ical_properties/periods.py 121 122 123 124 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *FREEBUSYPROPERTY* but *FREEBUSY*.\"\"\" return \"FREEBUSY\" GEO Bases: Property The GEO property specifies information related to the global position for the activity specified by a calendar component. Source code in ical_library/ical_properties/geo.py 6 7 8 9 10 11 12 13 14 15 16 class GEO ( Property ): \"\"\" The GEO property specifies information related to the global position for the activity specified by a calendar component. \"\"\" @property def geo_value ( self ) -> Tuple [ float , float ]: \"\"\"Return the value as two floats representing the latitude and longitude.\"\"\" latitude , longitude = self . value . split ( \";\" ) return float ( latitude ), float ( longitude ) geo_value : Tuple [ float , float ] property Return the value as two floats representing the latitude and longitude. ICALDuration Bases: Property The DURATION property specifies a positive duration of time. Source code in ical_library/ical_properties/ical_duration.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ICALDuration ( Property ): \"\"\"The DURATION property specifies a positive duration of time.\"\"\" @property def duration ( self ) -> pendulum . Duration : \"\"\"Return the value as a parsed pendulum.Duration. Example value: PT1H0M0S.\"\"\" parsed_value : pendulum . Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , pendulum . Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *ICALDURATION* but *DURATION*.\"\"\" return \"DURATION\" duration : pendulum . Duration property Return the value as a parsed pendulum.Duration. Example value: PT1H0M0S. get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not ICALDURATION but DURATION . Source code in ical_library/ical_properties/ical_duration.py 17 18 19 20 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *ICALDURATION* but *DURATION*.\"\"\" return \"DURATION\" LastModified Bases: _DTSingular The LAST-MODIFIED property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. Source code in ical_library/ical_properties/dt.py 123 124 125 126 127 128 129 130 131 132 class LastModified ( _DTSingular ): \"\"\" The LAST-MODIFIED property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"LAST-MODIFIED\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not LASTMODIFIED but LAST-MODIFIED . Source code in ical_library/ical_properties/dt.py 129 130 131 132 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"LAST-MODIFIED\" Location Bases: Property The LOCATION property defines the intended venue for the activity defined by a calendar component. Source code in ical_library/ical_properties/pass_properties.py 49 50 51 52 class Location ( Property ): \"\"\"The LOCATION property defines the intended venue for the activity defined by a calendar component.\"\"\" pass Method Bases: Property The METHOD property defines the iCalendar object method associated with the calendar object. Source code in ical_library/ical_properties/pass_properties.py 28 29 30 31 class Method ( Property ): \"\"\"The METHOD property defines the iCalendar object method associated with the calendar object.\"\"\" pass Organizer Bases: _CalAddress The ORGANIZER property defines the organizer for a calendar component. Source code in ical_library/ical_properties/cal_address.py 46 47 48 49 class Organizer ( _CalAddress ): \"\"\"The ORGANIZER property defines the organizer for a calendar component.\"\"\" pass PercentComplete Bases: _IntProperty The PERCENT-COMPLETE property is used by an assignee or delegatee of a to-do to convey the percent completion of a to-do to the \"Organizer\". Source code in ical_library/ical_properties/ints.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class PercentComplete ( _IntProperty ): \"\"\" The PERCENT-COMPLETE property is used by an assignee or delegatee of a to-do to convey the percent completion of a to-do to the \"Organizer\". \"\"\" @property def percentage ( self ) -> int : return self . int_value @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *PERCENTCOMPLETE* but *PERCENT-COMPLETE*.\"\"\" return \"PERCENT-COMPLETE\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not PERCENTCOMPLETE but PERCENT-COMPLETE . Source code in ical_library/ical_properties/ints.py 43 44 45 46 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *PERCENTCOMPLETE* but *PERCENT-COMPLETE*.\"\"\" return \"PERCENT-COMPLETE\" Priority Bases: _IntProperty The PRIORITY property represents the relative priority for a calendar component. Source code in ical_library/ical_properties/ints.py 13 14 15 16 class Priority ( _IntProperty ): \"\"\"The PRIORITY property represents the relative priority for a calendar component.\"\"\" pass ProdID Bases: Property The PRODID property specifies the identifier for the product that created the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 4 5 6 7 class ProdID ( Property ): \"\"\"The PRODID property specifies the identifier for the product that created the iCalendar object.\"\"\" pass RDate Bases: _ExOrRDate The RDATE property defines the list of DATE-TIME values for recurring events, to-dos, journal entries, or time zone definitions. Source code in ical_library/ical_properties/periods.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class RDate ( _ExOrRDate ): \"\"\" The RDATE property defines the list of DATE-TIME values for recurring events, to-dos, journal entries, or time zone definitions. \"\"\" @property def kind ( self ) -> Optional [ Literal [ \"DATE-TIME\" , \"DATE\" , \"PERIOD\" ]]: \"\"\"The kind of the values. It is either DATE-TIME, DATE or PERIOD. The default is DATE-TIME.\"\"\" return self . property_parameters . get ( \"VALUE\" , \"DATE-TIME\" ) @property def all_values ( self ) -> Union [ List [ DateTime ], List [ Date ], List [ Tuple [ DateTime , DateTime ]]]: \"\"\" A list of all recurring Dates, DateTimes or Periods. The periods are defined by tuples containing two datetimes representing the start and stop respectively. The returned types in the list will be according to the kind reported by `self.kind()`. \"\"\" if self . kind == \"DATE-TIME\" : return self . _parse_datetime_values () elif self . kind == \"DATE\" : return self . _parse_date_values () elif self . kind == \"PERIOD\" : return self . _parse_period_values () else : raise ValueError ( f \" { self . kind =} should be one in ['DATE-TIME', 'DATE', 'PERIOD'].\" ) def compute_max_end_date ( self , component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" max_value : Optional [ DateTime ] = None for value in self . all_values : if isinstance ( value , Date ): # This covers both Date and DateTime dt : DateTime = dt_utils . convert_time_object_to_datetime ( value ) dt : DateTime = dt + component_duration # type: ignore # Pendulum at fault here. dt = dt_utils . convert_time_object_to_aware_datetime ( dt ) if max_value is None or dt > max_value : max_value = dt elif isinstance ( value , tuple ) and len ( value ) == 2 : dt : DateTime = dt_utils . convert_time_object_to_aware_datetime ( value [ 1 ]) if max_value is None or dt > max_value : max_value = dt else : raise ValueError ( f \"Unexpected value encountered: { value } .\" ) return max_value or DateTime . max all_values : Union [ List [ DateTime ], List [ Date ], List [ Tuple [ DateTime , DateTime ]]] property A list of all recurring Dates, DateTimes or Periods. The periods are defined by tuples containing two datetimes representing the start and stop respectively. The returned types in the list will be according to the kind reported by self.kind() . kind : Optional [ Literal [ 'DATE-TIME' , 'DATE' , 'PERIOD' ]] property The kind of the values. It is either DATE-TIME, DATE or PERIOD. The default is DATE-TIME. compute_max_end_date ( component_duration ) To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). Parameters: Name Type Description Default component_duration Duration The duration of the component which has the recurring properties. required Returns: Type Description DateTime An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date Source code in ical_library/ical_properties/periods.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def compute_max_end_date ( self , component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" max_value : Optional [ DateTime ] = None for value in self . all_values : if isinstance ( value , Date ): # This covers both Date and DateTime dt : DateTime = dt_utils . convert_time_object_to_datetime ( value ) dt : DateTime = dt + component_duration # type: ignore # Pendulum at fault here. dt = dt_utils . convert_time_object_to_aware_datetime ( dt ) if max_value is None or dt > max_value : max_value = dt elif isinstance ( value , tuple ) and len ( value ) == 2 : dt : DateTime = dt_utils . convert_time_object_to_aware_datetime ( value [ 1 ]) if max_value is None or dt > max_value : max_value = dt else : raise ValueError ( f \"Unexpected value encountered: { value } .\" ) return max_value or DateTime . max RRule Bases: Property The RRULE property defines a rule or repeating pattern for recurring events, to-dos, journal entries, or time zone definitions. For more in depth restrictions and possibilities we refer you to the RTFC 5545 section 3.3.10. Recurrence Rule . Source code in ical_library/ical_properties/rrule.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class RRule ( Property ): \"\"\" The RRULE property defines a rule or repeating pattern for recurring events, to-dos, journal entries, or time zone definitions. For more in depth restrictions and possibilities we refer you to the `RTFC 5545` section `3.3.10. Recurrence Rule`. \"\"\" @property @instance_lru_cache () def value_as_dict ( self ) -> Dict [ str , str ]: \"\"\" Parse all recurrence rule parts as a dictionary, so it can be used as an easy lookup. :return: A dict mapping of str to str containing all recurrence rule parts. \"\"\" all_values = [ tuple ( key_and_value . split ( \"=\" )) for key_and_value in self . _value . split ( \";\" )] return { key : value for key , value in all_values } @property def freq ( self ) -> str : \"\"\" The FREQUENCY rule identifies the type of recurrence rule. Possible values are: SECONDLY, MINUTELY, HOURLY, DAILY, WEEKLY, MONTHLY and YEARLY. This is the only required field. :return: The frequency as a string. \"\"\" return self . value_as_dict [ \"FREQ\" ] @property def freq_dateutil ( self ) -> int : \"\"\" Return the frequency in the format dateutil expects which is a map of the string to an integer. :return: An integer in the range of 0 to 6. \"\"\" return getattr ( base_for_time_periods , self . freq ) @property def until ( self ) -> Optional [ Union [ Date , DateTime ]]: \"\"\" The UNTIL rule defines a DATE or DATE-TIME value that bounds the recurrence rule in an inclusive manner. This is optional but may not occur together with COUNT. :return: None or a positive integer. \"\"\" if ( until_value := self . value_as_dict . get ( \"UNTIL\" , None )) is not None : return dt_utils . parse_date_or_datetime ( until_value ) return None @property def count ( self ) -> Optional [ int ]: \"\"\" The COUNT rule defines the number of occurrences at which to range-bound the recurrence. This is optional but may not occur together with UNTIL. :return: None or a positive integer. \"\"\" count_value = self . value_as_dict . get ( \"COUNT\" , None ) return int ( count_value ) if count_value else None @property def interval ( self ) -> int : \"\"\" The INTERVAL rule contains a positive integer representing at which intervals the recurrence rule repeats. :return: A positive integer. \"\"\" return int ( self . value_as_dict . get ( \"INTERVAL\" , 1 )) @staticmethod def convert_str_to_optional_integer_tuple ( value : Optional [ str ]) -> Optional [ Tuple [ int , ... ]]: \"\"\" Converts a string to a Tuple of integers. :return: None or a Tuple of integers if the value exists, otherwise None. \"\"\" if not value : return None return tuple ( int ( item ) for item in value . split ( \",\" )) @property def by_second ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYSECOND rule part specifies a COMMA-separated list of seconds within a minute. :return: None or a list of integers in the range of 0 to 60. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYSECOND\" )) @property def by_minute ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMINUTE rule part specifies a COMMA-separated list of minutes within an hour. :return: None or a list of integers in the range of 0 to 59. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMINUTE\" )) @property def by_hour ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYHOUR rule part specifies a COMMA-separated list of hours of the day. :return: None or a list of integers in the range of 0 to 23. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYHOUR\" )) def by_day ( self ) -> Optional [ List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]]]: \"\"\" The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU :return None or a list of tuples of two values. The first value represents possible specified nth occurrence or None. The second value the day of the week as a SU, MO, TU, WE, TH, FR or SA. \"\"\" value = self . value_as_dict . get ( \"BYDAY\" ) if not value : return None list_of_days : List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]] = [] for a_day in value . split ( \",\" ): a_day = a_day . strip () nth_occurence : Optional [ int ] = int ( a_day [: - 2 ]) if len ( a_day ) > 2 else None day_of_week : str = a_day [ - 2 :] if day_of_week not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError list_of_days . append (( nth_occurence , day_of_week )) # type: ignore return list_of_days @property def by_day_dateutil ( self ) -> Optional [ Tuple [ weekday , ... ]]: \"\"\" Return the by_day in the format dateutil expects which is a tuple of weekday instance. :return: None or a tuple of weekday instances which is a type native to dateutil. \"\"\" day_list : List [ weekday ] = [] by_day = self . by_day () if by_day is None : return None for optional_nth_occurrence , weekday_str in by_day : try : if optional_nth_occurrence is not None : day_list . append ( getattr ( base_for_time_periods , weekday_str )( optional_nth_occurrence )) else : day_list . append ( getattr ( base_for_time_periods , weekday_str )) except Exception as exc : raise ValueError ( f \" { optional_nth_occurrence =} , { weekday_str =} \" ) from exc return tuple ( day_list ) @property def by_month_day ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMONTHDAY rule part specifies a COMMA-separated list of days of the month. For example: -10 represents the tenth to the last day of the month. :return: None or a tuple of integers in the range of 1 to 31 or -31 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMONTHDAY\" )) @property def by_year_day ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYYEARDAY rule part specifies a COMMA-separated list of days of the year. For example: -1 represents the last day of the year (December 31st). :return: None or a tuple of integers in the range of 1 to 366 or -366 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYYEARDAY\" )) @property def by_week_no ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYWEEKNO rule part specifies a COMMA-separated list of ordinals specifying weeks of the year. For example: 3 represents the third week of the year. :return: None or an integer in the range of 1 to 53 or -53 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYWEEKNO\" )) @property def by_month ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMONTH rule part specifies a COMMA-separated list of months of the year. :return: None or a list of integers in the range of 1 to 12. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMONTH\" )) @property def by_set_pos ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYSETPOS rule part specifies a COMMA-separated list of values that corresponds to the nth occurrence within the set of recurrence instances specified by the rule. BYSETPOS operates on a set of recurrence instances in one interval of the recurrence rule. For example, in a WEEKLY rule, the interval would be one week A set of recurrence instances starts at the beginning of the interval defined by the FREQ rule part. :return: None or a list of integers in the range of 1 to 366 or -366 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYSETPOS\" )) @property def wkst ( self ) -> Optional [ str ]: \"\"\" The WKST rule part specifies the day on which the workweek starts. :return: A string that is the value of MO, TU, WE, TH, FR, SA, or SU or None. \"\"\" day = self . value_as_dict . get ( \"WKST\" ) if not day : return None if day not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError ( f \" { day =} is not in the list of weekdays.\" ) return day @property def wkst_dateutil ( self ) -> Optional [ int ]: \"\"\" Return the wkst in the format dateutil expects which is an integer. 0 for MO, 1 for TU, 2 for WE, ... :return: An integer in the range of 0 to 6 or None. \"\"\" day = self . wkst return getattr ( base_for_time_periods , day ) if self . wkst is not None else None @property def by_easter ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" According to dateutil, this is an extension of the RFC specification.. I can't find it. If anyone can, please file an issue or a PR to add it here as a reference. The BYEASTER rule part specifies the offset from the Easter Sunday. :return: None or an integer in the range of 1 to 366 or -366 to -1 or None. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYEASTER\" )) def compute_max_end_date ( self , starting_datetime : Union [ Date , DateTime ], component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" if self . until : return dt_utils . convert_time_object_to_aware_datetime ( self . until ) + component_duration # type: ignore elif self . count : if self . count < 1000 : max_datetime = DateTime . max if isinstance ( starting_datetime , DateTime ) else Date ( 9999 , 12 , 31 ) * _ , last = self . sequence_iterator ( starting_datetime = starting_datetime , max_datetime = max_datetime ) return dt_utils . convert_time_object_to_aware_datetime ( last ) + component_duration # type: ignore return DateTime . max def sequence_iterator ( self , starting_datetime : Union [ Date , DateTime ], max_datetime : Union [ Date , DateTime ] ) -> Iterator [ DateTime ]: \"\"\" Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param max_datetime: The maximum datetime. If we reach this datetime, we stop the iteration.. :return: Yield all datetimes(except itself) in the sequence. \"\"\" if type ( starting_datetime ) != type ( max_datetime ): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of the same type.\" ) if isinstance ( starting_datetime , DateTime ): if ( starting_datetime . tz or max_datetime . tz ) and ( not starting_datetime . tz or not max_datetime . tz ): raise TypeError ( f \"The tz info should be consistent: { starting_datetime =} , { max_datetime =} .\" ) if not isinstance ( starting_datetime , ( Date , DateTime )) or not isinstance ( max_datetime , ( Date , DateTime )): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of Date or DateTime.\" ) if starting_datetime > max_datetime : raise ValueError ( f \"This should not be the case: { starting_datetime =} >= { max_datetime =} .\" ) if not ( is_datetime_format := isinstance ( starting_datetime , DateTime ) and isinstance ( max_datetime , DateTime )): starting_datetime = DateTime ( starting_datetime . year , starting_datetime . month , starting_datetime . day ) max_datetime = DateTime ( max_datetime . year , max_datetime . month , max_datetime . day ) starting_datetime = starting_datetime max_datetime = max_datetime starting_tz = starting_datetime . tz until = self . until if until : if not isinstance ( until , DateTime ): until = DateTime ( until . year , until . month , until . day ) until = until . replace ( tzinfo = None ) if starting_tz is None else until . in_timezone ( starting_tz ) keyword_arguments = { \"until\" : until , \"count\" : self . count , \"interval\" : self . interval , \"bysecond\" : self . by_second , \"byminute\" : self . by_minute , \"byhour\" : self . by_hour , \"byweekday\" : self . by_day_dateutil , \"bymonthday\" : self . by_month_day , \"byyearday\" : self . by_year_day , \"byweekno\" : self . by_week_no , \"bymonth\" : self . by_month , \"bysetpos\" : self . by_set_pos , \"wkst\" : self . wkst_dateutil , \"byeaster\" : self . by_easter , } no_none_keywords = { key : value for key , value in keyword_arguments . items () if value is not None } dt_iterator = rrule ( dtstart = starting_datetime , freq = self . freq_dateutil , ** no_none_keywords ) for dt in dt_iterator : if dt > max_datetime : break p_instance = pendulum . instance ( dt , tz = None ) yield p_instance if is_datetime_format else p_instance . date () by_day_dateutil : Optional [ Tuple [ weekday , ... ]] property Return the by_day in the format dateutil expects which is a tuple of weekday instance. Returns: Type Description None or a tuple of weekday instances which is a type native to dateutil. by_easter : Optional [ Tuple [ int , ... ]] property According to dateutil, this is an extension of the RFC specification.. I can't find it. If anyone can, please file an issue or a PR to add it here as a reference. The BYEASTER rule part specifies the offset from the Easter Sunday. Returns: Type Description None or an integer in the range of 1 to 366 or -366 to -1 or None. by_hour : Optional [ Tuple [ int , ... ]] property The BYHOUR rule part specifies a COMMA-separated list of hours of the day. Returns: Type Description None or a list of integers in the range of 0 to 23. by_minute : Optional [ Tuple [ int , ... ]] property The BYMINUTE rule part specifies a COMMA-separated list of minutes within an hour. Returns: Type Description None or a list of integers in the range of 0 to 59. by_month : Optional [ Tuple [ int , ... ]] property The BYMONTH rule part specifies a COMMA-separated list of months of the year. Returns: Type Description None or a list of integers in the range of 1 to 12. by_month_day : Optional [ Tuple [ int , ... ]] property The BYMONTHDAY rule part specifies a COMMA-separated list of days of the month. For example: -10 represents the tenth to the last day of the month. Returns: Type Description None or a tuple of integers in the range of 1 to 31 or -31 to -1. by_second : Optional [ Tuple [ int , ... ]] property The BYSECOND rule part specifies a COMMA-separated list of seconds within a minute. Returns: Type Description None or a list of integers in the range of 0 to 60. by_set_pos : Optional [ Tuple [ int , ... ]] property The BYSETPOS rule part specifies a COMMA-separated list of values that corresponds to the nth occurrence within the set of recurrence instances specified by the rule. BYSETPOS operates on a set of recurrence instances in one interval of the recurrence rule. For example, in a WEEKLY rule, the interval would be one week A set of recurrence instances starts at the beginning of the interval defined by the FREQ rule part. Returns: Type Description None or a list of integers in the range of 1 to 366 or -366 to -1. by_week_no : Optional [ Tuple [ int , ... ]] property The BYWEEKNO rule part specifies a COMMA-separated list of ordinals specifying weeks of the year. For example: 3 represents the third week of the year. Returns: Type Description None or an integer in the range of 1 to 53 or -53 to -1. by_year_day : Optional [ Tuple [ int , ... ]] property The BYYEARDAY rule part specifies a COMMA-separated list of days of the year. For example: -1 represents the last day of the year (December 31st). Returns: Type Description None or a tuple of integers in the range of 1 to 366 or -366 to -1. count : Optional [ int ] property The COUNT rule defines the number of occurrences at which to range-bound the recurrence. This is optional but may not occur together with UNTIL. Returns: Type Description None or a positive integer. freq : str property The FREQUENCY rule identifies the type of recurrence rule. Possible values are: SECONDLY, MINUTELY, HOURLY, DAILY, WEEKLY, MONTHLY and YEARLY. This is the only required field. Returns: Type Description The frequency as a string. freq_dateutil : int property Return the frequency in the format dateutil expects which is a map of the string to an integer. Returns: Type Description An integer in the range of 0 to 6. interval : int property The INTERVAL rule contains a positive integer representing at which intervals the recurrence rule repeats. Returns: Type Description A positive integer. until : Optional [ Union [ Date , DateTime ]] property The UNTIL rule defines a DATE or DATE-TIME value that bounds the recurrence rule in an inclusive manner. This is optional but may not occur together with COUNT. Returns: Type Description None or a positive integer. value_as_dict : Dict [ str , str ] property Parse all recurrence rule parts as a dictionary, so it can be used as an easy lookup. Returns: Type Description A dict mapping of str to str containing all recurrence rule parts. wkst : Optional [ str ] property The WKST rule part specifies the day on which the workweek starts. Returns: Type Description A string that is the value of MO, TU, WE, TH, FR, SA, or SU or None. wkst_dateutil : Optional [ int ] property Return the wkst in the format dateutil expects which is an integer. 0 for MO, 1 for TU, 2 for WE, ... Returns: Type Description An integer in the range of 0 to 6 or None. by_day () The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU Source code in ical_library/ical_properties/rrule.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def by_day ( self ) -> Optional [ List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]]]: \"\"\" The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU :return None or a list of tuples of two values. The first value represents possible specified nth occurrence or None. The second value the day of the week as a SU, MO, TU, WE, TH, FR or SA. \"\"\" value = self . value_as_dict . get ( \"BYDAY\" ) if not value : return None list_of_days : List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]] = [] for a_day in value . split ( \",\" ): a_day = a_day . strip () nth_occurence : Optional [ int ] = int ( a_day [: - 2 ]) if len ( a_day ) > 2 else None day_of_week : str = a_day [ - 2 :] if day_of_week not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError list_of_days . append (( nth_occurence , day_of_week )) # type: ignore return list_of_days compute_max_end_date ( starting_datetime , component_duration ) To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). Parameters: Name Type Description Default starting_datetime Union [ Date , DateTime ] The starting datetime from which we start computing the next occurrences. required component_duration Duration The duration of the component which has the recurring properties. required Returns: Type Description DateTime An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date Source code in ical_library/ical_properties/rrule.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def compute_max_end_date ( self , starting_datetime : Union [ Date , DateTime ], component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" if self . until : return dt_utils . convert_time_object_to_aware_datetime ( self . until ) + component_duration # type: ignore elif self . count : if self . count < 1000 : max_datetime = DateTime . max if isinstance ( starting_datetime , DateTime ) else Date ( 9999 , 12 , 31 ) * _ , last = self . sequence_iterator ( starting_datetime = starting_datetime , max_datetime = max_datetime ) return dt_utils . convert_time_object_to_aware_datetime ( last ) + component_duration # type: ignore return DateTime . max convert_str_to_optional_integer_tuple ( value ) staticmethod Converts a string to a Tuple of integers. Returns: Type Description Optional [ Tuple [ int , ...]] None or a Tuple of integers if the value exists, otherwise None. Source code in ical_library/ical_properties/rrule.py 78 79 80 81 82 83 84 85 86 @staticmethod def convert_str_to_optional_integer_tuple ( value : Optional [ str ]) -> Optional [ Tuple [ int , ... ]]: \"\"\" Converts a string to a Tuple of integers. :return: None or a Tuple of integers if the value exists, otherwise None. \"\"\" if not value : return None return tuple ( int ( item ) for item in value . split ( \",\" )) sequence_iterator ( starting_datetime , max_datetime ) Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. Parameters: Name Type Description Default starting_datetime Union [ Date , DateTime ] The starting datetime from which we start computing the next occurrences. required max_datetime Union [ Date , DateTime ] The maximum datetime. If we reach this datetime, we stop the iteration.. required Returns: Type Description Iterator [ DateTime ] Yield all datetimes(except itself) in the sequence. Source code in ical_library/ical_properties/rrule.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def sequence_iterator ( self , starting_datetime : Union [ Date , DateTime ], max_datetime : Union [ Date , DateTime ] ) -> Iterator [ DateTime ]: \"\"\" Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param max_datetime: The maximum datetime. If we reach this datetime, we stop the iteration.. :return: Yield all datetimes(except itself) in the sequence. \"\"\" if type ( starting_datetime ) != type ( max_datetime ): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of the same type.\" ) if isinstance ( starting_datetime , DateTime ): if ( starting_datetime . tz or max_datetime . tz ) and ( not starting_datetime . tz or not max_datetime . tz ): raise TypeError ( f \"The tz info should be consistent: { starting_datetime =} , { max_datetime =} .\" ) if not isinstance ( starting_datetime , ( Date , DateTime )) or not isinstance ( max_datetime , ( Date , DateTime )): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of Date or DateTime.\" ) if starting_datetime > max_datetime : raise ValueError ( f \"This should not be the case: { starting_datetime =} >= { max_datetime =} .\" ) if not ( is_datetime_format := isinstance ( starting_datetime , DateTime ) and isinstance ( max_datetime , DateTime )): starting_datetime = DateTime ( starting_datetime . year , starting_datetime . month , starting_datetime . day ) max_datetime = DateTime ( max_datetime . year , max_datetime . month , max_datetime . day ) starting_datetime = starting_datetime max_datetime = max_datetime starting_tz = starting_datetime . tz until = self . until if until : if not isinstance ( until , DateTime ): until = DateTime ( until . year , until . month , until . day ) until = until . replace ( tzinfo = None ) if starting_tz is None else until . in_timezone ( starting_tz ) keyword_arguments = { \"until\" : until , \"count\" : self . count , \"interval\" : self . interval , \"bysecond\" : self . by_second , \"byminute\" : self . by_minute , \"byhour\" : self . by_hour , \"byweekday\" : self . by_day_dateutil , \"bymonthday\" : self . by_month_day , \"byyearday\" : self . by_year_day , \"byweekno\" : self . by_week_no , \"bymonth\" : self . by_month , \"bysetpos\" : self . by_set_pos , \"wkst\" : self . wkst_dateutil , \"byeaster\" : self . by_easter , } no_none_keywords = { key : value for key , value in keyword_arguments . items () if value is not None } dt_iterator = rrule ( dtstart = starting_datetime , freq = self . freq_dateutil , ** no_none_keywords ) for dt in dt_iterator : if dt > max_datetime : break p_instance = pendulum . instance ( dt , tz = None ) yield p_instance if is_datetime_format else p_instance . date () RecurrenceID Bases: _DTBoth The RECURRENCE-ID property is defined as followed. This property is used in conjunction with the \"UID\" and \"SEQUENCE\" properties to identify a specific instance of a recurring \"VEVENT\", \"VTODO\", or \"VJOURNAL\" calendar component. The property value is the original value of the \"DTSTART\" property of the recurrence instance. Value Type: The default value type is DATE-TIME. The value type can be set to a DATE value type. This property MUST have the same value type as the \"DTSTART\" property contained within the recurring component. Furthermore, this property MUST be specified as a date with local time if and only if the \"DTSTART\" property contained within the recurring component is specified as a date with local time. Source code in ical_library/ical_properties/dt.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class RecurrenceID ( _DTBoth ): \"\"\" The RECURRENCE-ID property is defined as followed. This property is used in conjunction with the \"UID\" and \"SEQUENCE\" properties to identify a specific instance of a recurring \"VEVENT\", \"VTODO\", or \"VJOURNAL\" calendar component. The property value is the original value of the \"DTSTART\" property of the recurrence instance. Value Type: The default value type is DATE-TIME. The value type can be set to a DATE value type. This property MUST have the same value type as the \"DTSTART\" property contained within the recurring component. Furthermore, this property MUST be specified as a date with local time if and only if the \"DTSTART\" property contained within the recurring component is specified as a date with local time. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"RECURRENCE-ID\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not LASTMODIFIED but LAST-MODIFIED . Source code in ical_library/ical_properties/dt.py 86 87 88 89 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"RECURRENCE-ID\" RelatedTo Bases: Property The RELATED-TO property is used to represent a relationship or reference between one calendar component and another. Source code in ical_library/ical_properties/pass_properties.py 106 107 108 109 110 111 112 113 114 class RelatedTo ( Property ): \"\"\" The RELATED-TO property is used to represent a relationship or reference between one calendar component and another. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *RELATEDTO* but *RELATED-TO*.\"\"\" return \"RELATED-TO\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not RELATEDTO but RELATED-TO . Source code in ical_library/ical_properties/pass_properties.py 111 112 113 114 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *RELATEDTO* but *RELATED-TO*.\"\"\" return \"RELATED-TO\" Repeat Bases: _IntProperty The REPEAT property defines the number of times the alarm should be repeated, after the initial trigger. Source code in ical_library/ical_properties/ints.py 27 28 29 30 class Repeat ( _IntProperty ): \"\"\"The REPEAT property defines the number of times the alarm should be repeated, after the initial trigger.\"\"\" pass RequestStatus Bases: Property The REQUEST-STATUS property defines the status code returned for a scheduling request. Source code in ical_library/ical_properties/pass_properties.py 97 98 99 100 101 102 103 class RequestStatus ( Property ): \"\"\"The REQUEST-STATUS property defines the status code returned for a scheduling request.\"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *REQUESTSTATUS* but *REQUEST-STATUS*.\"\"\" return \"REQUEST-STATUS\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not REQUESTSTATUS but REQUEST-STATUS . Source code in ical_library/ical_properties/pass_properties.py 100 101 102 103 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *REQUESTSTATUS* but *REQUEST-STATUS*.\"\"\" return \"REQUEST-STATUS\" Resources Bases: Property The RESOURCES property defines the equipment or resources anticipated for an activity specified by a calendar component. Source code in ical_library/ical_properties/pass_properties.py 117 118 119 120 121 122 123 class Resources ( Property ): \"\"\" The RESOURCES property defines the equipment or resources anticipated for an activity specified by a calendar component. \"\"\" pass Sequence Bases: _IntProperty The SEQUENCE property defines the revision sequence number of the calendar component within a sequence of revisions. Source code in ical_library/ical_properties/ints.py 19 20 21 22 23 24 class Sequence ( _IntProperty ): \"\"\" The SEQUENCE property defines the revision sequence number of the calendar component within a sequence of revisions. \"\"\" pass Status Bases: Property The STATUS property defines the overall status or confirmation for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 55 56 57 58 class Status ( Property ): \"\"\"The STATUS property defines the overall status or confirmation for the calendar component.\"\"\" pass Summary Bases: Property The SUMMARY property defines a short summary or subject for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 168 169 170 171 172 173 class Summary ( Property ): \"\"\" The SUMMARY property defines a short summary or subject for the calendar component. \"\"\" pass TZID Bases: Property The TZID property specifies the text value that uniquely identifies the \"VTIMEZONE\" calendar component in the scope of an iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 150 151 152 153 154 155 156 class TZID ( Property ): \"\"\" The TZID property specifies the text value that uniquely identifies the \"VTIMEZONE\" calendar component in the scope of an iCalendar object. \"\"\" pass TZName Bases: Property The TZNAME property specifies the customary designation for a time zone description. Source code in ical_library/ical_properties/pass_properties.py 144 145 146 147 class TZName ( Property ): \"\"\"The TZNAME property specifies the customary designation for a time zone description.\"\"\" pass TZOffsetFrom Bases: _TZOffset The TZOFFSETFROM property specifies the offset that is in use prior to this time zone observance. Source code in ical_library/ical_properties/tz_offset.py 33 34 35 36 class TZOffsetFrom ( _TZOffset ): \"\"\"The TZOFFSETFROM property specifies the offset that is in use prior to this time zone observance.\"\"\" pass TZOffsetTo Bases: _TZOffset The TZOFFSETTO property specifies the offset that is in use prior to this time zone observance. Source code in ical_library/ical_properties/tz_offset.py 27 28 29 30 class TZOffsetTo ( _TZOffset ): \"\"\"The TZOFFSETTO property specifies the offset that is in use prior to this time zone observance.\"\"\" pass TZURL Bases: Property The TZURL property provides a means for a \"VTIMEZONE\" component to point to a network location that can be used to retrieve an up- to-date version of itself. Source code in ical_library/ical_properties/pass_properties.py 159 160 161 162 163 164 165 class TZURL ( Property ): \"\"\" The TZURL property provides a means for a \"VTIMEZONE\" component to point to a network location that can be used to retrieve an up- to-date version of itself. \"\"\" pass TimeTransparency Bases: Property The TRANSP property defines whether an event is transparent to busy time searches. Source code in ical_library/ical_properties/pass_properties.py 61 62 63 64 65 66 67 class TimeTransparency ( Property ): \"\"\"The TRANSP property defines whether an event is transparent to busy time searches.\"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *TIMETRANSPARANCY* but *TRANSP*.\"\"\" return \"TRANSP\" get_ical_name_of_class () classmethod Overwrite the iCal name of this class as it is not TIMETRANSPARANCY but TRANSP . Source code in ical_library/ical_properties/pass_properties.py 64 65 66 67 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *TIMETRANSPARANCY* but *TRANSP*.\"\"\" return \"TRANSP\" Trigger Bases: Property The TRIGGER property specifies when an alarm will trigger. Source code in ical_library/ical_properties/trigger.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Trigger ( Property ): \"\"\"The TRIGGER property specifies when an alarm will trigger.\"\"\" @property def kind ( self ) -> Literal [ \"DATE-TIME\" , \"DURATION\" ]: \"\"\"Return the type of the property value.\"\"\" kind_of_value = self . get_property_parameter ( \"VALUE\" ) return \"DATE-TIME\" if kind_of_value and kind_of_value == \"DATE-TIME\" else \"DURATION\" # noqa def parse_value ( self ) -> Union [ Duration , DateTime ]: \"\"\"Parse the value of this property based on the VALUE property parameter.\"\"\" if self . kind == \"DURATION\" : parsed_value : Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value else : parsed_value : DateTime = pendulum . parse ( self . value ) if not isinstance ( parsed_value , DateTime ): raise TypeError ( f \"Invalid value passed for DateTime: { self . value =} \" ) return parsed_value def trigger_relation ( self ) -> Literal [ \"START\" , \"END\" ]: \"\"\"Get the trigger relation, whether the duration should be relative to the start or the end of a component.\"\"\" return \"START\" if self . get_property_parameter_default ( \"RELATED\" , \"START\" ) == \"START\" else \"END\" # noqa kind : Literal [ 'DATE-TIME' , 'DURATION' ] property Return the type of the property value. parse_value () Parse the value of this property based on the VALUE property parameter. Source code in ical_library/ical_properties/trigger.py 18 19 20 21 22 23 24 25 26 27 28 29 def parse_value ( self ) -> Union [ Duration , DateTime ]: \"\"\"Parse the value of this property based on the VALUE property parameter.\"\"\" if self . kind == \"DURATION\" : parsed_value : Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value else : parsed_value : DateTime = pendulum . parse ( self . value ) if not isinstance ( parsed_value , DateTime ): raise TypeError ( f \"Invalid value passed for DateTime: { self . value =} \" ) return parsed_value trigger_relation () Get the trigger relation, whether the duration should be relative to the start or the end of a component. Source code in ical_library/ical_properties/trigger.py 31 32 33 def trigger_relation ( self ) -> Literal [ \"START\" , \"END\" ]: \"\"\"Get the trigger relation, whether the duration should be relative to the start or the end of a component.\"\"\" return \"START\" if self . get_property_parameter_default ( \"RELATED\" , \"START\" ) == \"START\" else \"END\" # noqa UID Bases: Property The UID property defines the persistent, globally unique identifier for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 132 133 134 135 class UID ( Property ): \"\"\"The UID property defines the persistent, globally unique identifier for the calendar component.\"\"\" pass URL Bases: Property The URL property defines a Uniform Resource Locator (URL) associated with the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 70 71 72 73 class URL ( Property ): \"\"\"The URL property defines a Uniform Resource Locator (URL) associated with the iCalendar object.\"\"\" pass Version Bases: Property The VERSION property specifies the identifier corresponding to the highest version number or the minimum and maximum range of the iCalendar specification that is required in order to interpret the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 10 11 12 13 14 15 16 class Version ( Property ): \"\"\" The VERSION property specifies the identifier corresponding to the highest version number or the minimum and maximum range of the iCalendar specification that is required in order to interpret the iCalendar object. \"\"\" pass","title":"Property classes"},{"location":"code/properties/all_properties/#all-properties","text":"This is a list of all properties","title":"All properties"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Action","text":"Bases: Property The ACTION property defines the action to be invoked when an alarm is triggered. Source code in ical_library/ical_properties/pass_properties.py 126 127 128 129 class Action ( Property ): \"\"\"The ACTION property defines the action to be invoked when an alarm is triggered.\"\"\" pass","title":"Action"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Attach","text":"Bases: Property The ATTACH property provides the capability to associate a document object with a calendar component. Source code in ical_library/ical_properties/pass_properties.py 76 77 78 79 class Attach ( Property ): \"\"\"The ATTACH property provides the capability to associate a document object with a calendar component.\"\"\" pass","title":"Attach"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Attendee","text":"Bases: _CalAddress The ATTENDEE property defines an \"Attendee\" within a calendar component. Source code in ical_library/ical_properties/cal_address.py 40 41 42 43 class Attendee ( _CalAddress ): \"\"\"The ATTENDEE property defines an \"Attendee\" within a calendar component.\"\"\" pass","title":"Attendee"},{"location":"code/properties/all_properties/#ical_library.ical_properties.CalScale","text":"Bases: Property The CALSCALE property defines the calendar scale used for the calendar information specified in the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 19 20 21 22 23 24 25 class CalScale ( Property ): \"\"\" The CALSCALE property defines the calendar scale used for the calendar information specified in the iCalendar object. \"\"\" pass","title":"CalScale"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Categories","text":"Bases: Property The CATEGORIES property defines the categories for a calendar component. Source code in ical_library/ical_properties/pass_properties.py 82 83 84 85 class Categories ( Property ): \"\"\"The CATEGORIES property defines the categories for a calendar component.\"\"\" pass","title":"Categories"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Class","text":"Bases: Property The CLASS property defines the access classification for a calendar component. Source code in ical_library/ical_properties/pass_properties.py 34 35 36 37 class Class ( Property ): \"\"\"The CLASS property defines the access classification for a calendar component.\"\"\" pass","title":"Class"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Comment","text":"Bases: Property The COMMENT property specifies non-processing information intended to provide a comment to the calendar user. Source code in ical_library/ical_properties/pass_properties.py 138 139 140 141 class Comment ( Property ): \"\"\"The COMMENT property specifies non-processing information intended to provide a comment to the calendar user.\"\"\" pass","title":"Comment"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Completed","text":"Bases: _DTSingular The COMPLETED property defines the date and time that a to-do was actually completed. Source code in ical_library/ical_properties/dt.py 106 107 108 109 class Completed ( _DTSingular ): \"\"\"The COMPLETED property defines the date and time that a to-do was actually completed.\"\"\" pass","title":"Completed"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Contact","text":"Bases: Property The CONTACT property is used to represent contact information or alternately a reference to contact information associated with the calendar component. Source code in ical_library/ical_properties/pass_properties.py 88 89 90 91 92 93 94 class Contact ( Property ): \"\"\" The CONTACT property is used to represent contact information or alternately a reference to contact information associated with the calendar component. \"\"\" pass","title":"Contact"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Created","text":"Bases: _DTSingular The CREATED property defines the date and time that the calendar information was created by the calendar user agent in the calendar store. Source code in ical_library/ical_properties/dt.py 113 114 115 116 117 118 119 class Created ( _DTSingular ): \"\"\" The CREATED property defines the date and time that the calendar information was created by the calendar user agent in the calendar store. \"\"\" pass","title":"Created"},{"location":"code/properties/all_properties/#ical_library.ical_properties.DTEnd","text":"Bases: _DTBoth The DTEND property specifies the date and time that a calendar component ends. Source code in ical_library/ical_properties/dt.py 60 61 62 63 class DTEnd ( _DTBoth ): \"\"\"The DTEND property specifies the date and time that a calendar component ends.\"\"\" pass","title":"DTEnd"},{"location":"code/properties/all_properties/#ical_library.ical_properties.DTStamp","text":"Bases: _DTBoth The DTSTAMP property is defined as followed. In the case of an iCalendar object that specifies a \"METHOD\" property, this property specifies the date and time that the instance of the iCalendar object was created. In the case of an iCalendar object that doesn't specify a \"METHOD\" property, this property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. Source code in ical_library/ical_properties/dt.py 93 94 95 96 97 98 99 100 101 102 class DTStamp ( _DTBoth ): \"\"\"The DTSTAMP property is defined as followed. In the case of an iCalendar object that specifies a \"METHOD\" property, this property specifies the date and time that the instance of the iCalendar object was created. In the case of an iCalendar object that doesn't specify a \"METHOD\" property, this property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. \"\"\" pass","title":"DTStamp"},{"location":"code/properties/all_properties/#ical_library.ical_properties.DTStart","text":"Bases: _DTBoth The DTSTART property specifies when the calendar component begins.. Source code in ical_library/ical_properties/dt.py 53 54 55 56 class DTStart ( _DTBoth ): \"\"\"The DTSTART property specifies when the calendar component begins..\"\"\" pass","title":"DTStart"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Description","text":"Bases: Property The DESCRIPTION property provides a more complete description of the calendar component than that provided by the \"SUMMARY\" property. Source code in ical_library/ical_properties/pass_properties.py 40 41 42 43 44 45 46 class Description ( Property ): \"\"\" The DESCRIPTION property provides a more complete description of the calendar component than that provided by the \"SUMMARY\" property. \"\"\" pass","title":"Description"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Due","text":"Bases: _DTBoth This DUE property defines the date and time that a to-do is expected to be completed.. Source code in ical_library/ical_properties/dt.py 67 68 69 70 class Due ( _DTBoth ): \"\"\"This DUE property defines the date and time that a to-do is expected to be completed..\"\"\" pass","title":"Due"},{"location":"code/properties/all_properties/#ical_library.ical_properties.EXDate","text":"Bases: _ExOrRDate The EXDATE property defines the list of DATE-TIME exceptions for recurring events, to-dos, journal entries, or time zone definitions. Source code in ical_library/ical_properties/periods.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class EXDate ( _ExOrRDate ): \"\"\" The EXDATE property defines the list of DATE-TIME exceptions for recurring events, to-dos, journal entries, or time zone definitions. \"\"\" @property def kind ( self ) -> Optional [ Literal [ \"DATE-TIME\" , \"DATE\" ]]: \"\"\"The kind of the values. It is either DATE-TIME or DATE. The default is DATE-TIME.\"\"\" return self . property_parameters . get ( \"VALUE\" , \"DATE-TIME\" ) @property def excluded_date_times ( self ) -> Union [ List [ DateTime ], List [ Date ]]: \"\"\"A list of all excluded Dates or DateTimes. The type will be according to kind reported by `self.kind()`.\"\"\" if self . kind == \"DATE-TIME\" : return self . _parse_datetime_values () elif self . kind == \"DATE\" : return self . _parse_date_values () else : raise ValueError ( f \" { self . kind =} should be one in ['DATE-TIME', 'DATE'].\" )","title":"EXDate"},{"location":"code/properties/all_properties/#ical_library.ical_properties.EXDate.excluded_date_times","text":"A list of all excluded Dates or DateTimes. The type will be according to kind reported by self.kind() .","title":"excluded_date_times"},{"location":"code/properties/all_properties/#ical_library.ical_properties.EXDate.kind","text":"The kind of the values. It is either DATE-TIME or DATE. The default is DATE-TIME.","title":"kind"},{"location":"code/properties/all_properties/#ical_library.ical_properties.FreeBusyProperty","text":"Bases: _PeriodFunctionality The FREEBUSY property defines one or more free or busy time intervals. Note: This class is called FreeBusyProperty to not be confused with the VFreeBusy component. Source code in ical_library/ical_properties/periods.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 class FreeBusyProperty ( _PeriodFunctionality ): \"\"\" The FREEBUSY property defines one or more free or busy time intervals. Note: This class is called FreeBusyProperty to not be confused with the VFreeBusy component. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *FREEBUSYPROPERTY* but *FREEBUSY*.\"\"\" return \"FREEBUSY\" @property def free_busy_type ( self ) -> str : \"\"\" Specifies the free or busy time type. Values are usually in the following list but can be anything: FREE, BUSY, BUSY-UNAVAILABLE, BUSY-TENTATIVE \"\"\" return self . get_property_parameter_default ( \"FBTYPE\" , \"BUSY\" ) @property def periods ( self ) -> List [ Tuple [ DateTime , DateTime ]]: \"\"\" All the periods present in this property for which we define a free or busy time. :return: A list of tuples, where each tuple values consists of two DateTimes indicating the start and end respectively. \"\"\" return self . _parse_period_values ()","title":"FreeBusyProperty"},{"location":"code/properties/all_properties/#ical_library.ical_properties.FreeBusyProperty.free_busy_type","text":"Specifies the free or busy time type. Values are usually in the following list but can be anything: FREE, BUSY, BUSY-UNAVAILABLE, BUSY-TENTATIVE","title":"free_busy_type"},{"location":"code/properties/all_properties/#ical_library.ical_properties.FreeBusyProperty.periods","text":"All the periods present in this property for which we define a free or busy time. Returns: Type Description A list of tuples, where each tuple values consists of two DateTimes indicating the start and end respectively.","title":"periods"},{"location":"code/properties/all_properties/#ical_library.ical_properties.FreeBusyProperty.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not FREEBUSYPROPERTY but FREEBUSY . Source code in ical_library/ical_properties/periods.py 121 122 123 124 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *FREEBUSYPROPERTY* but *FREEBUSY*.\"\"\" return \"FREEBUSY\"","title":"get_ical_name_of_class"},{"location":"code/properties/all_properties/#ical_library.ical_properties.GEO","text":"Bases: Property The GEO property specifies information related to the global position for the activity specified by a calendar component. Source code in ical_library/ical_properties/geo.py 6 7 8 9 10 11 12 13 14 15 16 class GEO ( Property ): \"\"\" The GEO property specifies information related to the global position for the activity specified by a calendar component. \"\"\" @property def geo_value ( self ) -> Tuple [ float , float ]: \"\"\"Return the value as two floats representing the latitude and longitude.\"\"\" latitude , longitude = self . value . split ( \";\" ) return float ( latitude ), float ( longitude )","title":"GEO"},{"location":"code/properties/all_properties/#ical_library.ical_properties.GEO.geo_value","text":"Return the value as two floats representing the latitude and longitude.","title":"geo_value"},{"location":"code/properties/all_properties/#ical_library.ical_properties.ICALDuration","text":"Bases: Property The DURATION property specifies a positive duration of time. Source code in ical_library/ical_properties/ical_duration.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ICALDuration ( Property ): \"\"\"The DURATION property specifies a positive duration of time.\"\"\" @property def duration ( self ) -> pendulum . Duration : \"\"\"Return the value as a parsed pendulum.Duration. Example value: PT1H0M0S.\"\"\" parsed_value : pendulum . Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , pendulum . Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *ICALDURATION* but *DURATION*.\"\"\" return \"DURATION\"","title":"ICALDuration"},{"location":"code/properties/all_properties/#ical_library.ical_properties.ICALDuration.duration","text":"Return the value as a parsed pendulum.Duration. Example value: PT1H0M0S.","title":"duration"},{"location":"code/properties/all_properties/#ical_library.ical_properties.ICALDuration.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not ICALDURATION but DURATION . Source code in ical_library/ical_properties/ical_duration.py 17 18 19 20 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *ICALDURATION* but *DURATION*.\"\"\" return \"DURATION\"","title":"get_ical_name_of_class"},{"location":"code/properties/all_properties/#ical_library.ical_properties.LastModified","text":"Bases: _DTSingular The LAST-MODIFIED property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. Source code in ical_library/ical_properties/dt.py 123 124 125 126 127 128 129 130 131 132 class LastModified ( _DTSingular ): \"\"\" The LAST-MODIFIED property specifies the date and time that the information associated with the calendar component was last revised in the calendar store. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"LAST-MODIFIED\"","title":"LastModified"},{"location":"code/properties/all_properties/#ical_library.ical_properties.LastModified.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not LASTMODIFIED but LAST-MODIFIED . Source code in ical_library/ical_properties/dt.py 129 130 131 132 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"LAST-MODIFIED\"","title":"get_ical_name_of_class"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Location","text":"Bases: Property The LOCATION property defines the intended venue for the activity defined by a calendar component. Source code in ical_library/ical_properties/pass_properties.py 49 50 51 52 class Location ( Property ): \"\"\"The LOCATION property defines the intended venue for the activity defined by a calendar component.\"\"\" pass","title":"Location"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Method","text":"Bases: Property The METHOD property defines the iCalendar object method associated with the calendar object. Source code in ical_library/ical_properties/pass_properties.py 28 29 30 31 class Method ( Property ): \"\"\"The METHOD property defines the iCalendar object method associated with the calendar object.\"\"\" pass","title":"Method"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Organizer","text":"Bases: _CalAddress The ORGANIZER property defines the organizer for a calendar component. Source code in ical_library/ical_properties/cal_address.py 46 47 48 49 class Organizer ( _CalAddress ): \"\"\"The ORGANIZER property defines the organizer for a calendar component.\"\"\" pass","title":"Organizer"},{"location":"code/properties/all_properties/#ical_library.ical_properties.PercentComplete","text":"Bases: _IntProperty The PERCENT-COMPLETE property is used by an assignee or delegatee of a to-do to convey the percent completion of a to-do to the \"Organizer\". Source code in ical_library/ical_properties/ints.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class PercentComplete ( _IntProperty ): \"\"\" The PERCENT-COMPLETE property is used by an assignee or delegatee of a to-do to convey the percent completion of a to-do to the \"Organizer\". \"\"\" @property def percentage ( self ) -> int : return self . int_value @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *PERCENTCOMPLETE* but *PERCENT-COMPLETE*.\"\"\" return \"PERCENT-COMPLETE\"","title":"PercentComplete"},{"location":"code/properties/all_properties/#ical_library.ical_properties.PercentComplete.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not PERCENTCOMPLETE but PERCENT-COMPLETE . Source code in ical_library/ical_properties/ints.py 43 44 45 46 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *PERCENTCOMPLETE* but *PERCENT-COMPLETE*.\"\"\" return \"PERCENT-COMPLETE\"","title":"get_ical_name_of_class"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Priority","text":"Bases: _IntProperty The PRIORITY property represents the relative priority for a calendar component. Source code in ical_library/ical_properties/ints.py 13 14 15 16 class Priority ( _IntProperty ): \"\"\"The PRIORITY property represents the relative priority for a calendar component.\"\"\" pass","title":"Priority"},{"location":"code/properties/all_properties/#ical_library.ical_properties.ProdID","text":"Bases: Property The PRODID property specifies the identifier for the product that created the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 4 5 6 7 class ProdID ( Property ): \"\"\"The PRODID property specifies the identifier for the product that created the iCalendar object.\"\"\" pass","title":"ProdID"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RDate","text":"Bases: _ExOrRDate The RDATE property defines the list of DATE-TIME values for recurring events, to-dos, journal entries, or time zone definitions. Source code in ical_library/ical_properties/periods.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 class RDate ( _ExOrRDate ): \"\"\" The RDATE property defines the list of DATE-TIME values for recurring events, to-dos, journal entries, or time zone definitions. \"\"\" @property def kind ( self ) -> Optional [ Literal [ \"DATE-TIME\" , \"DATE\" , \"PERIOD\" ]]: \"\"\"The kind of the values. It is either DATE-TIME, DATE or PERIOD. The default is DATE-TIME.\"\"\" return self . property_parameters . get ( \"VALUE\" , \"DATE-TIME\" ) @property def all_values ( self ) -> Union [ List [ DateTime ], List [ Date ], List [ Tuple [ DateTime , DateTime ]]]: \"\"\" A list of all recurring Dates, DateTimes or Periods. The periods are defined by tuples containing two datetimes representing the start and stop respectively. The returned types in the list will be according to the kind reported by `self.kind()`. \"\"\" if self . kind == \"DATE-TIME\" : return self . _parse_datetime_values () elif self . kind == \"DATE\" : return self . _parse_date_values () elif self . kind == \"PERIOD\" : return self . _parse_period_values () else : raise ValueError ( f \" { self . kind =} should be one in ['DATE-TIME', 'DATE', 'PERIOD'].\" ) def compute_max_end_date ( self , component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" max_value : Optional [ DateTime ] = None for value in self . all_values : if isinstance ( value , Date ): # This covers both Date and DateTime dt : DateTime = dt_utils . convert_time_object_to_datetime ( value ) dt : DateTime = dt + component_duration # type: ignore # Pendulum at fault here. dt = dt_utils . convert_time_object_to_aware_datetime ( dt ) if max_value is None or dt > max_value : max_value = dt elif isinstance ( value , tuple ) and len ( value ) == 2 : dt : DateTime = dt_utils . convert_time_object_to_aware_datetime ( value [ 1 ]) if max_value is None or dt > max_value : max_value = dt else : raise ValueError ( f \"Unexpected value encountered: { value } .\" ) return max_value or DateTime . max","title":"RDate"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RDate.all_values","text":"A list of all recurring Dates, DateTimes or Periods. The periods are defined by tuples containing two datetimes representing the start and stop respectively. The returned types in the list will be according to the kind reported by self.kind() .","title":"all_values"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RDate.kind","text":"The kind of the values. It is either DATE-TIME, DATE or PERIOD. The default is DATE-TIME.","title":"kind"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RDate.compute_max_end_date","text":"To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). Parameters: Name Type Description Default component_duration Duration The duration of the component which has the recurring properties. required Returns: Type Description DateTime An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date Source code in ical_library/ical_properties/periods.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 def compute_max_end_date ( self , component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" max_value : Optional [ DateTime ] = None for value in self . all_values : if isinstance ( value , Date ): # This covers both Date and DateTime dt : DateTime = dt_utils . convert_time_object_to_datetime ( value ) dt : DateTime = dt + component_duration # type: ignore # Pendulum at fault here. dt = dt_utils . convert_time_object_to_aware_datetime ( dt ) if max_value is None or dt > max_value : max_value = dt elif isinstance ( value , tuple ) and len ( value ) == 2 : dt : DateTime = dt_utils . convert_time_object_to_aware_datetime ( value [ 1 ]) if max_value is None or dt > max_value : max_value = dt else : raise ValueError ( f \"Unexpected value encountered: { value } .\" ) return max_value or DateTime . max","title":"compute_max_end_date"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule","text":"Bases: Property The RRULE property defines a rule or repeating pattern for recurring events, to-dos, journal entries, or time zone definitions. For more in depth restrictions and possibilities we refer you to the RTFC 5545 section 3.3.10. Recurrence Rule . Source code in ical_library/ical_properties/rrule.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 class RRule ( Property ): \"\"\" The RRULE property defines a rule or repeating pattern for recurring events, to-dos, journal entries, or time zone definitions. For more in depth restrictions and possibilities we refer you to the `RTFC 5545` section `3.3.10. Recurrence Rule`. \"\"\" @property @instance_lru_cache () def value_as_dict ( self ) -> Dict [ str , str ]: \"\"\" Parse all recurrence rule parts as a dictionary, so it can be used as an easy lookup. :return: A dict mapping of str to str containing all recurrence rule parts. \"\"\" all_values = [ tuple ( key_and_value . split ( \"=\" )) for key_and_value in self . _value . split ( \";\" )] return { key : value for key , value in all_values } @property def freq ( self ) -> str : \"\"\" The FREQUENCY rule identifies the type of recurrence rule. Possible values are: SECONDLY, MINUTELY, HOURLY, DAILY, WEEKLY, MONTHLY and YEARLY. This is the only required field. :return: The frequency as a string. \"\"\" return self . value_as_dict [ \"FREQ\" ] @property def freq_dateutil ( self ) -> int : \"\"\" Return the frequency in the format dateutil expects which is a map of the string to an integer. :return: An integer in the range of 0 to 6. \"\"\" return getattr ( base_for_time_periods , self . freq ) @property def until ( self ) -> Optional [ Union [ Date , DateTime ]]: \"\"\" The UNTIL rule defines a DATE or DATE-TIME value that bounds the recurrence rule in an inclusive manner. This is optional but may not occur together with COUNT. :return: None or a positive integer. \"\"\" if ( until_value := self . value_as_dict . get ( \"UNTIL\" , None )) is not None : return dt_utils . parse_date_or_datetime ( until_value ) return None @property def count ( self ) -> Optional [ int ]: \"\"\" The COUNT rule defines the number of occurrences at which to range-bound the recurrence. This is optional but may not occur together with UNTIL. :return: None or a positive integer. \"\"\" count_value = self . value_as_dict . get ( \"COUNT\" , None ) return int ( count_value ) if count_value else None @property def interval ( self ) -> int : \"\"\" The INTERVAL rule contains a positive integer representing at which intervals the recurrence rule repeats. :return: A positive integer. \"\"\" return int ( self . value_as_dict . get ( \"INTERVAL\" , 1 )) @staticmethod def convert_str_to_optional_integer_tuple ( value : Optional [ str ]) -> Optional [ Tuple [ int , ... ]]: \"\"\" Converts a string to a Tuple of integers. :return: None or a Tuple of integers if the value exists, otherwise None. \"\"\" if not value : return None return tuple ( int ( item ) for item in value . split ( \",\" )) @property def by_second ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYSECOND rule part specifies a COMMA-separated list of seconds within a minute. :return: None or a list of integers in the range of 0 to 60. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYSECOND\" )) @property def by_minute ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMINUTE rule part specifies a COMMA-separated list of minutes within an hour. :return: None or a list of integers in the range of 0 to 59. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMINUTE\" )) @property def by_hour ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYHOUR rule part specifies a COMMA-separated list of hours of the day. :return: None or a list of integers in the range of 0 to 23. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYHOUR\" )) def by_day ( self ) -> Optional [ List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]]]: \"\"\" The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU :return None or a list of tuples of two values. The first value represents possible specified nth occurrence or None. The second value the day of the week as a SU, MO, TU, WE, TH, FR or SA. \"\"\" value = self . value_as_dict . get ( \"BYDAY\" ) if not value : return None list_of_days : List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]] = [] for a_day in value . split ( \",\" ): a_day = a_day . strip () nth_occurence : Optional [ int ] = int ( a_day [: - 2 ]) if len ( a_day ) > 2 else None day_of_week : str = a_day [ - 2 :] if day_of_week not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError list_of_days . append (( nth_occurence , day_of_week )) # type: ignore return list_of_days @property def by_day_dateutil ( self ) -> Optional [ Tuple [ weekday , ... ]]: \"\"\" Return the by_day in the format dateutil expects which is a tuple of weekday instance. :return: None or a tuple of weekday instances which is a type native to dateutil. \"\"\" day_list : List [ weekday ] = [] by_day = self . by_day () if by_day is None : return None for optional_nth_occurrence , weekday_str in by_day : try : if optional_nth_occurrence is not None : day_list . append ( getattr ( base_for_time_periods , weekday_str )( optional_nth_occurrence )) else : day_list . append ( getattr ( base_for_time_periods , weekday_str )) except Exception as exc : raise ValueError ( f \" { optional_nth_occurrence =} , { weekday_str =} \" ) from exc return tuple ( day_list ) @property def by_month_day ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMONTHDAY rule part specifies a COMMA-separated list of days of the month. For example: -10 represents the tenth to the last day of the month. :return: None or a tuple of integers in the range of 1 to 31 or -31 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMONTHDAY\" )) @property def by_year_day ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYYEARDAY rule part specifies a COMMA-separated list of days of the year. For example: -1 represents the last day of the year (December 31st). :return: None or a tuple of integers in the range of 1 to 366 or -366 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYYEARDAY\" )) @property def by_week_no ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYWEEKNO rule part specifies a COMMA-separated list of ordinals specifying weeks of the year. For example: 3 represents the third week of the year. :return: None or an integer in the range of 1 to 53 or -53 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYWEEKNO\" )) @property def by_month ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYMONTH rule part specifies a COMMA-separated list of months of the year. :return: None or a list of integers in the range of 1 to 12. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYMONTH\" )) @property def by_set_pos ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" The BYSETPOS rule part specifies a COMMA-separated list of values that corresponds to the nth occurrence within the set of recurrence instances specified by the rule. BYSETPOS operates on a set of recurrence instances in one interval of the recurrence rule. For example, in a WEEKLY rule, the interval would be one week A set of recurrence instances starts at the beginning of the interval defined by the FREQ rule part. :return: None or a list of integers in the range of 1 to 366 or -366 to -1. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYSETPOS\" )) @property def wkst ( self ) -> Optional [ str ]: \"\"\" The WKST rule part specifies the day on which the workweek starts. :return: A string that is the value of MO, TU, WE, TH, FR, SA, or SU or None. \"\"\" day = self . value_as_dict . get ( \"WKST\" ) if not day : return None if day not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError ( f \" { day =} is not in the list of weekdays.\" ) return day @property def wkst_dateutil ( self ) -> Optional [ int ]: \"\"\" Return the wkst in the format dateutil expects which is an integer. 0 for MO, 1 for TU, 2 for WE, ... :return: An integer in the range of 0 to 6 or None. \"\"\" day = self . wkst return getattr ( base_for_time_periods , day ) if self . wkst is not None else None @property def by_easter ( self ) -> Optional [ Tuple [ int , ... ]]: \"\"\" According to dateutil, this is an extension of the RFC specification.. I can't find it. If anyone can, please file an issue or a PR to add it here as a reference. The BYEASTER rule part specifies the offset from the Easter Sunday. :return: None or an integer in the range of 1 to 366 or -366 to -1 or None. \"\"\" return self . convert_str_to_optional_integer_tuple ( self . value_as_dict . get ( \"BYEASTER\" )) def compute_max_end_date ( self , starting_datetime : Union [ Date , DateTime ], component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" if self . until : return dt_utils . convert_time_object_to_aware_datetime ( self . until ) + component_duration # type: ignore elif self . count : if self . count < 1000 : max_datetime = DateTime . max if isinstance ( starting_datetime , DateTime ) else Date ( 9999 , 12 , 31 ) * _ , last = self . sequence_iterator ( starting_datetime = starting_datetime , max_datetime = max_datetime ) return dt_utils . convert_time_object_to_aware_datetime ( last ) + component_duration # type: ignore return DateTime . max def sequence_iterator ( self , starting_datetime : Union [ Date , DateTime ], max_datetime : Union [ Date , DateTime ] ) -> Iterator [ DateTime ]: \"\"\" Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param max_datetime: The maximum datetime. If we reach this datetime, we stop the iteration.. :return: Yield all datetimes(except itself) in the sequence. \"\"\" if type ( starting_datetime ) != type ( max_datetime ): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of the same type.\" ) if isinstance ( starting_datetime , DateTime ): if ( starting_datetime . tz or max_datetime . tz ) and ( not starting_datetime . tz or not max_datetime . tz ): raise TypeError ( f \"The tz info should be consistent: { starting_datetime =} , { max_datetime =} .\" ) if not isinstance ( starting_datetime , ( Date , DateTime )) or not isinstance ( max_datetime , ( Date , DateTime )): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of Date or DateTime.\" ) if starting_datetime > max_datetime : raise ValueError ( f \"This should not be the case: { starting_datetime =} >= { max_datetime =} .\" ) if not ( is_datetime_format := isinstance ( starting_datetime , DateTime ) and isinstance ( max_datetime , DateTime )): starting_datetime = DateTime ( starting_datetime . year , starting_datetime . month , starting_datetime . day ) max_datetime = DateTime ( max_datetime . year , max_datetime . month , max_datetime . day ) starting_datetime = starting_datetime max_datetime = max_datetime starting_tz = starting_datetime . tz until = self . until if until : if not isinstance ( until , DateTime ): until = DateTime ( until . year , until . month , until . day ) until = until . replace ( tzinfo = None ) if starting_tz is None else until . in_timezone ( starting_tz ) keyword_arguments = { \"until\" : until , \"count\" : self . count , \"interval\" : self . interval , \"bysecond\" : self . by_second , \"byminute\" : self . by_minute , \"byhour\" : self . by_hour , \"byweekday\" : self . by_day_dateutil , \"bymonthday\" : self . by_month_day , \"byyearday\" : self . by_year_day , \"byweekno\" : self . by_week_no , \"bymonth\" : self . by_month , \"bysetpos\" : self . by_set_pos , \"wkst\" : self . wkst_dateutil , \"byeaster\" : self . by_easter , } no_none_keywords = { key : value for key , value in keyword_arguments . items () if value is not None } dt_iterator = rrule ( dtstart = starting_datetime , freq = self . freq_dateutil , ** no_none_keywords ) for dt in dt_iterator : if dt > max_datetime : break p_instance = pendulum . instance ( dt , tz = None ) yield p_instance if is_datetime_format else p_instance . date ()","title":"RRule"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.by_day_dateutil","text":"Return the by_day in the format dateutil expects which is a tuple of weekday instance. Returns: Type Description None or a tuple of weekday instances which is a type native to dateutil.","title":"by_day_dateutil"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.by_easter","text":"According to dateutil, this is an extension of the RFC specification.. I can't find it. If anyone can, please file an issue or a PR to add it here as a reference. The BYEASTER rule part specifies the offset from the Easter Sunday. Returns: Type Description None or an integer in the range of 1 to 366 or -366 to -1 or None.","title":"by_easter"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.by_hour","text":"The BYHOUR rule part specifies a COMMA-separated list of hours of the day. Returns: Type Description None or a list of integers in the range of 0 to 23.","title":"by_hour"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.by_minute","text":"The BYMINUTE rule part specifies a COMMA-separated list of minutes within an hour. Returns: Type Description None or a list of integers in the range of 0 to 59.","title":"by_minute"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.by_month","text":"The BYMONTH rule part specifies a COMMA-separated list of months of the year. Returns: Type Description None or a list of integers in the range of 1 to 12.","title":"by_month"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.by_month_day","text":"The BYMONTHDAY rule part specifies a COMMA-separated list of days of the month. For example: -10 represents the tenth to the last day of the month. Returns: Type Description None or a tuple of integers in the range of 1 to 31 or -31 to -1.","title":"by_month_day"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.by_second","text":"The BYSECOND rule part specifies a COMMA-separated list of seconds within a minute. Returns: Type Description None or a list of integers in the range of 0 to 60.","title":"by_second"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.by_set_pos","text":"The BYSETPOS rule part specifies a COMMA-separated list of values that corresponds to the nth occurrence within the set of recurrence instances specified by the rule. BYSETPOS operates on a set of recurrence instances in one interval of the recurrence rule. For example, in a WEEKLY rule, the interval would be one week A set of recurrence instances starts at the beginning of the interval defined by the FREQ rule part. Returns: Type Description None or a list of integers in the range of 1 to 366 or -366 to -1.","title":"by_set_pos"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.by_week_no","text":"The BYWEEKNO rule part specifies a COMMA-separated list of ordinals specifying weeks of the year. For example: 3 represents the third week of the year. Returns: Type Description None or an integer in the range of 1 to 53 or -53 to -1.","title":"by_week_no"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.by_year_day","text":"The BYYEARDAY rule part specifies a COMMA-separated list of days of the year. For example: -1 represents the last day of the year (December 31st). Returns: Type Description None or a tuple of integers in the range of 1 to 366 or -366 to -1.","title":"by_year_day"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.count","text":"The COUNT rule defines the number of occurrences at which to range-bound the recurrence. This is optional but may not occur together with UNTIL. Returns: Type Description None or a positive integer.","title":"count"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.freq","text":"The FREQUENCY rule identifies the type of recurrence rule. Possible values are: SECONDLY, MINUTELY, HOURLY, DAILY, WEEKLY, MONTHLY and YEARLY. This is the only required field. Returns: Type Description The frequency as a string.","title":"freq"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.freq_dateutil","text":"Return the frequency in the format dateutil expects which is a map of the string to an integer. Returns: Type Description An integer in the range of 0 to 6.","title":"freq_dateutil"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.interval","text":"The INTERVAL rule contains a positive integer representing at which intervals the recurrence rule repeats. Returns: Type Description A positive integer.","title":"interval"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.until","text":"The UNTIL rule defines a DATE or DATE-TIME value that bounds the recurrence rule in an inclusive manner. This is optional but may not occur together with COUNT. Returns: Type Description None or a positive integer.","title":"until"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.value_as_dict","text":"Parse all recurrence rule parts as a dictionary, so it can be used as an easy lookup. Returns: Type Description A dict mapping of str to str containing all recurrence rule parts.","title":"value_as_dict"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.wkst","text":"The WKST rule part specifies the day on which the workweek starts. Returns: Type Description A string that is the value of MO, TU, WE, TH, FR, SA, or SU or None.","title":"wkst"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.wkst_dateutil","text":"Return the wkst in the format dateutil expects which is an integer. 0 for MO, 1 for TU, 2 for WE, ... Returns: Type Description An integer in the range of 0 to 6 or None.","title":"wkst_dateutil"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.by_day","text":"The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU Source code in ical_library/ical_properties/rrule.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def by_day ( self ) -> Optional [ List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]]]: \"\"\" The BYDAY rule part specifies a COMMA-separated list of days of the week; SU indicates Sunday; MO indicates Monday; TU indicates Tuesday; WE indicates Wednesday; TH indicates Thursday; FR indicates Friday; and SA indicates Saturday. Each BYDAY value can also be preceded by a positive (+n) or negative (-n) integer. If present, this indicates the nth occurrence of a specific day within the MONTHLY or YEARLY \"RRULE\". Example values are SU,TU or +2SU,-3TU :return None or a list of tuples of two values. The first value represents possible specified nth occurrence or None. The second value the day of the week as a SU, MO, TU, WE, TH, FR or SA. \"\"\" value = self . value_as_dict . get ( \"BYDAY\" ) if not value : return None list_of_days : List [ Tuple [ Optional [ int ], Literal [ \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ]]] = [] for a_day in value . split ( \",\" ): a_day = a_day . strip () nth_occurence : Optional [ int ] = int ( a_day [: - 2 ]) if len ( a_day ) > 2 else None day_of_week : str = a_day [ - 2 :] if day_of_week not in ( \"SU\" , \"MO\" , \"TU\" , \"WE\" , \"TH\" , \"FR\" , \"SA\" ): raise ValueError list_of_days . append (( nth_occurence , day_of_week )) # type: ignore return list_of_days","title":"by_day"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.compute_max_end_date","text":"To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). Parameters: Name Type Description Default starting_datetime Union [ Date , DateTime ] The starting datetime from which we start computing the next occurrences. required component_duration Duration The duration of the component which has the recurring properties. required Returns: Type Description DateTime An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date Source code in ical_library/ical_properties/rrule.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 def compute_max_end_date ( self , starting_datetime : Union [ Date , DateTime ], component_duration : Duration ) -> DateTime : \"\"\" To speed up the computation of the Timelines range, it's good to know the ending of the last recurring event of a recurrence property. This does not need to be perfect, it should just be an estimate (so we don't check EXDate and such). :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param component_duration: The duration of the component which has the recurring properties. :return: An estimate of the maximum end date across all occurrences. This value should always be at least the actual highest recurrence end date \"\"\" if self . until : return dt_utils . convert_time_object_to_aware_datetime ( self . until ) + component_duration # type: ignore elif self . count : if self . count < 1000 : max_datetime = DateTime . max if isinstance ( starting_datetime , DateTime ) else Date ( 9999 , 12 , 31 ) * _ , last = self . sequence_iterator ( starting_datetime = starting_datetime , max_datetime = max_datetime ) return dt_utils . convert_time_object_to_aware_datetime ( last ) + component_duration # type: ignore return DateTime . max","title":"compute_max_end_date"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.convert_str_to_optional_integer_tuple","text":"Converts a string to a Tuple of integers. Returns: Type Description Optional [ Tuple [ int , ...]] None or a Tuple of integers if the value exists, otherwise None. Source code in ical_library/ical_properties/rrule.py 78 79 80 81 82 83 84 85 86 @staticmethod def convert_str_to_optional_integer_tuple ( value : Optional [ str ]) -> Optional [ Tuple [ int , ... ]]: \"\"\" Converts a string to a Tuple of integers. :return: None or a Tuple of integers if the value exists, otherwise None. \"\"\" if not value : return None return tuple ( int ( item ) for item in value . split ( \",\" ))","title":"convert_str_to_optional_integer_tuple"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RRule.sequence_iterator","text":"Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. Parameters: Name Type Description Default starting_datetime Union [ Date , DateTime ] The starting datetime from which we start computing the next occurrences. required max_datetime Union [ Date , DateTime ] The maximum datetime. If we reach this datetime, we stop the iteration.. required Returns: Type Description Iterator [ DateTime ] Yield all datetimes(except itself) in the sequence. Source code in ical_library/ical_properties/rrule.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def sequence_iterator ( self , starting_datetime : Union [ Date , DateTime ], max_datetime : Union [ Date , DateTime ] ) -> Iterator [ DateTime ]: \"\"\" Given a starting datetime, we compute dates according to the RRule specification until the end of the sequence according to the specification is reached or until we reached the max_datetime. :param starting_datetime: The starting datetime from which we start computing the next occurrences. :param max_datetime: The maximum datetime. If we reach this datetime, we stop the iteration.. :return: Yield all datetimes(except itself) in the sequence. \"\"\" if type ( starting_datetime ) != type ( max_datetime ): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of the same type.\" ) if isinstance ( starting_datetime , DateTime ): if ( starting_datetime . tz or max_datetime . tz ) and ( not starting_datetime . tz or not max_datetime . tz ): raise TypeError ( f \"The tz info should be consistent: { starting_datetime =} , { max_datetime =} .\" ) if not isinstance ( starting_datetime , ( Date , DateTime )) or not isinstance ( max_datetime , ( Date , DateTime )): raise TypeError ( f \" { type ( starting_datetime ) =} and { type ( max_datetime ) =} should be of Date or DateTime.\" ) if starting_datetime > max_datetime : raise ValueError ( f \"This should not be the case: { starting_datetime =} >= { max_datetime =} .\" ) if not ( is_datetime_format := isinstance ( starting_datetime , DateTime ) and isinstance ( max_datetime , DateTime )): starting_datetime = DateTime ( starting_datetime . year , starting_datetime . month , starting_datetime . day ) max_datetime = DateTime ( max_datetime . year , max_datetime . month , max_datetime . day ) starting_datetime = starting_datetime max_datetime = max_datetime starting_tz = starting_datetime . tz until = self . until if until : if not isinstance ( until , DateTime ): until = DateTime ( until . year , until . month , until . day ) until = until . replace ( tzinfo = None ) if starting_tz is None else until . in_timezone ( starting_tz ) keyword_arguments = { \"until\" : until , \"count\" : self . count , \"interval\" : self . interval , \"bysecond\" : self . by_second , \"byminute\" : self . by_minute , \"byhour\" : self . by_hour , \"byweekday\" : self . by_day_dateutil , \"bymonthday\" : self . by_month_day , \"byyearday\" : self . by_year_day , \"byweekno\" : self . by_week_no , \"bymonth\" : self . by_month , \"bysetpos\" : self . by_set_pos , \"wkst\" : self . wkst_dateutil , \"byeaster\" : self . by_easter , } no_none_keywords = { key : value for key , value in keyword_arguments . items () if value is not None } dt_iterator = rrule ( dtstart = starting_datetime , freq = self . freq_dateutil , ** no_none_keywords ) for dt in dt_iterator : if dt > max_datetime : break p_instance = pendulum . instance ( dt , tz = None ) yield p_instance if is_datetime_format else p_instance . date ()","title":"sequence_iterator"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RecurrenceID","text":"Bases: _DTBoth The RECURRENCE-ID property is defined as followed. This property is used in conjunction with the \"UID\" and \"SEQUENCE\" properties to identify a specific instance of a recurring \"VEVENT\", \"VTODO\", or \"VJOURNAL\" calendar component. The property value is the original value of the \"DTSTART\" property of the recurrence instance. Value Type: The default value type is DATE-TIME. The value type can be set to a DATE value type. This property MUST have the same value type as the \"DTSTART\" property contained within the recurring component. Furthermore, this property MUST be specified as a date with local time if and only if the \"DTSTART\" property contained within the recurring component is specified as a date with local time. Source code in ical_library/ical_properties/dt.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class RecurrenceID ( _DTBoth ): \"\"\" The RECURRENCE-ID property is defined as followed. This property is used in conjunction with the \"UID\" and \"SEQUENCE\" properties to identify a specific instance of a recurring \"VEVENT\", \"VTODO\", or \"VJOURNAL\" calendar component. The property value is the original value of the \"DTSTART\" property of the recurrence instance. Value Type: The default value type is DATE-TIME. The value type can be set to a DATE value type. This property MUST have the same value type as the \"DTSTART\" property contained within the recurring component. Furthermore, this property MUST be specified as a date with local time if and only if the \"DTSTART\" property contained within the recurring component is specified as a date with local time. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"RECURRENCE-ID\"","title":"RecurrenceID"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RecurrenceID.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not LASTMODIFIED but LAST-MODIFIED . Source code in ical_library/ical_properties/dt.py 86 87 88 89 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *LASTMODIFIED* but *LAST-MODIFIED*.\"\"\" return \"RECURRENCE-ID\"","title":"get_ical_name_of_class"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RelatedTo","text":"Bases: Property The RELATED-TO property is used to represent a relationship or reference between one calendar component and another. Source code in ical_library/ical_properties/pass_properties.py 106 107 108 109 110 111 112 113 114 class RelatedTo ( Property ): \"\"\" The RELATED-TO property is used to represent a relationship or reference between one calendar component and another. \"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *RELATEDTO* but *RELATED-TO*.\"\"\" return \"RELATED-TO\"","title":"RelatedTo"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RelatedTo.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not RELATEDTO but RELATED-TO . Source code in ical_library/ical_properties/pass_properties.py 111 112 113 114 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *RELATEDTO* but *RELATED-TO*.\"\"\" return \"RELATED-TO\"","title":"get_ical_name_of_class"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Repeat","text":"Bases: _IntProperty The REPEAT property defines the number of times the alarm should be repeated, after the initial trigger. Source code in ical_library/ical_properties/ints.py 27 28 29 30 class Repeat ( _IntProperty ): \"\"\"The REPEAT property defines the number of times the alarm should be repeated, after the initial trigger.\"\"\" pass","title":"Repeat"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RequestStatus","text":"Bases: Property The REQUEST-STATUS property defines the status code returned for a scheduling request. Source code in ical_library/ical_properties/pass_properties.py 97 98 99 100 101 102 103 class RequestStatus ( Property ): \"\"\"The REQUEST-STATUS property defines the status code returned for a scheduling request.\"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *REQUESTSTATUS* but *REQUEST-STATUS*.\"\"\" return \"REQUEST-STATUS\"","title":"RequestStatus"},{"location":"code/properties/all_properties/#ical_library.ical_properties.RequestStatus.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not REQUESTSTATUS but REQUEST-STATUS . Source code in ical_library/ical_properties/pass_properties.py 100 101 102 103 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *REQUESTSTATUS* but *REQUEST-STATUS*.\"\"\" return \"REQUEST-STATUS\"","title":"get_ical_name_of_class"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Resources","text":"Bases: Property The RESOURCES property defines the equipment or resources anticipated for an activity specified by a calendar component. Source code in ical_library/ical_properties/pass_properties.py 117 118 119 120 121 122 123 class Resources ( Property ): \"\"\" The RESOURCES property defines the equipment or resources anticipated for an activity specified by a calendar component. \"\"\" pass","title":"Resources"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Sequence","text":"Bases: _IntProperty The SEQUENCE property defines the revision sequence number of the calendar component within a sequence of revisions. Source code in ical_library/ical_properties/ints.py 19 20 21 22 23 24 class Sequence ( _IntProperty ): \"\"\" The SEQUENCE property defines the revision sequence number of the calendar component within a sequence of revisions. \"\"\" pass","title":"Sequence"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Status","text":"Bases: Property The STATUS property defines the overall status or confirmation for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 55 56 57 58 class Status ( Property ): \"\"\"The STATUS property defines the overall status or confirmation for the calendar component.\"\"\" pass","title":"Status"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Summary","text":"Bases: Property The SUMMARY property defines a short summary or subject for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 168 169 170 171 172 173 class Summary ( Property ): \"\"\" The SUMMARY property defines a short summary or subject for the calendar component. \"\"\" pass","title":"Summary"},{"location":"code/properties/all_properties/#ical_library.ical_properties.TZID","text":"Bases: Property The TZID property specifies the text value that uniquely identifies the \"VTIMEZONE\" calendar component in the scope of an iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 150 151 152 153 154 155 156 class TZID ( Property ): \"\"\" The TZID property specifies the text value that uniquely identifies the \"VTIMEZONE\" calendar component in the scope of an iCalendar object. \"\"\" pass","title":"TZID"},{"location":"code/properties/all_properties/#ical_library.ical_properties.TZName","text":"Bases: Property The TZNAME property specifies the customary designation for a time zone description. Source code in ical_library/ical_properties/pass_properties.py 144 145 146 147 class TZName ( Property ): \"\"\"The TZNAME property specifies the customary designation for a time zone description.\"\"\" pass","title":"TZName"},{"location":"code/properties/all_properties/#ical_library.ical_properties.TZOffsetFrom","text":"Bases: _TZOffset The TZOFFSETFROM property specifies the offset that is in use prior to this time zone observance. Source code in ical_library/ical_properties/tz_offset.py 33 34 35 36 class TZOffsetFrom ( _TZOffset ): \"\"\"The TZOFFSETFROM property specifies the offset that is in use prior to this time zone observance.\"\"\" pass","title":"TZOffsetFrom"},{"location":"code/properties/all_properties/#ical_library.ical_properties.TZOffsetTo","text":"Bases: _TZOffset The TZOFFSETTO property specifies the offset that is in use prior to this time zone observance. Source code in ical_library/ical_properties/tz_offset.py 27 28 29 30 class TZOffsetTo ( _TZOffset ): \"\"\"The TZOFFSETTO property specifies the offset that is in use prior to this time zone observance.\"\"\" pass","title":"TZOffsetTo"},{"location":"code/properties/all_properties/#ical_library.ical_properties.TZURL","text":"Bases: Property The TZURL property provides a means for a \"VTIMEZONE\" component to point to a network location that can be used to retrieve an up- to-date version of itself. Source code in ical_library/ical_properties/pass_properties.py 159 160 161 162 163 164 165 class TZURL ( Property ): \"\"\" The TZURL property provides a means for a \"VTIMEZONE\" component to point to a network location that can be used to retrieve an up- to-date version of itself. \"\"\" pass","title":"TZURL"},{"location":"code/properties/all_properties/#ical_library.ical_properties.TimeTransparency","text":"Bases: Property The TRANSP property defines whether an event is transparent to busy time searches. Source code in ical_library/ical_properties/pass_properties.py 61 62 63 64 65 66 67 class TimeTransparency ( Property ): \"\"\"The TRANSP property defines whether an event is transparent to busy time searches.\"\"\" @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *TIMETRANSPARANCY* but *TRANSP*.\"\"\" return \"TRANSP\"","title":"TimeTransparency"},{"location":"code/properties/all_properties/#ical_library.ical_properties.TimeTransparency.get_ical_name_of_class","text":"Overwrite the iCal name of this class as it is not TIMETRANSPARANCY but TRANSP . Source code in ical_library/ical_properties/pass_properties.py 64 65 66 67 @classmethod def get_ical_name_of_class ( cls ) -> str : \"\"\"Overwrite the iCal name of this class as it is not *TIMETRANSPARANCY* but *TRANSP*.\"\"\" return \"TRANSP\"","title":"get_ical_name_of_class"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Trigger","text":"Bases: Property The TRIGGER property specifies when an alarm will trigger. Source code in ical_library/ical_properties/trigger.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Trigger ( Property ): \"\"\"The TRIGGER property specifies when an alarm will trigger.\"\"\" @property def kind ( self ) -> Literal [ \"DATE-TIME\" , \"DURATION\" ]: \"\"\"Return the type of the property value.\"\"\" kind_of_value = self . get_property_parameter ( \"VALUE\" ) return \"DATE-TIME\" if kind_of_value and kind_of_value == \"DATE-TIME\" else \"DURATION\" # noqa def parse_value ( self ) -> Union [ Duration , DateTime ]: \"\"\"Parse the value of this property based on the VALUE property parameter.\"\"\" if self . kind == \"DURATION\" : parsed_value : Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value else : parsed_value : DateTime = pendulum . parse ( self . value ) if not isinstance ( parsed_value , DateTime ): raise TypeError ( f \"Invalid value passed for DateTime: { self . value =} \" ) return parsed_value def trigger_relation ( self ) -> Literal [ \"START\" , \"END\" ]: \"\"\"Get the trigger relation, whether the duration should be relative to the start or the end of a component.\"\"\" return \"START\" if self . get_property_parameter_default ( \"RELATED\" , \"START\" ) == \"START\" else \"END\" # noqa","title":"Trigger"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Trigger.kind","text":"Return the type of the property value.","title":"kind"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Trigger.parse_value","text":"Parse the value of this property based on the VALUE property parameter. Source code in ical_library/ical_properties/trigger.py 18 19 20 21 22 23 24 25 26 27 28 29 def parse_value ( self ) -> Union [ Duration , DateTime ]: \"\"\"Parse the value of this property based on the VALUE property parameter.\"\"\" if self . kind == \"DURATION\" : parsed_value : Duration = pendulum . parse ( self . value ) if not isinstance ( parsed_value , Duration ): raise TypeError ( f \"Invalid value passed for Duration: { self . value =} \" ) return parsed_value else : parsed_value : DateTime = pendulum . parse ( self . value ) if not isinstance ( parsed_value , DateTime ): raise TypeError ( f \"Invalid value passed for DateTime: { self . value =} \" ) return parsed_value","title":"parse_value"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Trigger.trigger_relation","text":"Get the trigger relation, whether the duration should be relative to the start or the end of a component. Source code in ical_library/ical_properties/trigger.py 31 32 33 def trigger_relation ( self ) -> Literal [ \"START\" , \"END\" ]: \"\"\"Get the trigger relation, whether the duration should be relative to the start or the end of a component.\"\"\" return \"START\" if self . get_property_parameter_default ( \"RELATED\" , \"START\" ) == \"START\" else \"END\" # noqa","title":"trigger_relation"},{"location":"code/properties/all_properties/#ical_library.ical_properties.UID","text":"Bases: Property The UID property defines the persistent, globally unique identifier for the calendar component. Source code in ical_library/ical_properties/pass_properties.py 132 133 134 135 class UID ( Property ): \"\"\"The UID property defines the persistent, globally unique identifier for the calendar component.\"\"\" pass","title":"UID"},{"location":"code/properties/all_properties/#ical_library.ical_properties.URL","text":"Bases: Property The URL property defines a Uniform Resource Locator (URL) associated with the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 70 71 72 73 class URL ( Property ): \"\"\"The URL property defines a Uniform Resource Locator (URL) associated with the iCalendar object.\"\"\" pass","title":"URL"},{"location":"code/properties/all_properties/#ical_library.ical_properties.Version","text":"Bases: Property The VERSION property specifies the identifier corresponding to the highest version number or the minimum and maximum range of the iCalendar specification that is required in order to interpret the iCalendar object. Source code in ical_library/ical_properties/pass_properties.py 10 11 12 13 14 15 16 class Version ( Property ): \"\"\" The VERSION property specifies the identifier corresponding to the highest version number or the minimum and maximum range of the iCalendar specification that is required in order to interpret the iCalendar object. \"\"\" pass","title":"Version"},{"location":"code/properties/base_class/","text":"Property base class All Properties are extending the Property class. Let's first start with the base class and then list all the other properties. Property Bases: ICalBaseClass This is the base class for any property (according to the RFC 5545 specification) in iCal-library. A property always exists of three parts: The name of the property. The property parameters, this is optional and does not need to be present. The value of the property. A line containing a property typically has the following format: PROPERTY-NAME;parameterKey=parameterValue,anotherParameterKey=anotherValue:actual-value Any property that is predefined according to the RFC 5545 should inherit this class, e.g. UID, RRule. Only x-properties or iana-properties should instantiate the Property class directly. Parameters: Name Type Description Default value Optional [ str ] The value of the property. required name Optional [ str ] The properties name, e.g. RRULE . None property_parameters Optional [ str ] The property parameters for this definition. None parent Component Instance of the :class: Component it is a part of. None Source code in ical_library/base_classes/property.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class Property ( ICalBaseClass ): \"\"\" This is the base class for any property (according to the RFC 5545 specification) in iCal-library. A property always exists of three parts: - The name of the property. - The property parameters, this is optional and does not need to be present. - The value of the property. A line containing a property typically has the following format: `PROPERTY-NAME;parameterKey=parameterValue,anotherParameterKey=anotherValue:actual-value` Any property that is predefined according to the RFC 5545 should inherit this class, e.g. UID, RRule. Only x-properties or iana-properties should instantiate the Property class directly. :param value: The value of the property. :param name: The properties name, e.g. `RRULE`. :param property_parameters: The property parameters for this definition. :param parent: Instance of the :class:`Component` it is a part of. \"\"\" def __init__ ( self , value : Optional [ str ], name : Optional [ str ] = None , property_parameters : Optional [ str ] = None , parent : \"Component\" = None , ): name = name if self . __class__ == Property else self . __class__ . get_ical_name_of_class () super () . __init__ ( name = name , parent = parent or ComponentContext . get_current_component ()) if parent is None and self . parent is not None : self . parent . set_property ( self ) self . _property_parameters : Optional [ str ] = property_parameters self . _value : Optional [ str ] = value def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \" { self . __class__ . __name__ } ( { self . as_original_string } )\" def __eq__ ( self : \"Property\" , other : \"Property\" ) -> bool : \"\"\"Return whether the current instance and the other instance are the same.\"\"\" if type ( self ) != type ( other ): return False return self . as_original_string == other . as_original_string @property @instance_lru_cache () def property_parameters ( self ) -> Dict [ str , str ]: \"\"\" Return (and cache) all the property's parameters as a dictionary of strings. Note: When the instance is collected by the garbage collection, the cache is automatically deleted as well. :return: all the property's parameters as a dictionary of strings \"\"\" property_parameters_str = self . _property_parameters or \"\" return { key_and_value . split ( \"=\" )[ 0 ]: key_and_value . split ( \"=\" )[ 1 ] for key_and_value in property_parameters_str . split ( \",\" ) if key_and_value . count ( \"=\" ) == 1 } def has_property_parameter ( self , key : str ) -> Optional [ bool ]: \"\"\" Return whether this property has a property parameter with a specific *key*. :param key: What key to search for. :return: boolean whether this property has a property parameter with a specific *key*. \"\"\" return key in self . property_parameters def get_property_parameter ( self , key : str ) -> Optional [ str ]: \"\"\" Get a property parameter's value with a specific key. :param key: The identifier of the property parameter. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , None ) def get_property_parameter_default ( self , key : str , default : str ) -> str : \"\"\" Get a property parameter's value with a specific key, where the default may not be None. :param key: The identifier of the property parameter. :param default: A value to return when the property parameter is not present, which may not be None. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , default ) @property def value ( self ) -> Optional [ str ]: \"\"\"Return the value of this property.\"\"\" return self . _value @property def as_original_string ( self ) -> str : \"\"\" Return the iCalendar representation of the parameter. :return: the iCalendar string representation. \"\"\" add_subs = f \"; { self . _property_parameters } \" if self . _property_parameters else \"\" return f \" { self . _name }{ add_subs } : { self . _value } \" as_original_string : str property Return the iCalendar representation of the parameter. Returns: Type Description the iCalendar string representation. property_parameters : Dict [ str , str ] property Return (and cache) all the property's parameters as a dictionary of strings. Note: When the instance is collected by the garbage collection, the cache is automatically deleted as well. Returns: Type Description all the property's parameters as a dictionary of strings value : Optional [ str ] property Return the value of this property. get_property_parameter ( key ) Get a property parameter's value with a specific key. Parameters: Name Type Description Default key str The identifier of the property parameter. required Returns: Type Description Optional [ str ] The requested property parameter, or if that is not present, the default value. Source code in ical_library/base_classes/property.py 84 85 86 87 88 89 90 91 def get_property_parameter ( self , key : str ) -> Optional [ str ]: \"\"\" Get a property parameter's value with a specific key. :param key: The identifier of the property parameter. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , None ) get_property_parameter_default ( key , default ) Get a property parameter's value with a specific key, where the default may not be None. Parameters: Name Type Description Default key str The identifier of the property parameter. required default str A value to return when the property parameter is not present, which may not be None. required Returns: Type Description str The requested property parameter, or if that is not present, the default value. Source code in ical_library/base_classes/property.py 93 94 95 96 97 98 99 100 101 def get_property_parameter_default ( self , key : str , default : str ) -> str : \"\"\" Get a property parameter's value with a specific key, where the default may not be None. :param key: The identifier of the property parameter. :param default: A value to return when the property parameter is not present, which may not be None. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , default ) has_property_parameter ( key ) Return whether this property has a property parameter with a specific key . Parameters: Name Type Description Default key str What key to search for. required Returns: Type Description Optional [ bool ] boolean whether this property has a property parameter with a specific key . Source code in ical_library/base_classes/property.py 75 76 77 78 79 80 81 82 def has_property_parameter ( self , key : str ) -> Optional [ bool ]: \"\"\" Return whether this property has a property parameter with a specific *key*. :param key: What key to search for. :return: boolean whether this property has a property parameter with a specific *key*. \"\"\" return key in self . property_parameters","title":"Base classes"},{"location":"code/properties/base_class/#property-base-class","text":"All Properties are extending the Property class. Let's first start with the base class and then list all the other properties.","title":"Property base class"},{"location":"code/properties/base_class/#ical_library.base_classes.Property","text":"Bases: ICalBaseClass This is the base class for any property (according to the RFC 5545 specification) in iCal-library. A property always exists of three parts: The name of the property. The property parameters, this is optional and does not need to be present. The value of the property. A line containing a property typically has the following format: PROPERTY-NAME;parameterKey=parameterValue,anotherParameterKey=anotherValue:actual-value Any property that is predefined according to the RFC 5545 should inherit this class, e.g. UID, RRule. Only x-properties or iana-properties should instantiate the Property class directly. Parameters: Name Type Description Default value Optional [ str ] The value of the property. required name Optional [ str ] The properties name, e.g. RRULE . None property_parameters Optional [ str ] The property parameters for this definition. None parent Component Instance of the :class: Component it is a part of. None Source code in ical_library/base_classes/property.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 class Property ( ICalBaseClass ): \"\"\" This is the base class for any property (according to the RFC 5545 specification) in iCal-library. A property always exists of three parts: - The name of the property. - The property parameters, this is optional and does not need to be present. - The value of the property. A line containing a property typically has the following format: `PROPERTY-NAME;parameterKey=parameterValue,anotherParameterKey=anotherValue:actual-value` Any property that is predefined according to the RFC 5545 should inherit this class, e.g. UID, RRule. Only x-properties or iana-properties should instantiate the Property class directly. :param value: The value of the property. :param name: The properties name, e.g. `RRULE`. :param property_parameters: The property parameters for this definition. :param parent: Instance of the :class:`Component` it is a part of. \"\"\" def __init__ ( self , value : Optional [ str ], name : Optional [ str ] = None , property_parameters : Optional [ str ] = None , parent : \"Component\" = None , ): name = name if self . __class__ == Property else self . __class__ . get_ical_name_of_class () super () . __init__ ( name = name , parent = parent or ComponentContext . get_current_component ()) if parent is None and self . parent is not None : self . parent . set_property ( self ) self . _property_parameters : Optional [ str ] = property_parameters self . _value : Optional [ str ] = value def __repr__ ( self ) -> str : \"\"\"Overwrite the repr to create a better representation for the item.\"\"\" return f \" { self . __class__ . __name__ } ( { self . as_original_string } )\" def __eq__ ( self : \"Property\" , other : \"Property\" ) -> bool : \"\"\"Return whether the current instance and the other instance are the same.\"\"\" if type ( self ) != type ( other ): return False return self . as_original_string == other . as_original_string @property @instance_lru_cache () def property_parameters ( self ) -> Dict [ str , str ]: \"\"\" Return (and cache) all the property's parameters as a dictionary of strings. Note: When the instance is collected by the garbage collection, the cache is automatically deleted as well. :return: all the property's parameters as a dictionary of strings \"\"\" property_parameters_str = self . _property_parameters or \"\" return { key_and_value . split ( \"=\" )[ 0 ]: key_and_value . split ( \"=\" )[ 1 ] for key_and_value in property_parameters_str . split ( \",\" ) if key_and_value . count ( \"=\" ) == 1 } def has_property_parameter ( self , key : str ) -> Optional [ bool ]: \"\"\" Return whether this property has a property parameter with a specific *key*. :param key: What key to search for. :return: boolean whether this property has a property parameter with a specific *key*. \"\"\" return key in self . property_parameters def get_property_parameter ( self , key : str ) -> Optional [ str ]: \"\"\" Get a property parameter's value with a specific key. :param key: The identifier of the property parameter. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , None ) def get_property_parameter_default ( self , key : str , default : str ) -> str : \"\"\" Get a property parameter's value with a specific key, where the default may not be None. :param key: The identifier of the property parameter. :param default: A value to return when the property parameter is not present, which may not be None. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , default ) @property def value ( self ) -> Optional [ str ]: \"\"\"Return the value of this property.\"\"\" return self . _value @property def as_original_string ( self ) -> str : \"\"\" Return the iCalendar representation of the parameter. :return: the iCalendar string representation. \"\"\" add_subs = f \"; { self . _property_parameters } \" if self . _property_parameters else \"\" return f \" { self . _name }{ add_subs } : { self . _value } \"","title":"Property"},{"location":"code/properties/base_class/#ical_library.base_classes.Property.as_original_string","text":"Return the iCalendar representation of the parameter. Returns: Type Description the iCalendar string representation.","title":"as_original_string"},{"location":"code/properties/base_class/#ical_library.base_classes.Property.property_parameters","text":"Return (and cache) all the property's parameters as a dictionary of strings. Note: When the instance is collected by the garbage collection, the cache is automatically deleted as well. Returns: Type Description all the property's parameters as a dictionary of strings","title":"property_parameters"},{"location":"code/properties/base_class/#ical_library.base_classes.Property.value","text":"Return the value of this property.","title":"value"},{"location":"code/properties/base_class/#ical_library.base_classes.Property.get_property_parameter","text":"Get a property parameter's value with a specific key. Parameters: Name Type Description Default key str The identifier of the property parameter. required Returns: Type Description Optional [ str ] The requested property parameter, or if that is not present, the default value. Source code in ical_library/base_classes/property.py 84 85 86 87 88 89 90 91 def get_property_parameter ( self , key : str ) -> Optional [ str ]: \"\"\" Get a property parameter's value with a specific key. :param key: The identifier of the property parameter. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , None )","title":"get_property_parameter"},{"location":"code/properties/base_class/#ical_library.base_classes.Property.get_property_parameter_default","text":"Get a property parameter's value with a specific key, where the default may not be None. Parameters: Name Type Description Default key str The identifier of the property parameter. required default str A value to return when the property parameter is not present, which may not be None. required Returns: Type Description str The requested property parameter, or if that is not present, the default value. Source code in ical_library/base_classes/property.py 93 94 95 96 97 98 99 100 101 def get_property_parameter_default ( self , key : str , default : str ) -> str : \"\"\" Get a property parameter's value with a specific key, where the default may not be None. :param key: The identifier of the property parameter. :param default: A value to return when the property parameter is not present, which may not be None. :return: The requested property parameter, or if that is not present, the default value. \"\"\" return self . property_parameters . get ( key , default )","title":"get_property_parameter_default"},{"location":"code/properties/base_class/#ical_library.base_classes.Property.has_property_parameter","text":"Return whether this property has a property parameter with a specific key . Parameters: Name Type Description Default key str What key to search for. required Returns: Type Description Optional [ bool ] boolean whether this property has a property parameter with a specific key . Source code in ical_library/base_classes/property.py 75 76 77 78 79 80 81 82 def has_property_parameter ( self , key : str ) -> Optional [ bool ]: \"\"\" Return whether this property has a property parameter with a specific *key*. :param key: What key to search for. :return: boolean whether this property has a property parameter with a specific *key*. \"\"\" return key in self . property_parameters","title":"has_property_parameter"},{"location":"code/properties/help_classes/","text":"Help classes Sometimes properties have a lot in common. Instead of constantly redefining all methods, we simply create an abstraction from the properties which we call help classes. This is the list of all help classes. _IntProperty Bases: Property This property class should be inherited. It represents a property that contain just an int as value. Source code in ical_library/ical_properties/ints.py 4 5 6 7 8 9 10 class _IntProperty ( Property ): \"\"\"This property class should be inherited. It represents a property that contain just an int as value.\"\"\" @property def int_value ( self ) -> int : \"\"\"Return the value as an int.\"\"\" return int ( self . value ) int_value : int property Return the value as an int. _DTBoth Bases: Property This property class should be inherited. It represents a property that contain a datetime or date as value. Source code in ical_library/ical_properties/dt.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class _DTBoth ( Property ): \"\"\"This property class should be inherited. It represents a property that contain a datetime or date as value.\"\"\" @property def datetime_or_date_value ( self ) -> Union [ Date , DateTime ]: \"\"\"Return the value as a DateTime or Date value taking into account the optional TZID property parameter.\"\"\" value = dt_utils . parse_date_or_datetime ( self . value ) if isinstance ( value , DateTime ): tz_id = self . get_property_parameter ( \"TZID\" ) if value . tz or not tz_id : return value return self . parent . tree_root . get_aware_dt_for_timezone ( dt = value , tzid = tz_id ) elif isinstance ( value , Date ): return value else : raise TypeError ( f \"Unknown { type ( value ) =} returned for { value =} .\" ) def get_datetime_or_date_value_in_specific_tz ( self , tz : FixedTimezone ) -> Union [ Date , DateTime ]: \"\"\"Return the value as a DateTime or Date value in a specific timezone.\"\"\" value = dt_utils . parse_date_or_datetime ( self . value ) if isinstance ( value , DateTime ): return value . in_timezone ( tz ) elif isinstance ( value , Date ): return value else : raise TypeError ( f \"Unknown { type ( value ) =} returned for { value =} .\" ) datetime_or_date_value : Union [ Date , DateTime ] property Return the value as a DateTime or Date value taking into account the optional TZID property parameter. get_datetime_or_date_value_in_specific_tz ( tz ) Return the value as a DateTime or Date value in a specific timezone. Source code in ical_library/ical_properties/dt.py 28 29 30 31 32 33 34 35 36 def get_datetime_or_date_value_in_specific_tz ( self , tz : FixedTimezone ) -> Union [ Date , DateTime ]: \"\"\"Return the value as a DateTime or Date value in a specific timezone.\"\"\" value = dt_utils . parse_date_or_datetime ( self . value ) if isinstance ( value , DateTime ): return value . in_timezone ( tz ) elif isinstance ( value , Date ): return value else : raise TypeError ( f \"Unknown { type ( value ) =} returned for { value =} .\" ) _DTSingular Bases: Property This property class should be inherited. It represents a property that can only contain a datetime as value. Source code in ical_library/ical_properties/dt.py 39 40 41 42 43 44 45 46 47 48 49 class _DTSingular ( Property ): \"\"\"This property class should be inherited. It represents a property that can only contain a datetime as value.\"\"\" @property def datetime ( self ) -> DateTime : \"\"\"Return the value as a DateTime value taking into account the optional TZID property parameter.\"\"\" value = pendulum . parse ( self . value , tz = None ) tz_id = self . get_property_parameter ( \"TZID\" ) if value . tz or not tz_id : return value return self . parent . tree_root . get_aware_dt_for_timezone ( dt = value , tzid = tz_id ) datetime : DateTime property Return the value as a DateTime value taking into account the optional TZID property parameter. _CalAddress Bases: Property Source code in ical_library/ical_properties/cal_address.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class _CalAddress ( Property ): @property def persons_name ( self ) -> Optional [ str ]: \"\"\"Return the persons name, identified by the CN property parameter.\"\"\" return self . get_property_parameter ( \"CN\" ) @property def email ( self ) -> Optional [ str ]: \"\"\"Return the email if the value starts with `mailto:`. Otherwise return None.\"\"\" if self . value . startswith ( \"mailto:\" ): return self . value [ len ( \"mailto:\" ) :] return None @property def cu_type ( self ) -> str : \"\"\"Return the CUTYPE.\"\"\" return self . get_property_parameter_default ( \"CUTYPE\" , default = \"INDIVIDUAL\" ) @property def member ( self ) -> Optional [ str ]: \"\"\"Return the membership property parameter.\"\"\" return self . get_property_parameter ( \"MEMBER\" ) @property def role ( self ) -> str : \"\"\"Return the role of the person.\"\"\" return self . get_property_parameter_default ( \"ROLE\" , default = \"REQ-PARTICIPANT\" ) @property def participation_status ( self ) -> str : \"\"\"Return the participation status, indicating whether the person will be present or not.\"\"\" return self . get_property_parameter_default ( \"PARTSTAT\" , default = \"NEEDS-ACTION\" ) cu_type : str property Return the CUTYPE. email : Optional [ str ] property Return the email if the value starts with mailto: . Otherwise return None. member : Optional [ str ] property Return the membership property parameter. participation_status : str property Return the participation status, indicating whether the person will be present or not. persons_name : Optional [ str ] property Return the persons name, identified by the CN property parameter. role : str property Return the role of the person. _PeriodFunctionality Bases: Property Provide methods to help to parse duration values. This class should be inherited by a Property. Source code in ical_library/ical_properties/periods.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class _PeriodFunctionality ( Property ): \"\"\" Provide methods to help to parse duration values. This class should be inherited by a Property. \"\"\" def _parse_period_values ( self ) -> List [ Tuple [ DateTime , DateTime ]]: \"\"\" Parse multiple values, delimited by comma's, representing periods. Example value for self.value: 19960403T020000Z/19960403T040000Z,19960404T010000Z/PT3H :return: List of tuples containing two DateTimes representing the start and end of the duration respectively. \"\"\" list_of_periods : List [ Tuple [ DateTime , DateTime ]] = [] for item in self . value . split ( \",\" ): item = item . strip () instance = self . _parse_individual_duration_str ( item ) if not isinstance ( instance , tuple ) or len ( instance ) != 2 : raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a tuple.\" ) for index , sub_instance in enumerate ( instance ): if not isinstance ( sub_instance , DateTime ): raise TypeError ( f \" { instance [ index ] =} is of { type ( sub_instance ) =} while it should be of type \" f \"Tuple[DateTime, DateTime].\" ) list_of_periods . append ( instance ) return list_of_periods def _parse_individual_datetime_or_duration_str ( self , datetime_or_duration_str : str ) -> Union [ DateTime , Duration ]: \"\"\" Parse an individual datetime or duration string. :param datetime_or_duration_str: A string represent either a datetime or duration. :return: A pendulum.DateTime if the string represented a datetime. Return a pendulum.Duration otherwise. \"\"\" tz_id = self . get_property_parameter ( \"TZID\" ) tz = self . parent . tree_root . get_timezone ( tz_id ) . get_as_timezone_object () if tz_id else None return pendulum . parse ( datetime_or_duration_str , tz = tz ) def _parse_individual_duration_str ( self , period_str : str ) -> Tuple [ DateTime , DateTime ]: \"\"\" Parse an individual period represented by DateTime/DateTime or DateTime/Duration. :param period_str: The period to parse. Examples: 19960403T020000Z/19960403T040000Z or 19960404T010000Z/PT3H :return: A tuple containing two DateTimes representing the start and end of the duration respectively. \"\"\" first_str , second_str = period_str . split ( \"/\" ) first_instance : DateTime = self . _parse_individual_datetime_or_duration_str ( first_str ) second_instance : Union [ DateTime , Duration ] = self . _parse_individual_datetime_or_duration_str ( second_str ) if not isinstance ( first_instance , DateTime ): raise TypeError ( f \"Expected { period_str =} to contain a DateTime as first argument.\" ) if isinstance ( second_instance , DateTime ): return first_instance , second_instance elif isinstance ( second_instance , Duration ): computed_datetime : DateTime = first_instance + second_instance # type: ignore # Pendulum at fault return first_instance , computed_datetime else : raise TypeError ( f \"Expected { period_str =} to contain a DateTime or Duration as second argument.\" ) _parse_individual_datetime_or_duration_str ( datetime_or_duration_str ) Parse an individual datetime or duration string. Parameters: Name Type Description Default datetime_or_duration_str str A string represent either a datetime or duration. required Returns: Type Description Union [ DateTime , Duration ] A pendulum.DateTime if the string represented a datetime. Return a pendulum.Duration otherwise. Source code in ical_library/ical_properties/periods.py 39 40 41 42 43 44 45 46 47 def _parse_individual_datetime_or_duration_str ( self , datetime_or_duration_str : str ) -> Union [ DateTime , Duration ]: \"\"\" Parse an individual datetime or duration string. :param datetime_or_duration_str: A string represent either a datetime or duration. :return: A pendulum.DateTime if the string represented a datetime. Return a pendulum.Duration otherwise. \"\"\" tz_id = self . get_property_parameter ( \"TZID\" ) tz = self . parent . tree_root . get_timezone ( tz_id ) . get_as_timezone_object () if tz_id else None return pendulum . parse ( datetime_or_duration_str , tz = tz ) _parse_individual_duration_str ( period_str ) Parse an individual period represented by DateTime/DateTime or DateTime/Duration. Parameters: Name Type Description Default period_str str The period to parse. Examples: 19960403T020000Z/19960403T040000Z or 19960404T010000Z/PT3H required Returns: Type Description Tuple [ DateTime , DateTime ] A tuple containing two DateTimes representing the start and end of the duration respectively. Source code in ical_library/ical_properties/periods.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def _parse_individual_duration_str ( self , period_str : str ) -> Tuple [ DateTime , DateTime ]: \"\"\" Parse an individual period represented by DateTime/DateTime or DateTime/Duration. :param period_str: The period to parse. Examples: 19960403T020000Z/19960403T040000Z or 19960404T010000Z/PT3H :return: A tuple containing two DateTimes representing the start and end of the duration respectively. \"\"\" first_str , second_str = period_str . split ( \"/\" ) first_instance : DateTime = self . _parse_individual_datetime_or_duration_str ( first_str ) second_instance : Union [ DateTime , Duration ] = self . _parse_individual_datetime_or_duration_str ( second_str ) if not isinstance ( first_instance , DateTime ): raise TypeError ( f \"Expected { period_str =} to contain a DateTime as first argument.\" ) if isinstance ( second_instance , DateTime ): return first_instance , second_instance elif isinstance ( second_instance , Duration ): computed_datetime : DateTime = first_instance + second_instance # type: ignore # Pendulum at fault return first_instance , computed_datetime else : raise TypeError ( f \"Expected { period_str =} to contain a DateTime or Duration as second argument.\" ) _parse_period_values () Parse multiple values, delimited by comma's, representing periods. Example value for self.value: 19960403T020000Z/19960403T040000Z,19960404T010000Z/PT3H Returns: Type Description List [ Tuple [ DateTime , DateTime ]] List of tuples containing two DateTimes representing the start and end of the duration respectively. Source code in ical_library/ical_properties/periods.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def _parse_period_values ( self ) -> List [ Tuple [ DateTime , DateTime ]]: \"\"\" Parse multiple values, delimited by comma's, representing periods. Example value for self.value: 19960403T020000Z/19960403T040000Z,19960404T010000Z/PT3H :return: List of tuples containing two DateTimes representing the start and end of the duration respectively. \"\"\" list_of_periods : List [ Tuple [ DateTime , DateTime ]] = [] for item in self . value . split ( \",\" ): item = item . strip () instance = self . _parse_individual_duration_str ( item ) if not isinstance ( instance , tuple ) or len ( instance ) != 2 : raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a tuple.\" ) for index , sub_instance in enumerate ( instance ): if not isinstance ( sub_instance , DateTime ): raise TypeError ( f \" { instance [ index ] =} is of { type ( sub_instance ) =} while it should be of type \" f \"Tuple[DateTime, DateTime].\" ) list_of_periods . append ( instance ) return list_of_periods _ExOrRDate Bases: _PeriodFunctionality Provide methods to help to parse different kind of values a Property could find. This class should be inherited by a Property. Source code in ical_library/ical_properties/periods.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class _ExOrRDate ( _PeriodFunctionality ): \"\"\" Provide methods to help to parse different kind of values a Property could find. This class should be inherited by a Property. \"\"\" def _parse_datetime_values ( self ) -> List [ DateTime ]: \"\"\" Parses DateTime values. Example of a possible value of self.value: 19970714T123000Z,19970714T123300Z :return: A List of DateTimes representing the start of an event/component. \"\"\" list_of_datetimes : List [ DateTime ] = [] for item in self . value . split ( \",\" ): item = item . strip () instance = self . _parse_individual_datetime_or_duration_str ( item ) if not isinstance ( instance , DateTime ): raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a DateTime.\" ) list_of_datetimes . append ( instance ) return list_of_datetimes def _parse_date_values ( self ) -> List [ Date ]: \"\"\" Parse Date values. Example of a possible value of self.value: 19970101,19970120,19970217 :return: A list of pendulum.Date representing the start of an event/component. \"\"\" list_of_dates : List [ Date ] = [] for item in self . value . split ( \",\" ): instance = self . _parse_individual_date_str ( item ) if not isinstance ( instance , Date ): raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a Date.\" ) list_of_dates . append ( instance ) return list_of_dates @staticmethod def _parse_individual_date_str ( date : str ) -> Date : \"\"\" Parse an individual date string. :param date: A string representing a date. :return: A pendulum.Date. \"\"\" return Date ( int ( date [ 0 : 4 ]), int ( date [ 4 : 6 ]), int ( date [ 6 : 8 ])) _parse_date_values () Parse Date values. Example of a possible value of self.value: 19970101,19970120,19970217 Returns: Type Description List [ Date ] A list of pendulum.Date representing the start of an event/component. Source code in ical_library/ical_properties/periods.py 91 92 93 94 95 96 97 98 99 100 101 102 def _parse_date_values ( self ) -> List [ Date ]: \"\"\" Parse Date values. Example of a possible value of self.value: 19970101,19970120,19970217 :return: A list of pendulum.Date representing the start of an event/component. \"\"\" list_of_dates : List [ Date ] = [] for item in self . value . split ( \",\" ): instance = self . _parse_individual_date_str ( item ) if not isinstance ( instance , Date ): raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a Date.\" ) list_of_dates . append ( instance ) return list_of_dates _parse_datetime_values () Parses DateTime values. Example of a possible value of self.value: 19970714T123000Z,19970714T123300Z Returns: Type Description List [ DateTime ] A List of DateTimes representing the start of an event/component. Source code in ical_library/ical_properties/periods.py 77 78 79 80 81 82 83 84 85 86 87 88 89 def _parse_datetime_values ( self ) -> List [ DateTime ]: \"\"\" Parses DateTime values. Example of a possible value of self.value: 19970714T123000Z,19970714T123300Z :return: A List of DateTimes representing the start of an event/component. \"\"\" list_of_datetimes : List [ DateTime ] = [] for item in self . value . split ( \",\" ): item = item . strip () instance = self . _parse_individual_datetime_or_duration_str ( item ) if not isinstance ( instance , DateTime ): raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a DateTime.\" ) list_of_datetimes . append ( instance ) return list_of_datetimes _parse_individual_date_str ( date ) staticmethod Parse an individual date string. Parameters: Name Type Description Default date str A string representing a date. required Returns: Type Description Date A pendulum.Date. Source code in ical_library/ical_properties/periods.py 104 105 106 107 108 109 110 111 @staticmethod def _parse_individual_date_str ( date : str ) -> Date : \"\"\" Parse an individual date string. :param date: A string representing a date. :return: A pendulum.Date. \"\"\" return Date ( int ( date [ 0 : 4 ]), int ( date [ 4 : 6 ]), int ( date [ 6 : 8 ])) _TZOffset Bases: Property Helper class to represent a UTC offset. This class should be inherited. Add functions to parse the value as a fixed timezone offset. Source code in ical_library/ical_properties/tz_offset.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class _TZOffset ( Property ): \"\"\" Helper class to represent a UTC offset. This class should be inherited. Add functions to parse the value as a fixed timezone offset. \"\"\" def parse_value_as_seconds ( self ) -> int : \"\"\"Parse the value as seconds difference from UTC.\"\"\" plus_or_minus = self . value [ 0 ] hour = int ( self . value [ 1 : 3 ]) minute = int ( self . value [ 3 : 5 ]) seconds = int ( self . value [ 5 : 7 ]) if len ( self . value ) > 6 else 0 summed = seconds + 60 * ( minute + 60 * hour ) return summed if plus_or_minus == \"+\" else 0 - summed def as_timezone_object ( self ) -> FixedTimezone : \"\"\"Return the value of the property as a fixed timezone offset.\"\"\" return FixedTimezone ( self . parse_value_as_seconds ()) as_timezone_object () Return the value of the property as a fixed timezone offset. Source code in ical_library/ical_properties/tz_offset.py 22 23 24 def as_timezone_object ( self ) -> FixedTimezone : \"\"\"Return the value of the property as a fixed timezone offset.\"\"\" return FixedTimezone ( self . parse_value_as_seconds ()) parse_value_as_seconds () Parse the value as seconds difference from UTC. Source code in ical_library/ical_properties/tz_offset.py 13 14 15 16 17 18 19 20 def parse_value_as_seconds ( self ) -> int : \"\"\"Parse the value as seconds difference from UTC.\"\"\" plus_or_minus = self . value [ 0 ] hour = int ( self . value [ 1 : 3 ]) minute = int ( self . value [ 3 : 5 ]) seconds = int ( self . value [ 5 : 7 ]) if len ( self . value ) > 6 else 0 summed = seconds + 60 * ( minute + 60 * hour ) return summed if plus_or_minus == \"+\" else 0 - summed","title":"Property helper classes"},{"location":"code/properties/help_classes/#help-classes","text":"Sometimes properties have a lot in common. Instead of constantly redefining all methods, we simply create an abstraction from the properties which we call help classes. This is the list of all help classes.","title":"Help classes"},{"location":"code/properties/help_classes/#ical_library.ical_properties.ints._IntProperty","text":"Bases: Property This property class should be inherited. It represents a property that contain just an int as value. Source code in ical_library/ical_properties/ints.py 4 5 6 7 8 9 10 class _IntProperty ( Property ): \"\"\"This property class should be inherited. It represents a property that contain just an int as value.\"\"\" @property def int_value ( self ) -> int : \"\"\"Return the value as an int.\"\"\" return int ( self . value )","title":"_IntProperty"},{"location":"code/properties/help_classes/#ical_library.ical_properties.ints._IntProperty.int_value","text":"Return the value as an int.","title":"int_value"},{"location":"code/properties/help_classes/#ical_library.ical_properties.dt._DTBoth","text":"Bases: Property This property class should be inherited. It represents a property that contain a datetime or date as value. Source code in ical_library/ical_properties/dt.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class _DTBoth ( Property ): \"\"\"This property class should be inherited. It represents a property that contain a datetime or date as value.\"\"\" @property def datetime_or_date_value ( self ) -> Union [ Date , DateTime ]: \"\"\"Return the value as a DateTime or Date value taking into account the optional TZID property parameter.\"\"\" value = dt_utils . parse_date_or_datetime ( self . value ) if isinstance ( value , DateTime ): tz_id = self . get_property_parameter ( \"TZID\" ) if value . tz or not tz_id : return value return self . parent . tree_root . get_aware_dt_for_timezone ( dt = value , tzid = tz_id ) elif isinstance ( value , Date ): return value else : raise TypeError ( f \"Unknown { type ( value ) =} returned for { value =} .\" ) def get_datetime_or_date_value_in_specific_tz ( self , tz : FixedTimezone ) -> Union [ Date , DateTime ]: \"\"\"Return the value as a DateTime or Date value in a specific timezone.\"\"\" value = dt_utils . parse_date_or_datetime ( self . value ) if isinstance ( value , DateTime ): return value . in_timezone ( tz ) elif isinstance ( value , Date ): return value else : raise TypeError ( f \"Unknown { type ( value ) =} returned for { value =} .\" )","title":"_DTBoth"},{"location":"code/properties/help_classes/#ical_library.ical_properties.dt._DTBoth.datetime_or_date_value","text":"Return the value as a DateTime or Date value taking into account the optional TZID property parameter.","title":"datetime_or_date_value"},{"location":"code/properties/help_classes/#ical_library.ical_properties.dt._DTBoth.get_datetime_or_date_value_in_specific_tz","text":"Return the value as a DateTime or Date value in a specific timezone. Source code in ical_library/ical_properties/dt.py 28 29 30 31 32 33 34 35 36 def get_datetime_or_date_value_in_specific_tz ( self , tz : FixedTimezone ) -> Union [ Date , DateTime ]: \"\"\"Return the value as a DateTime or Date value in a specific timezone.\"\"\" value = dt_utils . parse_date_or_datetime ( self . value ) if isinstance ( value , DateTime ): return value . in_timezone ( tz ) elif isinstance ( value , Date ): return value else : raise TypeError ( f \"Unknown { type ( value ) =} returned for { value =} .\" )","title":"get_datetime_or_date_value_in_specific_tz"},{"location":"code/properties/help_classes/#ical_library.ical_properties.dt._DTSingular","text":"Bases: Property This property class should be inherited. It represents a property that can only contain a datetime as value. Source code in ical_library/ical_properties/dt.py 39 40 41 42 43 44 45 46 47 48 49 class _DTSingular ( Property ): \"\"\"This property class should be inherited. It represents a property that can only contain a datetime as value.\"\"\" @property def datetime ( self ) -> DateTime : \"\"\"Return the value as a DateTime value taking into account the optional TZID property parameter.\"\"\" value = pendulum . parse ( self . value , tz = None ) tz_id = self . get_property_parameter ( \"TZID\" ) if value . tz or not tz_id : return value return self . parent . tree_root . get_aware_dt_for_timezone ( dt = value , tzid = tz_id )","title":"_DTSingular"},{"location":"code/properties/help_classes/#ical_library.ical_properties.dt._DTSingular.datetime","text":"Return the value as a DateTime value taking into account the optional TZID property parameter.","title":"datetime"},{"location":"code/properties/help_classes/#ical_library.ical_properties.cal_address._CalAddress","text":"Bases: Property Source code in ical_library/ical_properties/cal_address.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class _CalAddress ( Property ): @property def persons_name ( self ) -> Optional [ str ]: \"\"\"Return the persons name, identified by the CN property parameter.\"\"\" return self . get_property_parameter ( \"CN\" ) @property def email ( self ) -> Optional [ str ]: \"\"\"Return the email if the value starts with `mailto:`. Otherwise return None.\"\"\" if self . value . startswith ( \"mailto:\" ): return self . value [ len ( \"mailto:\" ) :] return None @property def cu_type ( self ) -> str : \"\"\"Return the CUTYPE.\"\"\" return self . get_property_parameter_default ( \"CUTYPE\" , default = \"INDIVIDUAL\" ) @property def member ( self ) -> Optional [ str ]: \"\"\"Return the membership property parameter.\"\"\" return self . get_property_parameter ( \"MEMBER\" ) @property def role ( self ) -> str : \"\"\"Return the role of the person.\"\"\" return self . get_property_parameter_default ( \"ROLE\" , default = \"REQ-PARTICIPANT\" ) @property def participation_status ( self ) -> str : \"\"\"Return the participation status, indicating whether the person will be present or not.\"\"\" return self . get_property_parameter_default ( \"PARTSTAT\" , default = \"NEEDS-ACTION\" )","title":"_CalAddress"},{"location":"code/properties/help_classes/#ical_library.ical_properties.cal_address._CalAddress.cu_type","text":"Return the CUTYPE.","title":"cu_type"},{"location":"code/properties/help_classes/#ical_library.ical_properties.cal_address._CalAddress.email","text":"Return the email if the value starts with mailto: . Otherwise return None.","title":"email"},{"location":"code/properties/help_classes/#ical_library.ical_properties.cal_address._CalAddress.member","text":"Return the membership property parameter.","title":"member"},{"location":"code/properties/help_classes/#ical_library.ical_properties.cal_address._CalAddress.participation_status","text":"Return the participation status, indicating whether the person will be present or not.","title":"participation_status"},{"location":"code/properties/help_classes/#ical_library.ical_properties.cal_address._CalAddress.persons_name","text":"Return the persons name, identified by the CN property parameter.","title":"persons_name"},{"location":"code/properties/help_classes/#ical_library.ical_properties.cal_address._CalAddress.role","text":"Return the role of the person.","title":"role"},{"location":"code/properties/help_classes/#ical_library.ical_properties.periods._PeriodFunctionality","text":"Bases: Property Provide methods to help to parse duration values. This class should be inherited by a Property. Source code in ical_library/ical_properties/periods.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class _PeriodFunctionality ( Property ): \"\"\" Provide methods to help to parse duration values. This class should be inherited by a Property. \"\"\" def _parse_period_values ( self ) -> List [ Tuple [ DateTime , DateTime ]]: \"\"\" Parse multiple values, delimited by comma's, representing periods. Example value for self.value: 19960403T020000Z/19960403T040000Z,19960404T010000Z/PT3H :return: List of tuples containing two DateTimes representing the start and end of the duration respectively. \"\"\" list_of_periods : List [ Tuple [ DateTime , DateTime ]] = [] for item in self . value . split ( \",\" ): item = item . strip () instance = self . _parse_individual_duration_str ( item ) if not isinstance ( instance , tuple ) or len ( instance ) != 2 : raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a tuple.\" ) for index , sub_instance in enumerate ( instance ): if not isinstance ( sub_instance , DateTime ): raise TypeError ( f \" { instance [ index ] =} is of { type ( sub_instance ) =} while it should be of type \" f \"Tuple[DateTime, DateTime].\" ) list_of_periods . append ( instance ) return list_of_periods def _parse_individual_datetime_or_duration_str ( self , datetime_or_duration_str : str ) -> Union [ DateTime , Duration ]: \"\"\" Parse an individual datetime or duration string. :param datetime_or_duration_str: A string represent either a datetime or duration. :return: A pendulum.DateTime if the string represented a datetime. Return a pendulum.Duration otherwise. \"\"\" tz_id = self . get_property_parameter ( \"TZID\" ) tz = self . parent . tree_root . get_timezone ( tz_id ) . get_as_timezone_object () if tz_id else None return pendulum . parse ( datetime_or_duration_str , tz = tz ) def _parse_individual_duration_str ( self , period_str : str ) -> Tuple [ DateTime , DateTime ]: \"\"\" Parse an individual period represented by DateTime/DateTime or DateTime/Duration. :param period_str: The period to parse. Examples: 19960403T020000Z/19960403T040000Z or 19960404T010000Z/PT3H :return: A tuple containing two DateTimes representing the start and end of the duration respectively. \"\"\" first_str , second_str = period_str . split ( \"/\" ) first_instance : DateTime = self . _parse_individual_datetime_or_duration_str ( first_str ) second_instance : Union [ DateTime , Duration ] = self . _parse_individual_datetime_or_duration_str ( second_str ) if not isinstance ( first_instance , DateTime ): raise TypeError ( f \"Expected { period_str =} to contain a DateTime as first argument.\" ) if isinstance ( second_instance , DateTime ): return first_instance , second_instance elif isinstance ( second_instance , Duration ): computed_datetime : DateTime = first_instance + second_instance # type: ignore # Pendulum at fault return first_instance , computed_datetime else : raise TypeError ( f \"Expected { period_str =} to contain a DateTime or Duration as second argument.\" )","title":"_PeriodFunctionality"},{"location":"code/properties/help_classes/#ical_library.ical_properties.periods._PeriodFunctionality._parse_individual_datetime_or_duration_str","text":"Parse an individual datetime or duration string. Parameters: Name Type Description Default datetime_or_duration_str str A string represent either a datetime or duration. required Returns: Type Description Union [ DateTime , Duration ] A pendulum.DateTime if the string represented a datetime. Return a pendulum.Duration otherwise. Source code in ical_library/ical_properties/periods.py 39 40 41 42 43 44 45 46 47 def _parse_individual_datetime_or_duration_str ( self , datetime_or_duration_str : str ) -> Union [ DateTime , Duration ]: \"\"\" Parse an individual datetime or duration string. :param datetime_or_duration_str: A string represent either a datetime or duration. :return: A pendulum.DateTime if the string represented a datetime. Return a pendulum.Duration otherwise. \"\"\" tz_id = self . get_property_parameter ( \"TZID\" ) tz = self . parent . tree_root . get_timezone ( tz_id ) . get_as_timezone_object () if tz_id else None return pendulum . parse ( datetime_or_duration_str , tz = tz )","title":"_parse_individual_datetime_or_duration_str"},{"location":"code/properties/help_classes/#ical_library.ical_properties.periods._PeriodFunctionality._parse_individual_duration_str","text":"Parse an individual period represented by DateTime/DateTime or DateTime/Duration. Parameters: Name Type Description Default period_str str The period to parse. Examples: 19960403T020000Z/19960403T040000Z or 19960404T010000Z/PT3H required Returns: Type Description Tuple [ DateTime , DateTime ] A tuple containing two DateTimes representing the start and end of the duration respectively. Source code in ical_library/ical_properties/periods.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def _parse_individual_duration_str ( self , period_str : str ) -> Tuple [ DateTime , DateTime ]: \"\"\" Parse an individual period represented by DateTime/DateTime or DateTime/Duration. :param period_str: The period to parse. Examples: 19960403T020000Z/19960403T040000Z or 19960404T010000Z/PT3H :return: A tuple containing two DateTimes representing the start and end of the duration respectively. \"\"\" first_str , second_str = period_str . split ( \"/\" ) first_instance : DateTime = self . _parse_individual_datetime_or_duration_str ( first_str ) second_instance : Union [ DateTime , Duration ] = self . _parse_individual_datetime_or_duration_str ( second_str ) if not isinstance ( first_instance , DateTime ): raise TypeError ( f \"Expected { period_str =} to contain a DateTime as first argument.\" ) if isinstance ( second_instance , DateTime ): return first_instance , second_instance elif isinstance ( second_instance , Duration ): computed_datetime : DateTime = first_instance + second_instance # type: ignore # Pendulum at fault return first_instance , computed_datetime else : raise TypeError ( f \"Expected { period_str =} to contain a DateTime or Duration as second argument.\" )","title":"_parse_individual_duration_str"},{"location":"code/properties/help_classes/#ical_library.ical_properties.periods._PeriodFunctionality._parse_period_values","text":"Parse multiple values, delimited by comma's, representing periods. Example value for self.value: 19960403T020000Z/19960403T040000Z,19960404T010000Z/PT3H Returns: Type Description List [ Tuple [ DateTime , DateTime ]] List of tuples containing two DateTimes representing the start and end of the duration respectively. Source code in ical_library/ical_properties/periods.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def _parse_period_values ( self ) -> List [ Tuple [ DateTime , DateTime ]]: \"\"\" Parse multiple values, delimited by comma's, representing periods. Example value for self.value: 19960403T020000Z/19960403T040000Z,19960404T010000Z/PT3H :return: List of tuples containing two DateTimes representing the start and end of the duration respectively. \"\"\" list_of_periods : List [ Tuple [ DateTime , DateTime ]] = [] for item in self . value . split ( \",\" ): item = item . strip () instance = self . _parse_individual_duration_str ( item ) if not isinstance ( instance , tuple ) or len ( instance ) != 2 : raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a tuple.\" ) for index , sub_instance in enumerate ( instance ): if not isinstance ( sub_instance , DateTime ): raise TypeError ( f \" { instance [ index ] =} is of { type ( sub_instance ) =} while it should be of type \" f \"Tuple[DateTime, DateTime].\" ) list_of_periods . append ( instance ) return list_of_periods","title":"_parse_period_values"},{"location":"code/properties/help_classes/#ical_library.ical_properties.periods._ExOrRDate","text":"Bases: _PeriodFunctionality Provide methods to help to parse different kind of values a Property could find. This class should be inherited by a Property. Source code in ical_library/ical_properties/periods.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class _ExOrRDate ( _PeriodFunctionality ): \"\"\" Provide methods to help to parse different kind of values a Property could find. This class should be inherited by a Property. \"\"\" def _parse_datetime_values ( self ) -> List [ DateTime ]: \"\"\" Parses DateTime values. Example of a possible value of self.value: 19970714T123000Z,19970714T123300Z :return: A List of DateTimes representing the start of an event/component. \"\"\" list_of_datetimes : List [ DateTime ] = [] for item in self . value . split ( \",\" ): item = item . strip () instance = self . _parse_individual_datetime_or_duration_str ( item ) if not isinstance ( instance , DateTime ): raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a DateTime.\" ) list_of_datetimes . append ( instance ) return list_of_datetimes def _parse_date_values ( self ) -> List [ Date ]: \"\"\" Parse Date values. Example of a possible value of self.value: 19970101,19970120,19970217 :return: A list of pendulum.Date representing the start of an event/component. \"\"\" list_of_dates : List [ Date ] = [] for item in self . value . split ( \",\" ): instance = self . _parse_individual_date_str ( item ) if not isinstance ( instance , Date ): raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a Date.\" ) list_of_dates . append ( instance ) return list_of_dates @staticmethod def _parse_individual_date_str ( date : str ) -> Date : \"\"\" Parse an individual date string. :param date: A string representing a date. :return: A pendulum.Date. \"\"\" return Date ( int ( date [ 0 : 4 ]), int ( date [ 4 : 6 ]), int ( date [ 6 : 8 ]))","title":"_ExOrRDate"},{"location":"code/properties/help_classes/#ical_library.ical_properties.periods._ExOrRDate._parse_date_values","text":"Parse Date values. Example of a possible value of self.value: 19970101,19970120,19970217 Returns: Type Description List [ Date ] A list of pendulum.Date representing the start of an event/component. Source code in ical_library/ical_properties/periods.py 91 92 93 94 95 96 97 98 99 100 101 102 def _parse_date_values ( self ) -> List [ Date ]: \"\"\" Parse Date values. Example of a possible value of self.value: 19970101,19970120,19970217 :return: A list of pendulum.Date representing the start of an event/component. \"\"\" list_of_dates : List [ Date ] = [] for item in self . value . split ( \",\" ): instance = self . _parse_individual_date_str ( item ) if not isinstance ( instance , Date ): raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a Date.\" ) list_of_dates . append ( instance ) return list_of_dates","title":"_parse_date_values"},{"location":"code/properties/help_classes/#ical_library.ical_properties.periods._ExOrRDate._parse_datetime_values","text":"Parses DateTime values. Example of a possible value of self.value: 19970714T123000Z,19970714T123300Z Returns: Type Description List [ DateTime ] A List of DateTimes representing the start of an event/component. Source code in ical_library/ical_properties/periods.py 77 78 79 80 81 82 83 84 85 86 87 88 89 def _parse_datetime_values ( self ) -> List [ DateTime ]: \"\"\" Parses DateTime values. Example of a possible value of self.value: 19970714T123000Z,19970714T123300Z :return: A List of DateTimes representing the start of an event/component. \"\"\" list_of_datetimes : List [ DateTime ] = [] for item in self . value . split ( \",\" ): item = item . strip () instance = self . _parse_individual_datetime_or_duration_str ( item ) if not isinstance ( instance , DateTime ): raise TypeError ( f \" { instance } is of { type ( instance ) =} while it should be a DateTime.\" ) list_of_datetimes . append ( instance ) return list_of_datetimes","title":"_parse_datetime_values"},{"location":"code/properties/help_classes/#ical_library.ical_properties.periods._ExOrRDate._parse_individual_date_str","text":"Parse an individual date string. Parameters: Name Type Description Default date str A string representing a date. required Returns: Type Description Date A pendulum.Date. Source code in ical_library/ical_properties/periods.py 104 105 106 107 108 109 110 111 @staticmethod def _parse_individual_date_str ( date : str ) -> Date : \"\"\" Parse an individual date string. :param date: A string representing a date. :return: A pendulum.Date. \"\"\" return Date ( int ( date [ 0 : 4 ]), int ( date [ 4 : 6 ]), int ( date [ 6 : 8 ]))","title":"_parse_individual_date_str"},{"location":"code/properties/help_classes/#ical_library.ical_properties.tz_offset._TZOffset","text":"Bases: Property Helper class to represent a UTC offset. This class should be inherited. Add functions to parse the value as a fixed timezone offset. Source code in ical_library/ical_properties/tz_offset.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class _TZOffset ( Property ): \"\"\" Helper class to represent a UTC offset. This class should be inherited. Add functions to parse the value as a fixed timezone offset. \"\"\" def parse_value_as_seconds ( self ) -> int : \"\"\"Parse the value as seconds difference from UTC.\"\"\" plus_or_minus = self . value [ 0 ] hour = int ( self . value [ 1 : 3 ]) minute = int ( self . value [ 3 : 5 ]) seconds = int ( self . value [ 5 : 7 ]) if len ( self . value ) > 6 else 0 summed = seconds + 60 * ( minute + 60 * hour ) return summed if plus_or_minus == \"+\" else 0 - summed def as_timezone_object ( self ) -> FixedTimezone : \"\"\"Return the value of the property as a fixed timezone offset.\"\"\" return FixedTimezone ( self . parse_value_as_seconds ())","title":"_TZOffset"},{"location":"code/properties/help_classes/#ical_library.ical_properties.tz_offset._TZOffset.as_timezone_object","text":"Return the value of the property as a fixed timezone offset. Source code in ical_library/ical_properties/tz_offset.py 22 23 24 def as_timezone_object ( self ) -> FixedTimezone : \"\"\"Return the value of the property as a fixed timezone offset.\"\"\" return FixedTimezone ( self . parse_value_as_seconds ())","title":"as_timezone_object"},{"location":"code/properties/help_classes/#ical_library.ical_properties.tz_offset._TZOffset.parse_value_as_seconds","text":"Parse the value as seconds difference from UTC. Source code in ical_library/ical_properties/tz_offset.py 13 14 15 16 17 18 19 20 def parse_value_as_seconds ( self ) -> int : \"\"\"Parse the value as seconds difference from UTC.\"\"\" plus_or_minus = self . value [ 0 ] hour = int ( self . value [ 1 : 3 ]) minute = int ( self . value [ 3 : 5 ]) seconds = int ( self . value [ 5 : 7 ]) if len ( self . value ) > 6 else 0 summed = seconds + 60 * ( minute + 60 * hour ) return summed if plus_or_minus == \"+\" else 0 - summed","title":"parse_value_as_seconds"}]}